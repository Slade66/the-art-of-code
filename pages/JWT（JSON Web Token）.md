-
- **JWT 的工作流程**
	- **用户登录：**用户通过用户名和密码等凭据发起登录请求。
	- **服务器验证：**服务器检查凭据是否正确。
	- **生成并发送 JWT：**若验证通过，服务器会生成一个 JWT（其中包含用户 ID、角色等信息，并设置过期时间），然后随响应返回给客户端。
	- **客户端存储 JWT：**客户端（如浏览器）收到 JWT 后，会将其保存，常见的存储位置包括 `localStorage`、`sessionStorage` 或 `HttpOnly Cookie`。
	- **携带 JWT 发送请求：**当客户端访问受保护的路由或资源时，会在请求头的 `Authorization` 字段中附带 JWT，通常格式为：`Authorization: Bearer <token>`。
	- **服务器验证 JWT：**服务器收到请求后，会检查 `Authorization` Header，并验证其中的 token 签名。
		- 如果签名有效，服务器会信任 token 中的信息（如用户 ID），并据此处理请求。
		- 如果签名无效或已过期，服务器会拒绝请求，返回 `401 Unauthorized` 或 `403 Forbidden` 状态码。
- **JWT 的优缺点**
	- **优点：**
		- **无状态：**服务器无需保存任何与用户会话相关的状态信息（如 session），用户的身份信息都包含在客户端自行携带的令牌中。
		- **自包含：**
			- 相比之下，`Session ID` 本身只是一串没有实际意义的随机字符串。当你需要知道用户的角色时，服务器必须拿着 `Session ID` 这把“钥匙”，到中央会话存储（如 Redis 或数据库）中查询，才能取回对应的用户角色信息。
			- 这就意味着，对于大多数需要权限验证的请求，服务器都要额外执行一次 I/O 操作：去 Redis 或数据库中查 Session。
			- 而 JWT 的 Payload 则可以直接携带所需的用户信息，从而避免频繁查询数据库。
	- **缺点：**
		- **签发的 Token 在过期前无法被主动废弃：**一旦 JWT 被签发，就会在过期时间到来之前始终有效。如果用户的 Token 泄露，服务端无法立即让它失效。
-