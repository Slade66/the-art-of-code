-
- **JWT 是什么？**
	- JWT 是一个防篡改的身份证。服务器在认证用户后生成 JWT 并返回给客户端，客户端在后续请求中携带该令牌。服务器只需验证 JWT 的签名合法性，就能识别请求发起者及其权限，而无需再次查询数据库。
	- JWT 是一个开放标准（RFC 7519），它定义了一种紧凑、URL 安全且自包含的方式，用于在各方之间以 JSON 对象的形式安全地传输信息。
	- 该标准主要定义了两种类型的 JWT：
		- **JWS（JSON Web Signature）：**签名的令牌。这是最常见的类型，用于身份验证和授权。令牌的内容是 Base64Url 编码的，任何人都可以读取，但它包含一个数字签名，用于验证其完整性和真实性。
		- **JWE（JSON Web Encryption）：**加密的令牌。在这种情况下，令牌的有效负载是加密的，确保了机密性，只有预期的接收方才能读取其内容。
- **JWT 的应用场景**
	- **授权（Authorization）：**这是 JWT 最常见的应用。用户登录成功后，服务器返回一个 JWT。之后，客户端在每次请求中携带该令牌，服务器据此验证用户的访问权限，决定是否允许访问受保护的路由、服务或资源。
	- **单点登录（Single Sign-On, SSO）：**JWT 非常适合实现 SSO。用户只需一次身份验证，即可使用同一个令牌无缝访问多个相互信任的应用或域，从而大幅提升用户体验。
	- **安全信息交换：**JWT 也可用于在各方之间安全传递信息。由于令牌带有数字签名，接收方可以确认信息来源可靠（真实性）且在传输过程中未被篡改（完整性）。
- **JWT 的结构**
	- JWT 是一个由三部分组成的字符串，每部分之间用点（`.`）分隔，并经过特殊编码和签名。
	- **示例：**`xxxxx.yyyyy.zzzzz`。
	- **Header（头部）：**
		- 描述令牌的元数据，例如签名算法。
		- Header 是一个 JSON 对象，通常包含以下两个字段：
			- `typ`：令牌的类型，其值固定为 `"JWT"`。
			- `alg`：使用的签名算法，例如 `HS256`（HMAC SHA256）或 `RS256`（RSA SHA256）。
		- **例子：**
			- ```json
			  {
			    "alg": "HS256",
			    "typ": "JWT"
			  }
			  ```
		- 这部分 JSON 数据会经过 Base64Url 编码，形成 JWT 的第一部分。
	- **Payload（载荷）：**
		- 负载是 JWT 的主体部分，是一个 JSON 对象，包含实际传输的数据，被称为“声明”（Claims）。
		- 声明是 Payload JSON 对象中的键值对。
		- **JWT 的规范将声明分为三类：**
			- **注册声明：**
				- JWT 规范预定义的一组声明，它们不是强制性的，但推荐使用。
				- 这些声明的键名都是单词前三个字母的缩写。
				- `iss`：Issuer，签发者
					- 接收方可以用这个值来验证签发者是否是它所信任的。
				- `sub`：Subject，主题
					- 明确指明了这个令牌代表的是哪个用户。通常是用户的 ID。
				- `aud`：Audience，受众
					- 表明该 JWT 的接收方是谁。如果一个服务收到了一个 `aud` 不包含自己的 JWT，它应该拒绝该令牌。这可以防止一个为服务 A 签发的令牌被恶意用到服务 B 上。
				- `exp`：Expiration Time，过期时间
					- 在此时间之后，该 JWT 将不再被接受。
				- `nbf`：Not Before，生效时间
					- 在此时间之前，该 JWT 将不会被接受。
				- `iat`：Issued At，签发时间
					- 定义了该 JWT 是何时被签发的。可用于确定 JWT 的“年龄”。
				- `jti`：JWT ID，令牌唯一标识
					- 可以将 `jti` 存入数据库或缓存中。当用户登出时，可以将此 `jti` 加入黑名单，从而实现令牌的吊销。
			- 公共声明（略）
			- **私有声明：**
				- 这类声明是通信双方（比如你自己的前端和后端服务）共同协商自定义的、用于传递应用需要的特定信息的声明。
				- **示例：**
					- ```json
					  {
					    "username": "johndoe",
					    "role": "admin",
					    "permissions": ["create", "read", "update"],
					    "department_id": 42
					  }
					  ```
		- **完整 Payload 示例：**
			- 一个典型的 JWT Payload 会混合使用这三类声明，但最常见的是注册声明和私有声明的组合。
			- ```json
			  {
			    // --- 注册声明 (Registered Claims) ---
			    "iss": "my-auth-service",
			    "sub": "user123",
			    "aud": "my-main-api",
			    "exp": 1678886400, // 假设这是一个未来的时间戳
			    "iat": 1678882800, // 假设这是当前的时间戳
			    "jti": "uuid-for-this-token-abcdef",
			  
			    // --- 私有声明 (Private Claims) ---
			    "name": "John Doe",
			    "email": "johndoe@example.com",
			    "roles": ["editor", "subscriber"],
			    "premium_user": true
			  }
			  ```
		- 这部分 JSON 数据也会经过 Base64Url 编码，形成 JWT 的第二部分。
	- **Signature（签名）：**
		- **作用：**签名用于验证消息的完整性。它能确保在传输过程中，JWT 的 Header 和 Payload 没有被篡改。同时，如果签名使用的是私钥，它还能验证 JWT 的发送者确实是它所声称的身份。
		- **生成过程：**要创建 JWT 的签名部分，首先将 Base64Url 编码后的 Header 和 Payload 用点（`.`）连接成一个字符串，然后使用 Header 中 `alg` 字段指定的算法和相应的密钥（私钥或共享密钥）对该字符串进行签名。
		- **使用 Payload 前，先验证签名：**JWT 的三段式结构本身体现了一种对安全至关重要的验证顺序。不了解其原理的开发者可能会先解码令牌，再直接使用 Payload 中的声明。但正确且安全的做法是“签名优先”：服务器在信任 Header 或 Payload 中的任何信息之前，必须先验证签名的有效性。
		- **算法混淆漏洞：**签名的验证方法由 Header 中的 `alg` 声明指定，但 Header 本身又是待验证的数据的一部分。这种“鸡生蛋、蛋生鸡”的情况正是 JWT 著名的“算法混淆”漏洞的根源。安全的实现绝不能盲目信任 `alg` 头部，而必须使用服务器预先配置的预期算法来进行验证。
	- **注意：**
		- Header 和 Payload 只是经过 Base64Url 编码，并未加密，因此其中的数据是明文的，任何人都可以解码它并读取其中的内容。签名的作用在于保证数据的完整性和真实性，而非机密性。因此，绝对不要在 Payload 中存放敏感信息，比如用户的密码。
	- **示例：**
		- header JSON：`{"alg":"HS256","typ":"JWT"}`
		- payload JSON：`{"sub":"1234567890","name":"John Doe","admin":true}`
		- 它们分别被编码成两段短字符串，再加上签名，拼成：
			- `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`
- **JWT 的工作流程**
	- **用户登录：**用户通过用户名和密码等凭据发起登录请求。
	- **服务器验证：**服务器检查凭据是否正确。
	- **生成并发送 JWT：**若验证通过，服务器会生成一个 JWT（其中包含用户 ID、角色等关键信息，并设置过期时间），然后随响应返回给客户端。
	- **客户端存储 JWT：**客户端（如浏览器）收到 JWT 后，会将其保存，常见的存储位置包括 `localStorage`、`sessionStorage` 或 `HttpOnly Cookie`。
	- **携带 JWT 发送请求：**当客户端访问受保护的路由或资源时，会在请求头的 `Authorization` 字段中附带 JWT，通常格式为：`Authorization: Bearer <token>`。
	- **服务器验证 JWT：**服务器收到请求后，会检查 `Authorization` Header，并验证其中的 token 签名。
		- 如果签名有效，服务器会进一步检查 token 中的声明：
			- 检查 `exp` 声明，确保令牌没有过期。
			- 检查 `iss` 和 `aud` 声明，确保令牌是由可信方签发，并且是发给自己的。
			- 最后，才会信任 Payload 中的私有声明（如 `roles`），并继续处理请求。
		- 如果签名无效或已过期，服务器会拒绝请求，返回 `401 Unauthorized` 或 `403 Forbidden` 状态码。
- **JWT 的优缺点**
	- **优点：**
		- **无状态：**服务器无需保存任何与用户会话相关的状态信息（如 session），用户的身份信息都包含在客户端自行携带的令牌中。
		- **自包含：**
			- 令牌本身就携带了验证用户身份和权限所需的全部信息。
			- 相比之下，`Session ID` 只是一串没有实际意义的随机字符串，所有状态信息都保存在服务器端。当需要知道用户角色时，服务器必须拿着这把 `Session ID` 的“钥匙”，去中央会话存储（如 Redis 或数据库）中查询，才能取回对应的用户角色。
			- 这就意味着，对于大多数需要权限验证的请求，服务器都要额外执行一次 I/O 操作：去 Redis 或数据库中查 Session。
			- 而 JWT 的 Payload 则可以直接携带所需的用户信息，从而避免频繁查询数据库。
		- **紧凑：**
			- JWT 采用 `header.payload.signature` 的三段式结构，体积小巧。经过 Base64Url 编码后，非常适合通过 HTTP 的 `Authorization` 头部、URL 参数或 Cookie 进行传输。
		- **URL 安全：**
			- 浏览器和服务器会对 URL 中的 `+`、`/`、`=` 进行特殊处理。如果直接将 JWT 的原始 Base64 编码放入 URL 参数：
				- `/` 会被当作路径分隔符，导致 JWT 被切成多段。
				- `+` 会被转换为空格 `' '`。
				- JWT 末尾的 `=` 可能被某些服务器或解析库误认为多余的填充，从而被截掉或忽略。
			- 结果是服务端收到的 token 与原始值不同，导致签名校验失败。
			- 使用 Base64Url 编码可以避免这些特殊字符，确保 JWT 在 URL 或请求头中安全传输。
	- **缺点：**
		- **签发的 Token 在过期前无法被主动废弃：**一旦 JWT 被签发，就会在过期时间到来之前始终有效。如果用户的 Token 泄露，服务端无法立即让它失效。
- **JWT 签名算法**
	- JWT 规范支持多种算法，主要分为两类：对称算法和非对称算法。
	- **对称算法：**
		- **代表：**`HS256`（HMAC with SHA-256）
		- **密钥类型：**共享密钥（Shared Secret）
		- **工作原理：**使用同一个密钥生成和验证签名。签发方用密钥签名数据，接收方用相同密钥验证签名。
		- **比喻：**就像一把共享的房屋钥匙，任何拥有它的人既可以锁门（签名），也可以开门（验证）。
	- **非对称算法：**
		- **代表：**`RS256`（RSA with SHA-256）、`ES256`（ECDSA with P-256 and SHA-256）
		- **密钥类型：**公钥 / 私钥对（Public / Private Pair）
		- **工作原理：**使用一对数学上相关的密钥：私钥签名，公钥验证。私钥必须严格保密，公钥可以公开。
		- **比喻：**就像信封上的蜡封，只有拥有独特印章（私钥）的人能制作，任何知道印章图案（公钥）的人都可以验证真伪。
		  id:: 68d8e867-06fc-4fe6-9bbd-174805f435df
	- **算法的选择：**
		- **安全性：**在分布式系统中，非对称算法（如 RS256）通常更安全，因为它们无需共享密钥。私钥可以严格保存在认证服务器内部，从而大大降低密钥泄露的风险。相比之下，如果 HS256 的共享密钥在任何一个服务中泄露，攻击者就可能为整个系统伪造有效令牌。
		- **性能：**对称算法在计算上比非对称算法更快，但对于大多数 Web 应用的典型负载，这种性能差异通常可以忽略不计。
-