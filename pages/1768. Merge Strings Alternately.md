-
- ## Description
	- **题目链接：**https://leetcode.cn/problems/merge-strings-alternately/
	- **题目截图：**
		- ![1768. Merge Strings Alternately.png](../assets/1768._Merge_Strings_Alternately_1761499264905_0.png)
	- **题目意思：**
		- 将两个字符串 `word1` 和 `word2` 交替合并：
			- 从 `word1` 的第一个字符开始，然后是 `word2` 的第一个字符，接着 `word1` 的第二个字符，`word2` 的第二个字符……以此类推。
			- 如果其中一个字符串更长，就把剩下的部分直接追加到结果末尾。
		- 例如：`"abc"` 和 `"pqr"` → `"apbqcr"`
		- 目标是返回合并后的字符串。
- ## Solution A
	- ### Algorithm
		- #### Principle
			- 用两个指针分别指向字符串 1 和字符串 2，然后按轮次交替将指针指向的字符拷贝到切片中，并将对应指针右移。
		- #### Steps
			- 将 `word1` 和 `word2` 转为 `rune` 切片，便于处理字符。
			  logseq.order-list-type:: number
			- 初始化两个指针 `p1`、`p2` 分别用于遍历两个字符串，以及一个结果切片 `ans`（预分配总长度）。
			  logseq.order-list-type:: number
			- 使用布尔标志 `print_word1` 控制交替顺序。
			  logseq.order-list-type:: number
			- 在循环中：
			  logseq.order-list-type:: number
				- 若轮到 `word1` 且 `p1` 未越界，则将字符写入 `ans[idx]`，并递增 `idx` 和 `p1`。
				  logseq.order-list-type:: number
				- 若轮到 `word2` 且 `p2` 未越界，则将字符写入 `ans[idx]`，并递增 `idx` 和 `p2`。
				  logseq.order-list-type:: number
				- 每次循环切换交替标志。
				  logseq.order-list-type:: number
			- 最终将 `ans` 转为字符串返回。
			  logseq.order-list-type:: number
			- **关键：**独立的写入索引 `idx`，仅在实际写入字符时递增，避免了数组越界。
	- ### Code
		- ```go
		  func mergeAlternately(word1 string, word2 string) string {
		  	w1, w2 := []rune(word1), []rune(word2)
		  	w1_len, w2_len := len(w1), len(w2)
		  	p1, p2 := 0, 0
		  	ans := make([]rune, w1_len+w2_len)
		  	print_word1 := true
		  	for i, idx := 0, 0; p1 < w1_len || p2 < w2_len; i++ {
		  		if print_word1 {
		  			if p1 < w1_len {
		  				ans[idx] = w1[p1]
		  				idx++
		  				p1++
		  			}
		  		} else {
		  			if p2 < w2_len {
		  				ans[idx] = w2[p2]
		  				idx++
		  				p2++
		  			}
		  		}
		  		print_word1 = !print_word1
		  	}
		  	return string(ans)
		  }
		  ```