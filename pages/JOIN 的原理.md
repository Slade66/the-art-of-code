- **一句话：**把一张表作为“驱动表”，逐行读取，每行用 join key 去另一张表查找匹配行。
- **Simple Nested-Loop Join (SNLJ, 简单嵌套循环)**
	- 这是最基础、性能最差的算法（现在的 MySQL 极少直接使用，除非没有任何优化可用）。
	- **原理:**
		- ```python
		  for row_a in table_A:          # 扫描驱动表
		      for row_b in table_B:      # 扫描被驱动表（全表扫描）
		          if row_a.id == row_b.id:
		              yield (row_a, row_b)
		  ```
	- **性能:** 极差。如果 A 表 100 行，B 表 1000 行，B 表会被全表扫描 100 次，总比较次数 $100 \times 1000 = 10^5$
- **Index Nested-Loop Join**
	- 这是最理想的算法。要求**被驱动表**的连接字段上有**索引**。
	- **原理:**
		- 外表读一行
		- 拿着 join key
		- 到被驱动表 B 的**索引树**（B+ Tree）中查找。
		- 如果匹配，回表（如果需要）拿数据，组合返回。
	- **性能:** 极快。B 表不再是全表扫描，而是树的查找（复杂度 $O(\log N)$）。
	- **优化点:** 确保 `ON` 的字段在被驱动表上有索引。
- **Block Nested-Loop Join**
	- 如果内表没有索引，MySQL 会把外表的一批行放入一个缓存（join buffer），然后对内层表进行多次扫描，减少重复 I/O。
	- 像你把一握积木放手里，然后一次性在 B 盒里找这些编号对应的积木。
	- **原理:** 利用内存中的 **Join Buffer**。
		- 把驱动表 A 的一批数据（如 100 行）读入内存的 `Join Buffer` 中。
		- 扫描被驱动表 B 的每一行。
		- 拿 B 的当前行与内存 Buffer 中的这 100 行 A 数据进行比较（内存中比较极快）。
		- 重复上述过程，直到 A 表处理完。
	- **效果:** 大幅减少了扫描 B 表的次数（磁盘 I/O）。
		- 如果 Buffer 能装下整个 A 表，B 表只需扫描 1 次。
- **Hash Join (哈希连接, MySQL 8.0.18+ 引入)**
	- 这是 MySQL 8.0 的重大特性，用于替代 BNLJ。当**没有索引**时，Hash Join 比 BNLJ 快很多。无需刻意加索引（但也少了索引覆盖的优势）。
	- **原理 (分为两阶段):**
		- **Build Phase (构建阶段):** 扫描驱动表（小表），在内存中基于连接字段建立一个 **Hash Table**。
		- **Probe Phase (探测阶段):** 扫描被驱动表（大表），计算每行连接字段的哈希值，去内存中的 Hash Table 查找匹配。
	- **性能:** 复杂度接近 $O(M+N)$，不再是嵌套循环的 $O(M \times N)$。
- **优化：**
	- **JOIN 连接列必须有索引:**
		- 这样才能触发 INLJ。
		- 如果 join 字段是索引，那 join 就变成：
			- 外层表循环 O(N)
			- 内层表索引查找 O(logM)
		- 整体就是 **N * logM**，速度飞起。
		- 没有索引时，只有两种情况：
			- **Nested Loop + 全表扫描**（慢）
			- Hash Join（某些情况可以快，但占内存）
-