## 有什么用？
	- `git fetch` 让你在不影响自己工作的情况下，安全地审视远程仓库的变化。
	- **更新远程跟踪分支，但不合并到本地：**
		- `git fetch` 用于从远程仓库获取最新的代码更新，并将这些更新存储在本地的远程跟踪分支中。
		- 执行 `git fetch` 后，你的本地远程跟踪分支（如 `origin/main`）会得到更新，但你当前正在工作的本地分支（如 `main`）并不会自动更新。这样做的好处是，你可以在不影响本地代码的情况下，安全地查看远程仓库的最新状态。
		- 要将这些更改合并到你的本地分支，你需要手动执行 `git merge` 或 `git rebase` 命令。
	- **举例：**
		- 你的同事向远程的 `main` 分支推送了 3 个新的提交。
		- **`fetch` 之前：**你的 `main` 和 `origin/main` 指向同一个旧的提交。
		- **运行 `git fetch`：**
			- 这 3 个新的提交被下载到你的本地仓库。
			- 你的 `main` 分支没有动。
			- 你的 `origin/main` 这个“书签”向前移动了 3 个提交，指向了最新的位置。
		- **`fetch` 之后：**现在你可以清楚地看到你的 `main` 分支已经落后于 `origin/main` 了。你可以决定何时以及如何将这些更新合并进来。
- ## 怎么用？
	- **基本语法：**`git fetch <远程仓库名>`
		- `git fetch`：获取默认远程仓库（通常是 `origin`）的所有分支的更新。
			- 执行这个命令后，Git会连接到名为 `origin` 的远程仓库，并下载所有你本地不存在的提交和分支信息。这些信息被存储在本地的 `origin/main`, `origin/feature-branch` 等远程跟踪分支中。你本地的 `main` 或 `feature-branch` 分支并不会被改变。
		- **获取特定仓库特定分支的更新：**
			- ```bash
			  # 只获取 origin 仓库的 main 分支的更新
			  git fetch origin main
			  ```
	- **常用选项：**
		- `--prune` 或 `-p`：在获取前，删除本地那些在远程仓库中已被删除的“远程跟踪分支”。
		- `--all`：获取所有远程仓库的更新。
		- `--tags`：除了分支，还获取远程仓库的所有标签。
- ## 其它
	- **工作流程：**
		- **同步远程数据：**首先连接到远程仓库，检查并下载所有本地不存在的最新内容。
		- **更新本地引用**随后，将下载的数据更新到本地的“远程跟踪分支”，使其与远程仓库保持同步。
	- **默认行为：**
		- 当你执行 `git fetch` 时，Git 会自动判断从哪里拉取数据。它首先会检查你当前的分支是否已经关联了特定的远程上游分支。如果有关联，它会从那里拉取最新更改；如果没有，它则会默认从名为 `origin` 的远程仓库抓取数据，这个行为确保了即使你不指定远程仓库，`git fetch` 也能找到正确的目标。
	- **`git fetch` vs. `git pull`**
		- `git fetch`：只下载远程仓库的最新内容，但不进行合并。它是一个安全的操作，因为它只会更新你的本地远程跟踪分支（如 `origin/main`），而不会修改你当前的分支或代码。
		- `git pull`：相当于 `git fetch` + `git merge`。它会先从远程下载更新，然后立刻尝试将这些更新合并到你当前的本地分支。如果存在冲突，你需要立即解决。
		- **一句话总结：**想先看看再决定合不合并，用 `fetch`；想一步到位直接更新并合并，用 `pull`。
	- **主要应用场景：**
		- **安全地审查更新**：在开始一项新任务前，你可能想先了解团队其他成员在远程仓库提交了哪些新代码。这时，你可以使用 `git fetch` 来拉取最新变更，并将其存储在本地的远程跟踪分支中，这样做既不会影响你当前的工作，也能让你在合并前先进行审查。
		- **清理不存在的远程分支：**当团队成员删除了远程分支，你本地的远程跟踪分支就会变得无效但还会存在。通过使用 `git fetch --prune` 命令，你可以自动清理掉本地那些已经被删除的远程分支，保持本地仓库的整洁。
-