-
- ### WebSocket 是什么？
	- WebSocket 是一种应用层网络通信协议，专门用于解决 Web 应用的实时通信需求。
	- 它在单个 TCP 连接上提供全双工通信信道，一旦连接建立，就持续使用同一个 TCP 连接，支持客户端和服务器同时双向发送数据。
	- 现代浏览器都内置了 WebSocket API，无需安装第三方库，可以直接在网页的 JavaScript 代码中调用。
- ### 为什么需要 WebSocket？
  id:: 68a58205-1006-4b6c-ae66-bb1c8070652f
	- ### HTTP 协议的局限
		- HTTP 的通信模式很简单：客户端发起请求，服务器返回响应，然后连接关闭。每当需要获取新信息时，都必须重新发送请求。这是一种典型的"请求-响应"模式，服务器无法主动向客户端推送信息。对于请求静态页面等需求来说，这种模式完全够用，但随着 Web 应用日趋动态化和交互化，这种模式的局限性开始凸显。
		- 在 WebSocket 出现之前，为了实现实时通信（如聊天、通知），开发者不得不“hack” HTTP 协议，想出了各种“曲线救国”的办法：
			- **短轮询（Short Polling）：**客户端以固定间隔（如每 10 秒）重复请求服务器，询问是否有新消息。
				- **缺点：**
					- **资源浪费：**绝大多数请求都是无效的，大量冗余请求不断冲击服务器，不仅消耗客户端和服务器的计算资源，还占用了宝贵的网络带宽。
					- **高延迟：**如果消息在刚请求后产生，也必须等到下一个请求才能获取，导致消息传递的延迟最长可达一个轮询周期。
			- **长轮询（Long Polling）**：客户端发送请求后，服务器会挂起该请求而不立即响应，直到有新消息时才返回结果。客户端收到响应后，会立即再次发起新的长轮询请求。
				- **缺点：**
					- **连接开销大：**每次服务器返回响应后，客户端都需要立即重新建立新的 HTTP 请求。建立连接和传输 HTTP 头部都会带来额外开销。相比短轮询虽然节省了不少资源，但仍然较为低效。
		- HTTP 的客户端拉取模式已难以满足交互式应用的需求，而实时通信又依赖服务器主动推送。随着各种变通方案逐渐暴露局限，一个专为持久化（即客户端与服务器间的连接可长期保持）、双向通信而设计的标准化协议——WebSocket——应运而生。
	- ### WebSocket 的优势
		- **全双工通信**：在 WebSocket 连接中，客户端和服务器都可以随时向对方发送数据，互不干扰，这为真正的实时交互提供了可能。
		- **持久化连接**：与 HTTP 的"一次性"连接不同，WebSocket 在初始握手成功后，底层的 TCP 连接会一直保持打开状态。所有后续的数据交换都在同一个连接上进行，无需为每条消息重新建立连接。
		- **低传输开销**：WebSocket 引入了一种新的帧协议，后续的数据交换不再需要发送 HTTP 头信息，数据帧的头部很小，大大减少了因重复发送冗余 HTTP 头部而产生的网络开销，性能优势显著。
- ### WebSocket 是如何工作的？
	- WebSocket 的工作过程可分为两个阶段：握手和数据传输。
	- ### 握手阶段
		- WebSocket 利用 HTTP 协议完成初始握手，这是连接生命周期中至关重要且仅发生一次的过程，用于将通信从 HTTP 协议升级为 WebSocket 协议。
		- **客户端发起请求：**
		  logseq.order-list-type:: number
			- 客户端会发送一个特殊的 HTTP GET 请求，通过这个请求向服务器表明其升级协议的意图。
			- **客户端请求剖析：**
				- ```HTTP
				  GET /chat HTTP/1.1
				  Host: example.com:8000
				  Upgrade: websocket
				  Connection: Upgrade
				  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
				  Sec-WebSocket-Version: 13
				  ```
				- `Upgrade: websocket`：最核心的字段，用于明确告知服务器，客户端希望将连接升级为 WebSocket 协议。
				- `Connection: Upgrade`：告知服务器“我想升级当前的 HTTP 连接”，至于升级到哪种协议，则由 `Upgrade` 头部指定。
				- `Sec-WebSocket-Version: 13`：指定客户端期望使用的 WebSocket 协议版本。版本 13 是 RFC 6455 定义的现行标准。
				- `Sec-WebSocket-Key`：这是一个由客户端随机生成的、经过 Base64 编码的 16 字节随机数。
					- **作用：**
						- **防止缓存污染：**由于每次的 `Sec-WebSocket-Key` 都是随机生成的，保证了握手请求的唯一性，代理服务器无法对其进行缓存，从而确保请求都会被转发到后端服务器，避免后续客户端在请求相同路径时被直接返回缓存内容，而不是建立新的 WebSocket 连接。
		- **服务器返回响应：**
		  logseq.order-list-type:: number
			- 当服务器接收到并解析客户端请求后，如果支持 WebSocket 协议并同意升级，就会返回一个特殊的响应。
			- **服务端响应剖析：**
				- ```http
				  HTTP/1.1 101 Switching Protocols
				  Upgrade: websocket
				  Connection: Upgrade
				  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
				  ```
				- `HTTP/1.1 101 Switching Protocols`：该状态码表示握手成功，明确告知客户端服务器已同意切换协议。
				- `Upgrade: websocket` 和 `Connection: Upgrade`：服务器在响应中必须回显这两个头部，以确认协议升级。
				- `Sec-WebSocket-Accept`：这是握手完整性校验的关键字段，其值由服务器根据客户端提供的 `Sec-WebSocket-Key` 计算生成。客户端收到响应后会进行相同的计算，并验证结果是否一致，只有匹配时握手才算真正成功。
		- 握手成功后，这条 TCP 连接的通信规则将从 HTTP 切换为 WebSocket，后续数据传输将遵循 WebSocket 协议格式。
	- ### 数据传输阶段
		- 握手成功后，客户端与服务器之间的通信不再使用 HTTP 报文，而是以符合 WebSocket 协议的数据帧（Frame）格式传输。
		- 一个完整的应用层消息（如一条聊天文本）在传输时可以被拆分成一个或多个帧，从而更灵活地处理大块数据和消息流。
		- **帧头部：**
			- `Opcode`：定义了该帧的类型。
				- `0`：延续帧（Continuation Frame），表示该帧是前一帧的延续。
				- `1`：文本帧（Text Frame），载荷为 UTF-8 编码的文本数据。
				- `2`：二进制帧（Binary Frame），载荷为任意二进制数据。
				- `8`：连接关闭帧（Connection Close Frame），用于发起关闭握手。
				- `9`：Ping 帧，用于心跳检测。
				- `10`：Pong 帧，作为对 Ping 帧的响应。
				- 其它值为保留字段。
		- **`ws://` vs. `wss://`：**
			- WebSocket 协议使用专用的 URI 方案：`ws` 和 `wss`，与 `http://` 和 `https://` 的关系类似。
			- `ws://` 表示未加密通信，`wss://` 表示基于 TLS（SSL 的继任者）的加密通信。默认端口分别为 80 和 443。
			- 在生产环境中，应始终使用 `wss://`，这样 WebSocket 流量就能像 HTTPS 一样得到加密保护。
- ### ⚠️注意⚠️
	- ### 连接超时
		- 网络并不总是可靠的，一个看似稳定的 WebSocket 连接可能会因各种原因被“静默”断开。
		- **空闲超时：**
			- 许多中间设备（如 NAT 网关、防火墙、负载均衡器）会维护一张连接状态表，并设置空闲超时以节省资源。如果某个 TCP 连接在一段时间内没有数据传输，它们就会认为该连接已失效，并主动断开以释放资源，从而导致连接中断。
			- WebSocket 的特点是长时间保持连接，只有在有新消息时才会发送数据。这使得处于“等待”状态的 WebSocket 连接很容易被中间设备误判为无效并关闭。
			- 这种断开通常是“静默”的，客户端和服务器都无法立即察觉，直到真正需要使用时才发现连接已被切断。
		- **解决方案：**
			- **实现心跳机制：**
				- 永远不要假设长连接会一直保持在线，必须在应用层实现心跳与自动重连机制，这是确保 WebSocket 应用稳定性的基础。
				- WebSocket 协议内置了 `Ping` 和 `Pong` 帧，用于保持连接存活。客户端或服务器可以定期发送 `Ping` 帧，对方收到后会回复 `Pong` 帧。通过这种方式在信道上持续产生流量，向沿途的网络设备传递信号：“这个连接还在，请不要关闭它！”，重置中间设备的空闲计时器。
	- ### 网关的协议升级配置
		- 在实际的生产环境中，WebSocket 服务几乎总是部署在某种网关之后，而几乎所有反向代理服务器都需要显式配置才能正确支持 WebSocket。
		- **反向代理的原理：**
			- 反向代理并不像路由器那样只是原封不动地转发数据包，它会先接收客户端请求，再重新发起新的请求，更像是一个“中间人”。
			- **终止连接：**客户端实际上是和反向代理服务器建立连接，连接在反向代理处终止。客户端只知道反向代理的存在，并不了解后端的具体服务。
			- **重新发起：**反向代理在解析客户端请求后，会以客户端的身份，向后端真实服务器发起新的请求。
			- **转发响应：**后端服务器处理完成后，将结果返回给反向代理，再由反向代理转发给最初的客户端。
		- **为什么代理服务器需要特殊配置？**
			- WebSocket 握手依赖两个关键的 HTTP 头：`Upgrade: websocket` 和 `Connection: Upgrade`。
			- 标准的 HTTP 代理服务器往往不认识这些特殊头，会将其过滤掉，结果就是后端只收到一个普通的 HTTP 请求，完全不知道客户端想要升级协议，导致握手失败，连接无法建立。
			- 因此，我们需要在代理服务器中进行明确配置，确保在处理 WebSocket 请求时能够正确识别并保留这两个关键头，并将它们完整转发到后端，从而保证握手顺利完成。
		- **示例：Nginx 上的 WebSocket 配置**
			- 在 Nginx 中，只需添加几行配置即可支持 WebSocket：
			- ```nginx
			  server {
			      listen 80;
			      server_name your_domain.com;
			  
			      location /ws/ {
			          # WebSocket 代理配置
			          # 将客户端请求转发到后端 WebSocket 服务
			          proxy_pass http://backend_server;
			  
			          # WebSocket 核心配置：
			          # 1. 使用 HTTP/1.1 与后端通信（WebSocket 协议需要）
			          proxy_http_version 1.1;
			  
			          # 2. 转发客户端的 Upgrade 请求头，告知后端客户端想升级协议
			          proxy_set_header Upgrade $http_upgrade;
			  
			          # 3. 设置 Connection 为 "upgrade"，指示连接类型需要升级
			          proxy_set_header Connection "upgrade";
			      }
			  
			      # 其他 location 配置...
			  }
			  ```
	- ### 横向拓展
		- **问题原因：**
			- 客户端的连接仅存于某个后端服务器实例的内存中，这在服务扩容时会带来挑战。
			- 假设你的服务部署了 3 个实例（A、B、C），客户端通过网关连接到了实例 A。当客户端发送第二条消息时，如果网关（作为负载均衡器）将请求转发给实例 B，由于实例 B 并不掌握该连接的信息，它无法处理这个请求，导致连接出错。
		- **解决方案：**
			- **粘性会话：**在网关或负载均衡器上开启“会话保持”（也称“粘性会话”），即可保证来自同一客户端的所有请求始终被转发到同一个后端服务器实例。
-