- **基本概念：**
	- `map` 是 Go 中用于存储键值对的数据结构，是一种无序的集合。
	- 与数组或切片相比，`map` 在查找元素时通常具有常数时间复杂度 `O(1)`，而数组或切片的查找复杂度为 `O(n)`。
	- 只要键类型可以比较（如基本类型），就可以作为 `map` 的键。
- **创建映射：**
	- 使用 `make(map[键的类型]值的类型)` 来创建一个空的映射。
	- **声明 `map` 类型的变量但不初始化：**
		- **语法：**
			- ```go
			  var 变量名 map[键类型]值类型
			  ```
			- 此时只声明了变量，并未初始化，映射变量的默认值为 `nil`，即它并不指向任何有效的底层数据结构。
			- 不能直接添加键值对，否则会导致运行时错误。
		- **从 `nil` 映射中读取数据是安全的：**读取键值时会返回值类型的零值，获取长度时返回 0，使用 `for-range` 遍历时不会执行循环。这些行为与空 `map` 相同，不会引发 panic。
	- **初始化 `map`：**
		- 为了能够向 `map` 添加键值对，必须使用 `make()` 函数初始化映射变量。
		- ```go
		  var m map[string]int
		  m = make(map[string]int)
		  ```
	- **一步到位：**
		- ```go
		  var m = make(map[string]int)
		  ```
	- **使用短变量声明：**
		- ```go
		  m := make(map[string]int)
		  ```
	- **使用字面量创建映射：**
		- 如果预先知道映射的键和值，可以在声明时使用字面量来创建并初始化映射，无需使用 `make` 函数。
		- ```go
		  m := map[string]int{"a": 1, "b": 2, "c": 3}
		  m := map[string]int{} // 空映射
		  ```
- **访问映射中的键值对：**
	- 通过 `map[key]` 可以根据键获取对应的值。如果访问一个不存在的键，不会报错，而是返回该值类型的零值。
	- 访问 `map` 中的键时，可以选择获取一个额外的布尔值，用于判断该键是否存在。
		- ```go
		  value, ok := m["key"]
		  ```
		- 如果键存在，`ok` 为 `true`，否则为 `false`。
- **删除键值对：**
	- 可以使用内置的 `delete()` 函数来删除映射中的某个键值对。
	- ```go
	  delete(目标映射, "要删除的键")
	  ```
- **遍历映射：**
	- `range` 可以用于遍历映射，它返回键和值的每一对。
	- ```go
	  for key, value := range m {
	      fmt.Println(key, "=>", value)
	  }
	  ```
	- 遍历顺序是随机的，每次执行的结果可能不同。
- **`map` 是引用类型：**
	- 当你将一个 `map` 变量赋值给另一个变量，或者将一个 `map` 作为参数传递给函数时，你传递的是指向底层数据结构的指针，而不是 `map` 的副本。
	- 因此，函数内部对 `map` 的修改会直接影响到外部的原始 `map`。
- **`map` 不是并发安全的：**
	- 如果你有多个 goroutine 同时对一个 map 进行读写操作，程序会直接崩溃。
	- **办法：**
		- 使用 `sync.RWMutex`（读写互斥锁）。
		- 使用专门为并发场景设计的 `sync.Map` 类型。
- **设置键值对：**
	- 通过 `map[key] = value` 的语法来设置映射中的键值对。
	- **示例：**
		- ```go
		  m["k1"] = 7
		  m["k2"] = 13
		  ```
- **打印映射：**
	- 使用 `fmt.Println` 打印映射会输出所有的键值对。
- **对声明但未初始化的 map 添加元素会发生什么？**
	- map 的零值是 `nil`。
	- 你可以从 `nil` map 中读取（会得到零值）。
	- 编译器允许对 `nil` map 进行赋值操作，但向 `nil` map 写入键值对会导致运行时恐慌。
-