- **基本概念：**
	- `map` 是 Go 中用于存储键值对的内置数据结构，是一种无序的集合。
	- 与数组或切片相比，`map` 在查找元素时通常具有常数时间复杂度 `O(1)`，而数组或切片的查找复杂度为 `O(n)`。
	- 只要键类型可以比较（如基本类型），就可以作为 `map` 的键。
	- `map` 建立了一种**映射关系**。它通过一个唯一的 `Key`，能快速找到对应的 `Value`。
- **创建映射：**
	- **语法：**`map[KeyType]ValueType`
	- **声明 `map` 类型的变量但不初始化：**
		- **语法：**
			- ```go
			  var 变量名 map[键类型]值类型
			  ```
			- 此时只声明了变量，并未初始化，映射变量的默认值为 `nil`，即它并不指向任何有效的底层数据结构。
	- **初始化 `map`：**
		- 为了能够向 `map` 添加键值对，必须在使用 `map` **之前**，使用 `make()` 函数初始化它。
		- ```go
		  var m map[string]int
		  m = make(map[string]int)
		  ```
		- 执行完这行代码后，`m` **不再是 `nil`**。它现在是一个**空**的、但**已经准备好接收数据**的 `map`。
	- **一步到位：**
		- ```go
		  var m = make(map[string]int)
		  ```
	- **使用短变量声明：**
		- ```go
		  m := make(map[string]int)
		  ```
	- **使用字面量创建映射：**
		- 如果预先知道映射的键和值，可以在声明时使用字面量来创建并初始化映射，无需使用 `make` 函数。
		- `map` 字面量的语法就是 `map类型` 后面跟一对花括号 `{}`, 里面包含任意数量的 `Key: Value` 键值对，用逗号 `,` 隔开。就是在创建 `map` 的同时，就用键值对把它填满。
		- 你**必须**在字面量中明确提供 `Key`，不像在初始化 `struct` 时可以省略字段名，只按顺序提供值。
		- ```go
		  m := map[string]int{"a": 1, "b": 2, "c": 3}
		  m := map[string]int{} // 空映射
		  ```
		- **总结：** 当你需要在代码中**硬编码 (hard-code)** 一些 `map` 数据时（比如配置、常量映射等），`map` 字面量是比 `make` 然后逐个 `m["..."] = ...` 赋值**更简洁、更清晰**的方法。
		- **省略值类型：**当 Go 编译器从“顶层类型”声明（如 `map[string]Vertex{...}` 或 `[]Vertex{...}`）中**已经知道**其元素（值）的类型时，你就可以在字面量**内部**省略掉这个类型名称。
			- **显式写法：**`map[string]Vertex{"Key": Vertex{1, 2}}`
			- **省略写法：**`map[string]Vertex{"Key": {1, 2}}`
			- 编译器会自动将 `{1, 2}` 推断为 `Vertex{1, 2}`。
			- 此特性同样适用于**切片 (slice)** 字面量。
				- ```go
				  // 显式写法
				  var s = []Vertex{
				      Vertex{1, 2},
				      Vertex{3, 4},
				  }
				  
				  // 省略写法
				  var s = []Vertex{
				      {1, 2}, // 编译器知道 {1, 2} 必须是 Vertex{1, 2}
				      {3, 4},
				  }
				  ```
- **访问映射中的键值对：**
	- 通过 `map[key]` 可以根据键获取对应的值。如果访问一个不存在的键，不会报错，而是返回该值类型的零值。
	- **检查键是否存在**
		- 访问 `map` 中的键时，可以选择获取一个额外的布尔值，用于判断该键是否存在。
			- ```go
			  value, ok := m["key"]
			  ```
			- 如果键存在，`ok` 为 `true`，`elem` 是对应的值；否则为 `false`，`elem` 是零值。
- **删除键值对：**
	- 可以使用内置的 `delete()` 函数来删除映射中的某个键值对。
	- 如果 `key` 不存在，这个操作**不会做任何事，也不会报错**。
	- ```go
	  delete(目标映射, "要删除的键")
	  ```
- **遍历映射：**
	- `range` 可以用于遍历映射，它返回键和值的每一对。
	- ```go
	  for key, value := range m {
	      fmt.Println(key, "=>", value)
	  }
	  ```
	- 遍历顺序是随机的，每次执行的结果可能不同。
- **插入或更新键值对：**
	- 通过 `map[key] = value` 的语法来设置映射中的键值对。
	- 如果 `key` 不存在，就创建它；如果 `key` 已存在，就覆盖它的值。
	- **示例：**
		- ```go
		  m["k1"] = 7
		  m["k2"] = 13
		  ```
- **`map` 是引用类型：**
	- 当你将一个 `map` 变量赋值给另一个变量，或者将一个 `map` 作为参数传递给函数时，你传递的是指向底层数据结构的指针，而不是 `map` 的副本。因此，函数内部对 `map` 的修改会直接影响到外部的原始 `map`。
	- **比喻：**
		- 想象 `map` 是一个“共享仓库”的地址。
		- 当你把这个仓库的地址传给别人（比如函数参数、赋值给另一个变量），你并没有复制仓库里的货物，只是把仓库的钥匙副本交了出去。
		- 所以无论谁用这把钥匙，都能操作同一个仓库里的货。
- **`map` 不是并发安全的：**
	- 如果你有多个 goroutine 同时对一个 map 进行读写操作，程序会直接崩溃。
	- **办法：**
		- 使用 `sync.RWMutex`（读写互斥锁）。
		- 使用专门为并发场景设计的 `sync.Map` 类型。
- **对声明但未初始化的 map 添加元素会发生什么？**
	- map 的零值是 `nil`。
	- **从 `nil` map 中读取数据是安全的：**读取键值时会返回值类型的零值，获取长度时返回 0，使用 `for-range` 遍历时不会执行循环。这些行为与空 `map` 相同，不会引发 panic。
	- 不能向一个 `nil` map 添加键值对，否则会导致运行时错误。
	- **示例代码：**
		- ```go
		  package main
		  
		  import "fmt"
		  
		  func main() {
		  	var a map[string]int
		  	fmt.Println(a == nil) // true
		  	fmt.Println(a["test"]) // 0
		  	fmt.Println(len(a)) // 0
		  	for k, v := range a { // range over nil map will not panic
		  		fmt.Println(k, v)
		  	}
		  }
		  ```
-