- **为什么要叫容器？**
	- **比喻：集装箱（The Shipping Container）**
		- 在没有集装箱的时代，运输货物是一场噩梦：
			- 汽车、钢琴、面粉、水果，形状各异，对温度和搬运要求也不同。把它们塞进一艘船里不仅慢，还容易互相损坏。
		- 集装箱（Container）解决了这个问题：
			- 不管里面装的是什么，外面都是一个标准的金属盒子。
			- 港口的起重机不需要知道里面是钢琴还是苹果，只要能吊起盒子就行。
		- “Docker” 这个英文单词的意思是 “在码头上装卸货物的工人”：dock + -er = 在码头干活的人。
		- Docker 的名字和图标（一只背着集装箱的鲸鱼）很形象：就像码头工人负责把货物装上船、运来运去一样，Docker 负责把应用程序 “打包” “运输” “部署”，让它们可以在不同环境之间顺畅移动。
		- **以前：**开发者的代码在自己电脑上能跑，发给测试人员就报错，部署到服务器上又因为缺少某个库崩了。这就是著名的 “在我的机器上是好的” 问题。
		- **现在：**Docker 容器把代码、运行环境、依赖库、配置文件全部打包进一个 “标准的盒子” 里。因此应用程序可以从一个计算环境快速可靠地运行到另一个计算环境。
- #### 容器是什么？
	- 镜像是一个只读的模板，它包含了运行某个应用程序所需的所有东西，比如代码、运行时、库。
	- 容器是镜像的运行实例。当你从一个镜像启动容器时，Docker 会在只读的镜像层之上，创建一个可写的容器层。所有在容器中进行的改动，例如创建或修改文件，都只会影响到这个可写的容器层，而不会对底层的原始镜像造成任何改动。
- **容器是临时的**
	- **数据易失：**当你删除一个容器（`docker rm`）时，容器内部产生的所有文件修改、日志、临时数据，都会瞬间消失，无法找回。
	- **原理：分层文件系统与 Copy-on-Write**
		- 为什么容器会有这种特性？这源于它的底层技术：联合文件系统（UnionFS）。
		- 想象一下，Docker 镜像就像是一叠透明的幻灯片（只读层）。 当你启动一个容器时，Docker 并没有复制这叠幻灯片，而是在最上面盖了一张空白的透明纸（读写层）。
		- **读取文件：**你透过最上面的空白纸，直接看到下面幻灯片里的内容。
		- **修改/写入文件：**
			- 当你试图修改一个文件时，Docker 会把文件从下面的只读层“复制”到最上面的空白纸上，然后你实际上是在修改这个副本，下面的原始镜像层依然完好无损。
			- 这就是 Copy-on-Write（写时复制）机制。
		- 这张“最上面的空白纸”（读写层）是属于当前这个容器实例的。一旦容器被删除，这张纸就被撕碎了，你在上面写的所有东西（新文件、修改的配置、产生的日志）也就随之消失了。
- **Docker 存储挂载**
	- **Volumes（数据卷）**
		- 数据存放在主机的一个特定区域（`/var/lib/docker/volumes/...`），完全由 Docker 守护进程管理。
		- **特点：**
			- 不需要指定电脑上的具体路径，只需要给卷起个名字，Docker 自动管理路径。
		- **适用场景：生产环境**
			- **目标：**我运行一个 Redis 数据库。不管我怎么删除、升级容器，我的数据必须还在。
			- ```bash
			  # 格式： -v <卷名称>:<容器内路径>
			  docker run -d -v redis-data:/data --name my-redis redis
			  ```
			- **发生了什么？**
				- Docker 自动在后台创建了一个叫 `redis-data` 的数据卷（如果不存在的话）。
				- 即使你执行 `docker rm -f my-redis` 删除了容器。
				- 这个卷 `redis-data` 依然存在，数据安然无恙。
				- 下次你启动新容器，只要再加上 `-v redis-data:/data`，数据就又回来了。
	- **Bind Mounts（绑定挂载）**
		- 你直接把物理机上的一个具体文件夹（比如你的代码目录）“映射”到容器里面。
		- **特点：**
			- 你在电脑上改了代码，容器里立马就能看到。两边是完全同步的。
			- 你需要自己指定具体的路径。强依赖主机的文件结构。
		- **适用场景：开发环境（代码热更新）、挂载配置文件**
			- **目标：**我正在写一个网页，我希望我改了 HTML 文件，浏览器刷新就能看到，不用每次都重启容器。
			- 假设你的电脑上当前目录下有一个 `index.html` 文件，我们运行一个 Nginx 容器来展示它。
			- ```bash
			  # 格式： -v <主机路径>:<容器内路径>
			  # $(pwd) 表示当前目录
			  docker run -d -p 8080:80 -v $(pwd):/usr/share/nginx/html --name my-website nginx
			  ```
			- **发生了什么？**
				- 你把电脑当前目录挂载到了容器的 `/usr/share/nginx/html`。
				- 现在，你在电脑上用记事本修改 `index.html`。
				- 刷新浏览器 `http://localhost:8080`，你会发现内容立刻变了！
				- 这就是 Bind Mount 的魔力：实时同步。
- #### 容器的生命周期
	- **已创建 (Created)：**使用 `docker create` 命令时，容器被创建。此时 Docker 已准备好运行所需的镜像、配置、文件系统和网络端口，但尚未启动主进程，容器处于“待命”状态。
	- **运行中 (Running)：**容器的主进程已启动并运行，应用正常工作。可通过 `docker run`（相当于 `create` + `start`）或 `docker start` 进入该状态。
	- **暂停中 (Paused)：**执行 `docker pause` 命令可暂停容器内所有进程，容器仍驻留在内存中，但不再分配 CPU 时间片。可通过 `docker unpause` 恢复运行，类似“冻结/解冻”效果。
	- **已停止 (Stopped)：**执行 `docker stop` 时，Docker 会先发送 `SIGTERM` 信号以便容器优雅关闭，若在默认 10 秒内未退出，则发送 `SIGKILL` 强制终止。文件系统和配置依然保留，但主进程已结束。
	- **已退出 (Exited)：**容器的主进程执行完成或因错误退出后进入此状态，通常只会短暂存在，随后即变为“已停止”。可用 `docker ps -a` 查看此状态的容器。
	- **已删除 (Deleted)：**执行 `docker rm` 后，容器及其相关资源（文件系统、日志等）被彻底移除，无法恢复。
- ### `docker run`
	- #### 有什么用？
		- `docker run` 命令用于从一个镜像创建并启动一个容器。
	- #### 怎么用？
		- **语法：**`docker run [OPTIONS] IMAGE [COMMAND] [ARG...]`
			- `[OPTIONS]`：用于配置容器的各种运行参数。
			- `IMAGE`：用于创建容器的镜像。
			- `[COMMAND]`：可选项。在容器启动后，需要执行的命令。
			- `[ARG...]`：可选项。传递给 `[COMMAND]` 的参数。
	- #### 常用选项
		- `-it`：这是两个选项的组合，通常一起使用。用于交互式运行容器，与其建立终端连接，使你能够进入容器内部执行命令并实时查看结果。
		- `-d` 或 `--detach`：在后台运行容器，并打印出容器 ID。让终端可以继续做其它事情，否则你的终端会被容器日志占据。
		- `-p` 或 `--publish`：将主机的端口映射到容器的端口，这样外部才能访问容器内的服务。格式为 `-p 主机端口:容器端口`。
		- `--name`：为容器指定一个名字。之后可以使用这个名字来方便地操作它，而无需使用冗长的容器 ID。
		- `--rm`：当容器退出时自动删除容器。用于运行临时任务或测试，避免留下大量无用的容器。
		- `-v` 或 `--volume`：用于在主机和容器之间共享和持久化数据。
		- `-e` 或 `--env`：在容器内部设置环境变量。格式为 `-e KEY=VALUE`。
		- `--env-file`：从一个指定的文件中批量读取并设置环境变量。文件中的每一行都应遵循 `KEY=VALUE` 的格式。
		- `-m` 或 `--memory`：限制容器能使用的最大内存，防止单个容器耗尽系统资源。
		- `--cpus`：限制容器能使用的 CPU 核心数。
		- `--restart`：设置容器的重启策略。当容器因意外退出时，Docker 可以根据策略自动重启它。
		- `--network`：将容器连接到指定的 Docker 网络。
		- ` --gpus`：将主机的 GPU 资源分配给 Docker 容器。
- [[docker logs]]
-