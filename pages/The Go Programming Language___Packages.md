-
- 每个 Go 程序都由包（Packages）构成。
- 程序从 `main` 包开始运行。
- 每个 `.go` 文件都必须在文件的第一行用 `package <包名>` 来声明它所属的包。
- Go 项目就是由一个个功能独立的“包”搭建起来的。
- 在 Go 语言中，包（package）是==最基本的代码组织和复用单元==。你可以把它想象成一个文件夹，里面装着一堆功能相关的 `.go` 源代码文件。
- 包是编程中最小的可独立管理、可复用的代码集合，它既负责组织代码结构，也提供对外可重用的功能。
- 比如在 Go 里，一个包目录下可能有：
	- ```go
	  math/
	    add.go
	    sub.go
	    mul.go
	    div.go
	  ```
	- 这几个文件都属于 `math` 包，共同实现数学运算相关的功能。
	- 当你在别的地方 `import "math"` 时，就能使用这些函数，比如 `math.Add(3,4)`。
- **为什么说包是“最基本的组织单元”**
	- 在编程里，我们要管理很多代码文件。
	- 如果没有“包”的概念，所有文件都堆在一起，会像一个杂乱无章的文件夹，根本分不清哪些文件是干什么的。
	- “包”就是一种分组方式。
		- 按功能归类（比如 `net` 网络相关，`io` 输入输出相关）
		- 按层级划分（比如 `service`、`dao`、`api`）
	- 没有比它更底层的组织形式（在 Go 中，函数、结构体都要放在某个包里），所以说它是最基本的“代码组织”单元。
- **比喻理解：**
	- 你可以把：
		- **函数**看成是一颗螺丝（零件）
		- **包**看成是一整个“零件袋”
		- **模块/项目**看成是一台完整的机器
	- 一个机器（项目）由很多零件袋（包）组成；
	- 每个零件袋里装了很多螺丝、齿轮、弹簧（函数、结构体等）。
	- 你要造别的机器时，不用重新做螺丝，只要拿这个“零件袋”过来用就行。
- **为什么说包是可独立管理的？**
	- 包拥有完整的内部实现和明确的外部接口，可以被单独开发、测试、编译、维护、发布，而不依赖于整个项目的其他部分。
	- 换句话说，一个包不需要知道“整个系统长什么样”，它只管自己的功能范围就行。
	- 比如你有一个项目结构：
		- ```go
		  myapp/
		    ├── main.go
		    ├── user/
		    │     └── user.go
		    └── utils/
		          └── string_utils.go
		  ```
		- `user` 包只负责用户相关逻辑（注册、登录等）
		- `utils` 包只负责字符串工具函数（比如去除空格、格式化等）
		- 你完全可以只修改 `utils` 包、测试它的功能，而不用动 `main.go` 或 `user.go`。
		- 你甚至可以把整个 `utils` 文件夹复制出来，放到另一个项目里继续用，这就是“独立管理”。
	- **生活类比：**
		- 你可以把“包”想成是一个独立生产的小工厂。
		- 每个工厂只生产自己那类零件（功能）。
		- 工厂内部的机器、工人（函数、结构体）自己安排、自己管理。
		- 外面的人只关心“你能提供什么产品（API）”，而不管你怎么生产。
		- 这样整个“工业区”（项目）就可以由多个独立工厂组成，每个工厂都能独立升级、测试、替换，而不会影响别的工厂。
- **为什么说包是“复用单元”**
	- “复用”就是“别的地方也能用”。
	- 当你写好一个包，比如：
		- ```go
		  package mathutils
		  
		  func Add(a, b int) int {
		      return a + b
		  }
		  ```
	- 别的程序可以直接：
		- ```go
		  import "yourproject/mathutils"
		  
		  fmt.Println(mathutils.Add(1, 2))
		  ```
	- 包是可以被其他程序直接导入、直接使用的，这就实现了代码复用，而不需要复制粘贴代码。因此它是最基本的复用单位。
- **作用：**
	- **命名空间：**避免函数、变量等命名冲突。
	  collapsed:: true
		- 比如，你可以有一个 `company_a` 包和一个 `company_b` 包，它们里面都可以有叫做 `GetUser` 的函数，通过 `company_a.GetUser()` 和 `company_b.GetUser()` 来区分调用。
	- **代码复用：**将通用的功能封装在包里，其他项目可以轻松地导入和使用。
	- **逻辑封装：**Go 通过首字母大小写来控制可见性。一个包内首字母大写的函数或变量（如 `fmt.Println`）可以被包外的代码访问，称为导出 (exported)。首字母小写的（如 `fmt.print`) 则只能在包内部使用，外部无法访问。
- **Go 语言有两种类型的包：**
	- **可执行包：**任何包含一个无参数、无返回值的 `main` 函数的包，且其包声明为 `package main`，编译后都会生成一个可执行文件。当这个可执行文件运行时，它会从 `main` 包中的 `func main()` 函数开始执行。这个 `main` 函数就是整个程序的入口 (Entry Point)。操作系统运行你的程序时，就是从这个 `main` 函数开始执行的。
	  collapsed:: true
		- **示例：**
			- 一个最简单的 Go 程序长这样：
			- ```go
			  package main // 声明为 main 包，表明它是一个可执行程序
			  
			  import "fmt" // 导入 fmt 包
			  
			  // 程序入口函数
			  func main() {
			  	fmt.Println("Hello, World!")
			  }
			  ```
	- **库包：**如果一个包不叫 `main`，它就是一个库包，这种包的目的是提供功能给其他包使用，不能被直接执行，只能被其他程序导入使用。
	  collapsed:: true
		- 包名可以是除了 `main` 以外的任何名字，比如 `"fmt"`, `"net/http"`, `"math/rand"` 等。
- `import` 关键字告诉编译器你的程序需要用到哪些外部的包。
- **包名和导入路径：**
	- 按照约定，包名（package name）与其导入路径（import path）的最后一个元素相同。导入路径的最后一部分必须和包名一致。
		- 例如，`"math/rand"` 包由声明语句 `package rand` 开头的文件组成。
		- 以 `"math/rand"` 为例：
			- 导入路径：`"math/rand"`
			- 路径的最后一个元素：`rand`
			- 所以，这个包里的所有 `.go` 文件都必须以 `package rand` 开头。
	- **导入路径（Import Path）：**是用来唯一标识一个包的字符串，是你在 `import` 语句中写的那个字符串，例如 `"fmt"` 或 `"math/rand"`。Go 的工具链会根据这个路径去寻找对应的包文件。
	- **包名 (Package Name)**：是你在源代码文件第一行 `package <包名>` 中声明的名字，也是你在代码中实际使用的名字。
	- 当你在代码中使用包时，你用的是包名，而不是完整的导入路径：
		- ```go
		  package main
		  
		  import (
		  	"fmt"
		  	"math/rand" // 使用导入路径
		  )
		  
		  func main() {
		  	// 使用包名 `rand` 来调用里面的函数
		  	// 正确 ✅: rand.Intn(100)
		  	// 错误 ❌: math/rand.Intn(100)
		  	fmt.Println("A random number:", rand.Intn(100))
		  }
		  ```
-