Seata 有什么用？
heading:: true
	- 在单体应用中，我们通常使用数据库的本地事务（ACID）来保证数据的一致性。但在微服务架构中，一个业务操作可能会跨越多个独立的服务，每个服务都有自己的数据库。这时，如何保证所有这些跨服务的数据库操作要么全部成功，要么全部失败，就成了一个巨大的挑战，这就是分布式事务问题。
	- Seata（Simple Extensible Autonomous Transaction Architecture）用于解决微服务架构中的分布式事务问题。它将一个业务流程中涉及的多个微服务的数据库操作整合为一个统一的全局事务，从而实现要么全部提交、要么全部回滚，以保障数据的一致性。
- Seata 的核心知识点
  heading:: true
	- **Transaction Coordinator (TC) - 事务协调者**
		- **角色：**它是整个事务的“大脑”和“指挥官”。TC 独立部署，负责维护全局事务和分支事务的状态。当一个全局事务开始时，它会接收事务的发起请求，并生成一个全局唯一的事务 ID (XID)。
		- **职责：**接收 TM 的全局事务开启 / 提交 / 回滚请求，协调所有 RM 进行分支事务的提交或回滚。
	- **Transaction Manager (TM) - 事务管理器**
		- **角色：**它是全局事务的“发起者”。TM 通常嵌入在业务应用（微服务）中，用于定义一个全局事务的范围。
		- **职责：**向 TC 发起请求，开启一个新的全局事务，或者在业务逻辑执行完毕后，请求 TC 提交或回滚该全局事务。
	- **Resource Manager (RM) - 资源管理器**
		- **角色：**它是分支事务的“执行者”。RM 也嵌入在业务应用（微服务）中，负责管理和执行本地资源（如数据库连接）上的操作。
		- **职责：**
			- 向 TC 注册分支事务，将其纳入对应全局事务的管辖。
			- 接收 TC 的指令，执行分支事务的提交或回滚。
			- 与 TC 保持通信，报告分支事务的执行状态。
	- **工作流程简述：**
		- TM 向 TC 申请开启一个全局事务，TC 创建一个全局事务并返回一个唯一的 XID。
		- 这个 XID 会在微服务的调用链中传播。
		- 每个参与该全局事务的服务中的 RM 会向 TC 注册一个分支事务。
		- 当业务逻辑执行完毕后，TM 会根据执行结果向 TC 发起全局提交或回滚请求。
		- TC 会协调所有参与该全局事务的 RM，通知它们提交或回滚各自的分支事务。
	- **XID：全局事务的唯一身份证**
		- XID（Transaction ID）是一个全局唯一的字符串，用于标识一个分布式事务。在一个复杂的分布式调用链中，无论涉及到多少个微服务、多少次数据库操作，只要它们同属于一个分布式事务，就都会共享同一个 XID。它就像是这次“团队行动”的统一代号。
		- XID 是串联起所有分散的“分支事务”的生命线。TC 就是通过 XID 来识别和管理属于同一个全局事务的所有分支，并在最终需要提交或回滚时，知道应该向哪些服务的哪些分支发送指令。没有 XID，分布式事务就成了一盘散沙。
		- **构成**：一个典型的 XID 格式为 `TC的IP地址:TC的端口:全局事务ID`。
		- **工作机制（传播）**：
			- **生成**：当一个被 `@GlobalTransactional` 注解的方法启动时，TM（事务管理器）会向 TC（事务协调者）申请，由 TC 生成并返回这个 XID。
			- **线程内持有**：TM 将获取到的 XID 存入当前业务线程的 `ThreadLocal` 中。
			- **跨服务传递**：当你使用 Feign、Dubbo 或其他 RPC 框架发起跨服务调用时，Seata 的客户端拦截器会自动从 `ThreadLocal` 中取出 XID，并将其放入请求的 Header 中。在服务接收端，Seata 的服务端拦截器又会从 Header 中取出 XID，并放入自己服务处理线程的 `ThreadLocal` 中。
	- **数据源代理**
		- Seata 对 Java 的标准数据源（`DataSource`）进行了一层包装，生成一个 `DataSourceProxy`。你的应用实际使用的是这个代理数据源，而不是原始数据源。这个代理的目的，就是在不侵入你业务代码的前提下，自动地、透明地完成回滚日志（`undo_log`）的生成工作。
		- 当你的业务代码执行一条 SQL（例如 `UPDATE product SET stock = stock - 1 WHERE id = 100`）时，`DataSourceProxy` 实际上执行了如下一系列“幕后操作”：
			- **拦截 SQL**：代理捕获到你将要执行的业务 SQL。
			- **解析 SQL**：分析出你要操作的表是 `product`，条件是 `id = 100`。
			- **查询前镜像**：在执行你的 `UPDATE` 之前，代理会先执行一条 `SELECT * FROM product WHERE id = 100`，将修改前的数据完整地查询出来，这称为“前镜像”。
			- **执行业务 SQL**：正常执行你写的 `UPDATE` 语句，将库存减 1。
			- **查询后镜像**：在执行你的 `UPDATE` 之后，代理会再次执行一条 `SELECT` 语句，将修改后的数据也查询出来，这称为“后镜像”。
			- **组装 undo_log**：将 XID、分支事务ID、表名、前后镜像等信息打包，准备插入到 `seata_undo_log` 表中。
			- **提交本地事务**：将第4步（业务SQL）和第6步（插入undo_log）放在同一个本地数据库事务中，然后一起 `COMMIT`。
	- **全局锁**
		- 全局锁是一种由 TC 集中管理的、在逻辑层面上的锁。它不是数据库的物理锁（如行锁、表锁），它的锁对象是“某条具体的数据行”（通过 表名 + 主键 来唯一识别）。它的生命周期与整个全局事务一样长。
		- **工作流程：**
			- **加锁**：在第一阶段，当某个分支事务（例如，库存服务）要修改某一行数据并在本地提交**之前**，它的 RM 会先向 TC 发送一个请求：“请帮我锁定 `product` 表主键为 `100` 的这条记录，持有者是当前的 XID”。TC 会检查该资源是否已被其他 XID 锁定，如果没有，就记录下这个锁定关系。
			- **检查**：如果此时有另一个全局事务也想修改 `product` 表主键为 `100` 的记录，它在申请全局锁时就会被 TC 拒绝，并进入重试等待。
			- **解锁**：当整个全局事务最终结束时（无论是全局提交还是全局回滚），TC 会将该 XID 持有的所有全局锁全部释放。
		- **试想如果没有全局锁：**
			- 事务 T1 把库存从 10 减到 9，并提交了本地事务（释放了数据库锁）。
			- 此时，事务 T2 来了，它看到库存是 9，把它减到了 8，并成功提交了全局事务。数据库里的值现在是 8。
			- 随后，事务 T1 因为其他原因需要回滚。它拿出自己的 `undo_log`（前镜像是10），强行把库存从 8 改回了 10。
			- **结果**：已经成功提交的 T2 事务的修改被 T1 的回滚给覆盖了，数据产生了严重的不一致！
			- 有了全局锁，上述第二步中，T2 在申请锁时就会被阻塞，必须等待 T1 结束并释放锁后才能继续，从而杜绝了这种脏写情况的发生。
	- **后镜像：**
		- **T1-分支A 执行：**
			- Seata 的 RM 查询到**前镜像**：`{stock: 100}`。
			- RM 执行业务 SQL：`UPDATE product SET stock = 90`。
			- RM 再次查询得到**后镜像**：`{stock: 90}`。
			- RM 将这两个镜像写入 `undo_log`，然后提交本地事务。
		- **外部程序介入：**
			- 在 T1 全局事务尚未结束时，那个不受 Seata 管理的外部程序执行了一条 SQL：`UPDATE product SET stock = 50`。
			- 现在，数据库里该商品的实际库存是 `50`。
		- **T1 触发全局回滚：**
			- T1 的后续分支失败，TC 发出回滚指令给分支A。
		- **回滚时的关键校验（后镜像登场）：**
			- 分支A的 RM 准备回滚。它**不会**立即用前镜像 `100` 去覆盖。
			- **第一步：校验**。RM 先从数据库中读取当前的库存值，得到的是 `50`。
			- **第二步：对比**。RM 将这个当前值 `50` 与它自己 `undo_log` 中记录的**后镜像** `90` 进行比较。
			- **第三步：发现异常**。`50 != 90`！这个不等式成立，向 Seata 发出了一个强烈的危险信号：**“在我上次修改完数据之后，有别人动过我的数据！”**
		- **安全失败（Fail-Safe）**
			- 发现数据不一致后，Seata 会中断本次自动回滚，并抛出异常，在日志中记录下详细的错误信息。它不会强行把库存恢复到 `100`。
			- **为什么这么做？**因为强行恢复到 `100` 会把外部程序设置的 `50` 这个状态给覆盖掉，这可能导致更严重的数据不一致问题。Seata 选择“安全地失败”，把问题暴露出来，交由人工判断和处理，避免了错误的自动覆盖。
	- **数据源代理的自动“偷梁换柱”：**
		- Seata AT 模式的核心是数据源代理，但你从来没有在代码里写过 `new DataSourceProxy(druidDataSource)` 这样的代码，它是如何被自动应用的呢？
		- Seata 的自动配置类在启动时，会去检查 Spring 的应用上下文中是否存在一个数据源（`DataSource`）的 Bean。一旦发现存在这样的数据源 Bean，Seata 就会自动地：
			- 获取到你配置的原始数据源。
			- 用这个原始数据源作为参数，创建一个 `DataSourceProxy` 实例。
			- 将这个 `DataSourceProxy` 实例注册到 Spring 容器中，并让它顶替掉你原来的数据源。
		- **结果**：之后，你的应用中任何需要使用数据源的地方（比如 MyBatis、JPA），当它向 Spring 请求 `DataSource` 时，拿到的都已经是被 Seata “偷梁换柱”后的代理数据源了。这就为后面自动生成 `undo_log` 等操作铺平了道路。
	- **RPC 框架的自动拦截与增强：**
		- Seata 的自动配置类还会检查你的项目中是否存在 Feign、Dubbo 等 RPC 框架的依赖。
		- **在调用方（上游服务，如订单服务）**：
			- 如果检测到 Feign，Seata 会自动注册一个 `SeataFeignClientInterceptor`。
			- 这个拦截器会在你每次发起 Feign 调用**之前**运行。它的唯一任务就是：从当前线程的 `RootContext` 中获取全局事务 XID，并把它塞进即将发出的 HTTP 请求的 Header 里。
		- **在被调用方（下游服务，如库存服务）**：
			- 同样，下游服务因为也引入了 Seata 依赖，它的自动配置会注册一个相应的服务端拦截器（比如一个 Servlet Filter 或 WebMvc Interceptor）。
			- 这个拦截器会在处理所有收到的请求**之前**运行。它的任务是：检查收到的 HTTP 请求的 Header 中是否存在 XID。如果存在，就把它取出来，并设置到自己当前处理线程的 `RootContext` 中。
		- **结果**：XID 就这样神不知鬼不觉地、随着你的正常业务调用，从上游服务传递到了下游服务。当下游服务执行数据库操作时，它的数据源代理一检查 `RootContext`，发现存在 XID，就自动地将自己纳入了当前全局事务的管理，开始执行申请全局锁、记录 `undo_log` 等操作。
- Seata 的四种事务模式
  heading:: true
	- **AT 模式 (Automatic Transaction) - 自动模式**
		- **Seata AT 模式的核心就是：**先让每个服务各自完成自己的事并写好“悔过书”（undo_log），然后由一个总协调人根据最终结果，决定是把所有“悔过书”销毁（提交），还是让大家照着“悔过书”的内容改正错误（回滚）。
		- **以“下单流程”为例：**
			- 该流程需要执行创建订单、扣减库存和扣减余额等操作，整个过程分为两个阶段进行：
			- **第一阶段**
				- 这个阶段，每个服务都只管完成自己的任务，但必须写好 `undo_log`。
				- **发起人（`@GlobalTransactional`）** 对 **总协调人（TC）** 说：“我要开始办‘下单’这件事了。”
				- **订单服务（RM）**：
					- **干活**：在数据库里创建一条新订单。
					- **写悔过书**：在 `undo_log` 表里记录：“如果需要反悔，就删除我刚创建的这条订单。”
					- **完成**：**立刻提交自己的本地工作**，然后告诉总协调人“我搞定了”。
				- **库存服务（RM）**：
					- **干活**：在数据库里把库存数量减 1。
					- **写悔过书**：在 `undo_log` 表里记录：“如果需要反悔，就把库存数量加 1。”
					- **完成**：**立刻提交自己的本地工作**，然后告诉总协调人“我搞定了”。
				- **账户服务（RM）**：
					- **干活**：在数据库里把用户余额扣掉。
					- **写悔过书**：在 `undo_log` 表里记录：“如果需要反悔，就把扣掉的钱加回来。”
					- **完成**：**立刻提交自己的本地工作**，然后告诉总协调人“我搞定了”。
				- **本阶段重点**：每个服务都很快完成了自己的任务，并且已经提交了本地数据库事务，所以它们不会长时间占用数据库资源，系统效率很高。最关键的是，每个服务都留下了 `undo_log` 这个“后悔药”。
			- **第二阶段**
				- 现在，所有“执行人”都报告工作完成了，等待“发起人”和“总协调人”的最终决定。
				- **结局一：一切顺利，全局提交**
					- 发起人（`@GlobalTransactional` 方法）顺利执行完毕，它对总协调人（TC）说：“事情圆满办妥，可以确认了！”
					- 总协调人（TC）收到好消息，立刻向所有执行人（RM）下令：“大家把手里的‘悔过书’（`undo_log`）都销毁吧，用不上了！”
				- **结局二：中途出错，全局回滚**
					- 发起人（`@GlobalTransactional` 方法）在执行过程中遇到了一个错误（比如余额不足的异常），它立刻对总协调人（TC）说：“出问题了，计划取消，全体撤退！”
					- 总协调人（TC）收到坏消息，立刻向所有执行人（RM）下令：“行动失败！快看你们各自的‘悔过书’（`undo_log`），把刚才做的事情反向操作一遍！”
					- 各个执行人（RM）收到指令，纷纷拿出自己的“悔过书”开始改正错误：
						- 账户服务：把钱退回给用户。
						- 库存服务：把库存数量加回去。
						- 订单服务：删除已创建的订单。
-