-
- ## Description
	- **题目链接：**https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/
	- **题目截图：**
		- ![28. Find the Index of the First Occurrence in a String.png](../assets/28._Find_the_Index_of_the_First_Occurrence_in_a_String_1761907666219_0.png)
	- **题目意思：**
		- 在字符串 `haystack` 中查找子串 `needle` 第一次出现的位置（从 0 开始计数）。
		- 如果 `needle` 不存在于 `haystack` 中，就返回 `-1`。
		- 例如：`haystack = "sadbutsad"`, `needle = "sad"` → 返回 `0`
- ## Solution A：暴力字符串匹配
	- ### Algorithm
		- #### Principle
			- 从左到右依次检查主串中每一个可能的起始位置，对每个位置逐字符比较模式串，判断能否与其完全匹配。
		- #### Steps
			- 首先计算主串（haystack）和模式串（needle）的长度。
			- 遍历主串中所有可能作为匹配起点的位置（从开头至“主串长度-模式串长度”处）。
			- 假设当前起点可以匹配成功。从该位置起，逐字符比较主串与模式串：
				- 若发现任意字符不匹配，即放弃当前起点，转而尝试下一个位置。
				- 若所有字符都完全匹配，则立即返回该起点索引。
			- 若遍历完所有起点后仍未找到匹配，则返回 -1。
	- ### Code
		- ```go
		  func strStr(haystack string, needle string) int {
		  	hLen, nLen := len(haystack), len(needle)
		  	for i := 0; i <= hLen-nLen; i++ {
		  		match := true
		  		for j := 0; j < nLen; j++ {
		  			if haystack[i+j] != needle[j] {
		  				match = false
		  				break
		  			}
		  		}
		  		if match {
		  			return i
		  		}
		  	}
		  	return -1
		  }
		  
		  ```
- ## Solution B：KMP
	- ### Algorithm
		- #### Principle
			- 暴力法：每次失败都从主串下一位重新开始。重复劳动！
			- KMP：
				- 每次失败都根据“模式串自己的规律”跳到最可能的下一个位置。
				- KMP 并不是更快地比较字符，而是更聪明地决定“下一步该从哪开始比”。
				- 它提前想清楚“自己（模式串）哪些部分是重复的”，预分析模式串的自相似性，每次出错时，它不会傻傻地回到主串下一个位置重头开始，直接跳到下一个可能对得上的地方，跳过大量无效位置，避免主串指针回退，从而实现高效匹配。
		- #### Steps
			-
	- ### Code
		- ```go
		  ```
-