#### 镜像的原理
	- 可以将镜像比作“洋葱”，由一层层**只读文件系统**堆叠而成。最底层通常是基础镜像（如 Ubuntu），其上依次叠加你的修改，每一层都对应一次文件系统的变化，例如安装软件或复制文件。Docker 借助 **UnionFS**（联合文件系统）将这些只读层合并，使容器看起来仿佛拥有一个完整的文件系统。
	- 可以将创建镜像比作制作**千层蛋糕**：基础镜像是蛋糕底，每条指令（RUN、COPY 等）就像添加一层奶油或水果，最终镜像则是所有层叠加后的成品蛋糕。
	- 这种分层机制有两大优势：
		- **节省空间**：相同的层可供多个镜像共享。
		- **构建快速**：修改后只需重建发生变化的层。
- #### 镜像层和容器层的关系
	- 镜像是只读的，容器启动时会在其上添加一个**可写层**（容器层）。
	- 容器运行期间的所有改动（如新增文件、修改配置）都会写入该层，容器删除后这些改动将随之消失。
- #### 镜像的缓存
	- Docker 会按 Dockerfile 从上到下依次执行，每条指令（RUN、COPY、ADD 等）通常生成一层，并可被缓存。
	- 只要指令内容及其输入未变化，就能命中缓存并直接跳过构建。
	- **合理调整顺序可有效提升命中率：**应将变化较少的步骤放在前面、变化频繁的放在后面；因为在早期层频繁修改文件会导致后续层缓存全部失效。
- ## 创建 Docker 镜像
	- ### 方式一：用 Dockerfile 构建
		- **编写 `Dockerfile`：**用指令描述镜像的构建步骤。
		  logseq.order-list-type:: number
		- **执行构建命令：**
		  logseq.order-list-type:: number
			- `docker build`
				- **有什么用？**
					- 把某个目录（构建上下文）按 Dockerfile 里的步骤，打成一份可复用的镜像。可以想成：把食谱（Dockerfile）+食材（上下文目录）交给厨师（Docker 引擎）做成成品（镜像）。
				- **语法：**`docker build [选项] <构建上下文路径>`
					- **`-t`**：为构建的镜像命名并打标签
						- **语法**：`-t [REGISTRY_HOST[:PORT]/]NAMESPACE/REPO:TAG`
						- **`REGISTRY_HOST[:PORT]`**：镜像仓库地址，可省略，默认使用 Docker Hub
						- **`NAMESPACE/REPO`**：命名空间与仓库名（如用户名/项目名）
						- **`TAG`**：标签，省略时默认为 `latest`
					- **`-f`**：指定 Dockerfile 的路径
				- **示例**：`docker build -t yourname/app:1.0 .`
					- 末尾的点号表示当前目录为构建上下文，Docker 会在此查找 Dockerfile 并收集需要打包进镜像的文件。
		- **生成镜像**：Docker 会按 Dockerfile 的指令顺序逐行执行，每条指令生成一个新的**镜像层**，最终合并为完整镜像。
	- ### 方式二：从容器保存成镜像
		- 启动容器并进行修改。
		- 修改完成后退出容器，执行 `docker commit 容器ID myimage:v1`，即可将容器当前的文件系统状态保存为新镜像。
	- ### 方式三：从 tar 包导入
		- 使用 `docker export` 导出容器的文件系统为 tar 包。
		- 再通过 `docker import` 将该 tar 包导入为镜像。
-