- Redis 是一款基于内存的数据库，其高性能得益于数据存储在内存中的特性。但这也意味着，如果未配置持久化机制，系统在重启或崩溃时，内存中的数据将会全部丢失。
- 为了防止断电或系统故障导致数据丢失，Redis 提供了持久化功能，可将数据保存到磁盘，并在重启时加载恢复。
- RDB（Redis DataBase）
  heading:: true
	- RDB 是 Redis 在某一时刻内存数据的全量快照，它将当前的数据内容以二进制文件形式保存到磁盘（通常以 `.rdb` 结尾）。
	- 与记录写入命令的 AOF 不同，RDB 直接保存的是内存中的数据本身。
	- 使用 `save` 命令会在主线程中同步生成 RDB 文件，此过程会阻塞所有客户端请求，直到文件创建完成。
	- 使用 `bgsave` 命令时，主线程会 fork 出一个子进程，由子进程负责生成 RDB 文件，从而避免阻塞主线程，主进程仍可继续处理客户端请求。
	- 当执行 `SHUTDOWN` 命令关闭 Redis 服务时，若未禁用 RDB，Redis 会自动以阻塞方式执行一次 `SAVE`，将数据保存至磁盘后再退出。
	- 可通过配置文件设置定期自动触发 `bgsave`，例如：
		- ```redis
		  save 900 1      # 900 秒内至少有 1 个键发生变化时触发 bgsave
		  save 300 10     # 300 秒内至少有 10 个键发生变化时触发 bgsave
		  save 60 10000   # 60 秒内至少有 10000 个键发生变化时触发 bgsave
		  ```
	- **数据丢失风险较高**：由于 RDB 快照是周期性生成的，若 Redis 在两次快照之间发生故障（如宕机），这段时间内的所有数据变更都将丢失。数据丢失的程度取决于 save 配置的触发频率。
- AOF（Append Only File）
  heading:: true
	- 记录所有执行过的写操作命令。每当执行写操作命令时，都会将该命令以追加方式写入一个文件。服务器启动时会按顺序读取 AOF 文件中的命令并逐条执行，以恢复内存中的数据。
	- AOF 日志记录的是写操作的命令，而非具体的数据内容。
	- AOF 的写入时机
	  heading:: true
		- **写入 AOF 缓冲区**：当 Redis 执行一条修改数据的命令（如 `SET`、`DEL`、`INCR` 等）时，除了更新内存数据外，还会将命令以文本形式追加到 AOF 缓冲区（内存中），而非直接写入磁盘。
		- **写入操作系统缓存**：Redis 随后会将 AOF 缓冲区中的数据通过 `write()` 系统调用写入到 AOF 文件中，此时数据仅进入操作系统缓存，还未真正落盘。
		- **同步到磁盘**：何时将操作系统缓存中的数据同步到硬盘，由 `appendfsync` 配置项控制：
			- `always`：每次写入后立即同步，数据最安全，但性能最差；
			- `everysec`（默认）：每秒同步一次，兼顾性能和数据安全，崩溃时最多丢失 1 秒的数据；
			- `no`：完全交由操作系统决定何时同步，性能最好，但数据丢失风险最大。
		- **客户端响应时机**：只要命令成功执行并写入 AOF 缓冲区，Redis 就会立即向客户端返回成功，而不是等待数据写入磁盘完成。
		- **写操作命令在执行完成后，才会被记录到 AOF 日志中**：
			- 如果先记录命令再执行，可能会将语法错误的命令写入日志，导致 Redis 在重放 AOF 文件恢复数据时出错。
			- 这种顺序可以避免额外的语法检查开销，但也带来了数据丢失的风险：因为执行命令和写入日志是两个步骤，如果在写入磁盘之前服务器宕机，命令将无法恢复。
			- 命令和 AOF 写入在同一线程中执行。虽然日志写入发生在命令执行之后，不会阻塞当前命令，但在将日志写入磁盘时，仍可能短暂阻塞后续命令。
	- AOF 文件重写机制
	  heading:: true
		- 随着命令不断追加，AOF 文件会逐渐膨胀，不仅占用更多磁盘空间，还会导致重启时的数据恢复变慢。
		- 为减小文件体积、提升性能，Redis 提供了 AOF 重写机制：
			- 它不是对原有 AOF 文件进行分析和优化，而是直接读取数据库当前的状态，然后用最少的命令来记录这个状态，生成一个新的、更小的 AOF 文件，替换原有 AOF 文件。
		- **触发方式**：
			- **手动触发**：通过执行 `BGREWRITEAOF` 命令。
			- **自动触发**：根据配置文件中的相关选项自动执行。
		- **重写过程**：
			- Redis 主进程通过 `fork` 创建一个子进程（即 `bgrewriteaof` 进程），负责在后台完成 AOF 重写操作，从而避免阻塞主进程处理客户端请求。
			- 子进程会将当前数据库中的键值对转换为一系列写命令，并写入一个临时 AOF 文件。这个过程不依赖于旧的 AOF 文件。
			- 在子进程重写期间，主进程继续处理客户端请求。新的写命令会同时追加到旧的 AOF 文件末尾，并写入 AOF 重写缓冲区，以确保重写期间的命令不丢失。
			- 重写完成后，子进程会向主进程发送通知信号。
			- 主进程接收到信号后，会将重写缓冲区中的命令追加到临时 AOF 文件末尾。
			- 最后，主进程会使用这个新的完整 AOF 文件替换旧的 AOF 文件，之后新的写命令将被追加到这个新文件中。
- **写时复制（Copy-On-Write）机制：**
	- 为避免备份操作阻塞主线程，Redis 在执行 `bgsave` 或 `bgrewriteaof` 时，会通过操作系统的 `fork()` 创建子进程，由子进程负责将数据写入磁盘，主线程则继续响应客户端请求。
	- fork 时采用写时复制技术：主进程与子进程最初共享相同的内存页（被标记为只读），只有当主进程执行写操作时，才会触发内存页的实际复制。
	- 一旦写入发生，操作系统会复制被修改的内存页，主进程写入副本，而子进程继续读取原始数据，从而确保子进程看到的是 fork 时刻的一致快照，不受后续改动影响。
	- 写时复制能够显著减少不必要的内存复制，节省内存与 CPU 资源。
	- 但每一次写操作都可能触发内存页复制，尤其在写入频繁时，可能导致内存激增。因此，建议在生产环境中预留足够的物理内存（至少为当前 Redis 占用的两倍），并避免在高峰写入期执行快照，以减轻系统负担和避免 OOM（内存不足）。
- 混合持久化
  heading:: true
	- 启用混合持久化后，在 AOF 重写过程中会发生以下两部分内容的写入：
		- **RDB 快照部分**：Redis 首先将当前内存中的数据以 RDB 格式写入 AOF 文件的开头，作为一次完整的数据快照，记录重写开始时的全量数据。
		- **AOF 增量部分**：快照写入完成后，Redis 会将之后的新写入命令以 AOF 格式追加到该文件的末尾。
	- 因此，最终生成的 AOF 文件是由 RDB 快照和 AOF 命令组成的混合结构。
	- **恢复过程**：Redis 重启时，会先加载 AOF 文件中的 RDB 部分以实现快速恢复，再加载追加的 AOF 命令，以补全快照之后的数据变更，最大程度降低数据丢失风险。
	- **优势**：
		- **恢复速度快**：RDB 的快速加载显著缩短了启动时间。
		- **数据更完整**：AOF 增量记录保留了快照之后的所有写入操作，进一步降低数据丢失风险。