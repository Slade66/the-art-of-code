- `func New(text string) error`
	- **作用**：
		- 创建一个包含指定“错误信息”的基本错误对象。
	- **参数**：
		- `text`：一个字符串类型，表示你想描述的错误信息。
	- **返回值**：
		- 返回一个实现了 `error` 接口的对象，其内部携带了你提供的 `text` 字符串。
		- `fmt.Println` 会自动调用 `err.Error()` 来拿到字符串！
- `func Is(err, target error) bool`
	- **作用：**
		- `errors.Is` 用于检查某个错误或错误链中是否包含指定的错误。
		- Go 的 `fmt.Errorf` 函数允许我们通过 `%w` 来包装一个错误，形成错误链。`Is` 会沿着错误链进行深度优先遍历，检查错误链中的每一个错误，直到找到目标错误或者遍历完所有错误。
	- **参数：**
		- `err`：被检查的错误。它可能是一个单一的错误，也可能是一个错误链中的一个错误。
		- `target`：目标错误，用于和 `err` 进行比较。
	- **返回值：**
		- `Is` 函数返回一个布尔值：
			- 如果 `err` 或其错误链中的某个错误与 `target` 匹配，则返回 `true`。
			- 如果没有匹配，则返回 `false`。
- `func As(err error, target any) bool`
	- **作用：**
		- 在 Go 1.13 之前，判断一个 `error` 是否为某种具体类型，通常会使用类型断言。在像 Kratos 这样的微服务框架中，为了在发生错误时提供更多的上下文信息，错误通常会在服务调用链路中被层层“包装”。然而，包装后的错误类型与我们需要断言的类型不一致，类型断言只能访问到最外层的错误类型，而无法直接获取被包装在内部的原始错误。
		- `errors.As` 可以遍历整个错误链，检查链中是否有任何一个错误的类型可以赋值给你想要的目标类型。
		  id:: 6886df08-c3ca-4b6e-b3e2-a3869e8b16b5
	- **参数：**
		- `err error`：你拿到的那个可能被包装过的 `error`。
		- `target any`：`target` 必须是指向错误类型的非 `nil` 指针。通常，`target` 是实现了 `error` 接口的类型，或者是可以接收错误的接口类型。
	- **返回值：**
		- 如果 `err` 错误链中找到了一个可以赋值给 `target` 的错误，函数返回 `true`。同时，它会将找到的那个错误的值赋给 `target` 指针指向的变量。
		- 如果没找到，返回 `false`。
- **`errors.As` vs `errors.Is`：**
	- `errors.Is(err, target)`：
		- 用于判断 `err` 错误链中是否存在一个特定的错误实例（值）。
		- `target` 通常是一个预定义的“哨兵错误”（sentinel error），比如 `sql.ErrNoRows` 或 `io.EOF`。
		- 你只关心“是不是这个错误”，不关心错误的具体内容。
	- `errors.As(err, &target)`：
		- 用于判断 `err` 错误链中是否存在一个特定类型的错误，并获取该错误的值。
		- 你关心的是“这个错误是否为某个特定类型”，并希望获取该错误的实例，以便访问它的字段或方法。
-