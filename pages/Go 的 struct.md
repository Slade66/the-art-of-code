- **基本概念**
	- 数组、切片和映射是保存相同类型数据的集合，而结构体（`struct`）则用于组合不同类型的数据。结构体可以将多个不同类型的值组织为一个整体。
- **结构体的指针**
	- `struct` 是值类型，传递给函数时会进行拷贝，因此在函数中修改不会影响原始结构体，同时也存在性能开销。为了避免这些问题，可以传递结构体的指针。
	- 使用结构体的指针是为了节省内存、提高性能并允许修改原数据。
	- Go 允许在 `nil` 指针上调用指针接收者的方法。在方法内部，指针接收者的变量为 `nil`，只要内部逻辑对这种情况进行适当处理，就可以确保安全。
	- Go 在结构体指针的字段访问上做了语法优化，不像 C++ 那样必须使用 `(*ptr).field` 或 `ptr->field`，在 Go 中可以直接使用 `ptr.field` 访问字段，编译器会自动解引用。
- **结构体的导出规则**
	- 如果一个结构体类型在包外可见（即类型名首字母大写），但其字段名未大写（未导出），则这些字段在包外仍不可访问。字段要在包外可访问，需使用大写字母开头。
- **什么时候嵌入结构体变量，什么时候嵌入结构体指针？**
	- 对于没有状态的“工具集”，只需使用它提供的方法，因此直接“复制”一份（嵌入值）是最简单且高效的方式。
	- 如果一个结构体为空，唯一的作用是提供方法，不存储任何数据或状态。在这种情况下，嵌入空结构体几乎没有开销。对于这种没有状态、仅提供方法的结构体，可以直接使用值嵌入的简单方式。
	- 对于有状态的实例，必须通过指针引用，而非复制。因为嵌入值会带来复制开销，并且如果原状态发生变化，复制对象无法同步更新。
- **结构体嵌套与匿名字段**
	- Go 通过结构体嵌入实现类似“继承”的功能，从而复用代码。简单来说，结构体嵌入就是将一个结构体作为另一个结构体的字段，这样，嵌入的结构体会自动继承被嵌入结构体的所有方法和字段。
	- 无论是嵌入结构体的值还是指针，Go 都会将内部结构体的字段和方法“提升”到外部结构体。这意味着，你可以直接通过外部结构体的实例访问这些字段和方法，就像它们是外部结构体自己定义的一样。
	- 当一个结构体嵌套另一个结构体时，通常需要通过完整路径访问内部字段，例如 `outer.inner.field`，语法相对繁琐。
	- 若将内部结构体作为匿名字段（即仅指定类型而不命名字段），其字段会被“提升”，可以直接通过外层结构体访问。这种方式称为结构体嵌入，能够简化访问语法。
	- 需要注意，未导出的字段不会被提升，因为这会破坏封装性。不过，内部结构体中导出的方法仍然会被提升，外部结构体可以像拥有这些方法一样直接调用。
	- 方法提升有助于类型组合：你可以将多个结构体嵌入一个新结构体中，进而复用它们的方法，而无需重复定义。这种方式既保留了代码的整洁性，也提高了使用的便利性。
	- ```go
	  // 定义一个基础结构体，用于表示通用联系信息
	  type ContactInfo struct {
	    email string
	    phone string
	  }
	  
	  // 用户结构体，嵌入 ContactInfo 作为匿名字段
	  type User struct {
	    name string
	    age  int
	    ContactInfo  // 匿名字段，其字段会被提升
	  }
	  
	  func main() {
	    u := User{
	      name: "Alice",
	      age:  30,
	      ContactInfo: ContactInfo{
	        email: "alice@example.com",
	        phone: "123-456-7890",
	      },
	    }
	  
	    // 可以直接访问嵌入字段的成员
	    fmt.Println("Name:", u.name)
	    fmt.Println("Email:", u.email)  // 实际访问的是 ContactInfo.email
	    fmt.Println("Phone:", u.phone)  // 实际访问的是 ContactInfo.phone
	  }
	  ```
- **使用结构体字面量创建并初始化结构体**
	- 可以通过结构体字面量快速创建结构体变量并初始化赋值。
	- 若省略某些字段，则这些字段会自动初始化为对应类型的零值。
	- ```go
	  lyz := person{age: 23, money: 123.0} // 指定字段名来初始化结构体
	  ```
- **结构体类型定义与变量声明**
	- **匿名结构体定义及变量声明（一次性使用）**
		- ```go
		  var lyz struct {
		    age   int
		    money float64
		  }
		  ```
	- **具名结构体类型定义及变量声明（多次使用）**
		- 结构体类型通过 `type` 关键字来定义。
		- ```go
		  type 类型名 struct {
		    字段名 类型
		    字段名 类型
		  }
		  
		  type person struct {
		    age   int
		    money float64
		  }
		  
		  var lyz person
		  ```
		- 声明结构体变量后，其所有字段都会被自动初始化为对应类型的零值。
- **结构体标签**
	- 结构体标签是附加在字段后的字符串字面量，不影响字段本身的功能。你可以将其理解为字段的“说明标签”。
	- 标签的主要作用是为其它程序包（尤其是通过“反射”机制读取结构体元数据的包）提供额外信息。Go 标准库中，最常使用结构体标签的就是 `encoding/json` 包。
	- **举个例子：**
		- ```go
		  type DownloadTask struct {
		  	ID         uuid.UUID `json:"id"`
		  	URL        string    `json:"url"`
		  	OutputPath string    `json:"output_path"`
		  	Threads    int       `json:"threads"`
		  }
		  ```
		- 这里的 `json:"threads"` 是用来指定 JSON 中对应的字段名。它解决了 Go 与 JSON 命名风格之间的不一致：
			- 在 Go 中，结构体字段若需被外部访问，必须首字母大写，例如 `Threads`。
			- 而在 JSON 中，通常采用小写开头的 `camelCase` 或 `snake_case` 命名风格。
			- 标签充当了两种命名规范之间的桥梁，允许你在 Go 中保持一致性，同时生成符合 JSON 标准的输出。
		- 当你使用 `encoding/json` 包来处理 `DownloadTask` 这个结构体时，这个标签会告诉 `json` 包如何操作 `Threads` 这个字段：
			- **序列化（Go 转 JSON）：**
				- 字段名是 `Threads`，标签指定输出为 `threads`，从而符合 JSON 的小写命名习惯。
			- **反序列化（JSON 转 GO）：**
				- 当解析 JSON 字符串时，如果遇到键名 `"threads"`，标签会指示将其值赋给结构体中的 `Threads` 字段。
	- Java 使用注解来标识数据，而在 Go 中，结构体标签起到了类似的作用。
	- 除了 `json` 外，还有：
		- `xml:"threads"`：用于 XML 编解码。
		- `db:"threads"`：用于数据库 ORM 映射。
		- `yaml:"threads"`：用于 YAML 编解码。
- **访问结构体字段**
	- 使用 `.` 运算符访问结构体字段。
		- ```go
		  lyz.age = 23
		  fmt.Println(lyz.money)
		  ```
	- 你可以直接使用结构体变量调用指针接收者的方法，Go 会自动帮你取地址：
		- ```go
		  type Person struct {
		      age int
		  }
		  
		  // 指针接收者方法
		  func (p *Person) GrowUp() {
		      p.age += 1
		  }
		  
		  func main() {
		      lyz := Person{age: 23}
		  
		      // 调用指针接收者方法，Go 自动取地址
		      lyz.GrowUp()
		  
		      fmt.Println(lyz.age) // 输出 24
		  }
		  ```
		- 无论是访问字段还是调用方法，Go 都在背后帮你做了自动取址或解引用处理，大多数时候你都不需要手动加 `&` 或 `*`。这是 Go 语言的一个便捷特性。
- **Getter 和 Setter 方法**
	- **Setter 方法**
		- 用于设置结构体字段的值，通常会在方法中加入合法性校验，避免设置无效或非法数据。
		- 封装是一种将数据隐藏、限制外部直接访问的机制，用于数据校验和状态保护。
		- Setter 方法必须使用指针接收者，否则只是修改副本，对原结构体没有影响。
		- 为防止外部绕过 Setter 直接修改字段，可以将字段设为未导出（小写），再提供一个导出（大写）的 Setter 方法来控制访问。
		- Go 的包级访问控制机制允许包内的导出函数访问未导出字段，因此可以通过导出方法间接访问未导出数据。
		- 按照惯例，Setter 方法通常以 `Set` 为前缀，例如 `SetAge`、`SetName`。
	- **Getter 方法**
		- 用于获取结构体字段或变量的值。
		- Go 通常不强制使用 Getter 方法，如果字段可以安全公开，直接导出字段即可。
		- 若需要通过方法访问，一般惯例是将方法命名为字段名本身，而不是使用 `Get` 前缀，例如访问字段 `Age` 的方法也应命名为 `Age()`，而不是 `GetAge()`，以保持简洁一致。
- **结构体的命名规范：**
	- **结构体名称：**使用大写字母开头的驼峰命名法。
	- **结构体字段名称：**同样使用驼峰命名法。
		- **首字母大小写决定可见性：**
			- **大写字母开头：**可以在包外部被访问和使用。
			- **小写字母开头：**只能在当前包内部被访问。
- **结构体标签（struct tags）**
	- **作用：**
		- 它是一种“注解”或“元数据”，本身不会影响 Go 程序的正常执行。它的作用是为结构体字段提供额外信息，库或框架可以通过反射机制读取这些信息，并根据标签内容决定如何处理该结构体。
	- **格式：**`key:"value"`
	- **举例：**
		- `json:"..."` 这个标签是给 `encoding/json` 这个库看的，它看到这个标签就知道如何将结构体转换为 JSON 字符串，以及如何将 JSON 字符串解析为 Go 结构体。
		- `gorm:"..."` 这个标签是给像 GORM 这样的 ORM 库看的，它看到这个标签就知道如何将你的结构体映射到数据库表中的列。
		- `validate:"..."` 标签是给一些数据验证库看的，它看到这个标签就知道如何验证字段的值。
-