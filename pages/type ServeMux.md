- **作用：**
	- `http.ServeMux` 是 Go 标准库提供的一个 HTTP 请求多路复用器（路由器）。它的作用是接收 HTTP 请求，并根据请求的 URL 路径、主机名和方法，将其分发给预先注册好的处理函数（Handler）。
	- 简单来说，`ServeMux` 就像一个交通警察，它站在 Web 服务这个繁忙的路口，根据 HTTP 请求的目的地（URL），将它们指挥到正确的处理逻辑。
- **结构体定义与字段解析：**
	- ```go
	  type ServeMux struct {
	  	// mu 是一个读写互斥锁 (sync.RWMutex)，用于保护内部路由数据的并发访问安全。
	  	// Web 服务器会并发处理大量请求，这个锁确保了在任何时刻：
	  	// 1. 当注册新路由（写操作）时，会获得一个独占锁，防止其他 goroutine 读写路由表，保证数据一致性。
	  	// 2. 当匹配请求路由（读操作）时，允许多个 goroutine 同时获取读锁，极大地提高了并发处理性能。
	  	// 这个机制使得 ServeMux 天生就是线程安全的，开发者无需额外加锁。
	  	mu sync.RWMutex
	  
	  	// tree 是 Go 1.22+ 版本中用于路由匹配的核心数据结构，一个高效的路由树（很可能是基数树 Radix Tree）。
	  	// 它将所有注册的 URL 模式（如 "/users/{id}/profile"）拆解并存入树中。
	  	// 当请求到达时，ServeMux 会沿着这棵树逐段匹配 URL 路径，从而快速定位到对应的 Handler。
	  	// 这个树形结构是实现高性能匹配和支持 `{name}`、`{name...}` 等高级通配符语法的技术基础。
	  	tree routingNode
	  
	  	// index 是一个路由索引，作为 tree 的辅助数据结构，主要用于路由的管理和验证阶段。
	  	// 它的主要职责可能包括：
	  	// 1. 快速冲突检测：在注册新路由时，通过索引快速检查新模式是否与现有模式冲突，如果冲突则立即 panic。
	  	// 2. 存储元数据：存放一些不适合直接存储在 tree 节点上的额外信息，以辅助路由管理。
	  	// 它保证了路由表的健壮性和逻辑正确性。
	  	index routingIndex
	  
	  	// mux121 是一个完整的、旧版本（Go 1.21 及更早）的 ServeMux 实现。
	  	// 它的存在完全是为了向后兼容。Go 1.22 的路由功能有重大且不兼容的更新，
	  	// 为了让依赖旧有路由行为的老项目能平滑过渡，Go 提供了这个“备胎”。
	  	// 只有当程序启动前设置了环境变量 `GODEBUG=httpmuxgo121=1` 时，
	  	// ServeMux 才会启用这个旧的实现，而完全忽略上面新的 `tree` 和 `index` 结构。
	  	// 对于新项目，绝对不应该使用这个模式。
	  	mux121 serveMux121
	  }
	  ```
- **`DefaultServeMux`：**
	- `DefaultServeMux` 是 Go 标准库中一个开箱即用的、全局单例的 HTTP 路由器。
	- 所有通过 `http.HandleFunc` 和 `http.Handle` 注册的路由，都会被添加进这个唯一的实例中。
	- **优点：**对于简单的小型应用，它非常方便。你无需额外配置，调用 `http.HandleFunc` 就能快速启动 Web 服务。
	- **缺点：**在大型应用中，依赖全局变量会带来问题。它可能导致不同模块间的路由冲突，并使单元测试变得困难。
	- **结论：**`DefaultServeMux` 非常适合快速构建原型或用于学习 HTTP 路由。但在实际的大型项目中，为了避免全局状态带来的问题，最佳实践是创建并使用你自己的 `ServeMux` 实例，从而更好地管理路由并避免潜在的冲突。
- **路由匹配规则：**
	- **精确匹配：**这是最严格的匹配方式。例如，模式 `/hello` 只会匹配 URL `http://example.com/hello`。任何带有末尾斜杠（`/hello/`）或查询参数（`/hello?name=world`）的请求都不会被匹配。
	- **根路径匹配：**模式 **`/`** 是一个特殊的“兜底”规则。它会匹配所有没有被其他更精确模式匹配到的请求。举例来说，如果你注册了 `/hello` 和 `/` 两个模式，那么 `/hello` 的请求会由 `/hello` 的处理器处理，而 `/about`、`/contact` 等其他请求都会由 `/` 的处理器处理。
	- **前缀匹配：**如果模式以斜杠 **`/`** 结尾，则视为前缀匹配。例如，模式 `/images/` 会匹配所有以该路径开头的请求，如 `/images/logo.png` 或 `/images/avatar/user.jpg`。这种匹配方式通常用于处理静态文件目录。
- **核心工作流程：**
	- `http.ServeMux` 类型自身就实现了 `http.Handler` 接口，因此它本身就是一个 HTTP 请求处理器。它的 `ServeHTTP` 方法内部实现了路由匹配和分发逻辑。正因如此，我们可以直接将它作为第二个参数传递给 `http.ListenAndServe`，让它充当整个服务器的根处理器。
	- 它的核心工作流程分为两个阶段：
		- **路由注册：**在服务器启动前，你需要通过 `ServeMux` 的方法注册路由规则，建立一张“模式-处理器”的路由表。每条规则都将一个 URL 模式（如 `/users/`）与一个特定的 HTTP 请求处理器（`http.Handler`）关联起来。这就像是告诉 `ServeMux`，当收到特定路径的请求时，应该由哪个处理器来响应。
		- **请求处理：**当一个 HTTP 请求到达时，`ServeMux` 的 `ServeHTTP` 方法会接管它。该方法会解析请求的 URL 路径、主机和方法，并在路由表中寻找最精确的匹配项。找到匹配的规则后，`ServeMux` 会将请求和响应的控制权转交给对应的处理器来处理。如果找不到任何匹配项，它会自动返回 `404 Not Found` 响应。
-