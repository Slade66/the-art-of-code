-
- **问题描述：**
	- 当你的系统需要调用第三方 API 时，是让前端直接去操作这些 API，还是由后端作为代理来中转请求。
- **两种方案的对比：前端直连还是后端代理**
	- **方案一：前端直连第三方 API**
		- **工作方式：**
			- 前端在代码中持有 APISIX Admin API Key，并直接向 APISIX Admin API 发送 HTTP 请求。
		- **优点：**表面上开发速度快，减少了后端的代码量。
		- **缺点：**
			- **安全漏洞：**
				- Admin API Key 是最高权限凭证。将其放在前端，意味着会暴露在用户浏览器中。任何用户都能通过开发者工具获取此 Key，从而完全控制你的网关，随意修改或删除所有路由，导致业务中断。
			- **权限控制失能：**
				- 你无法实现精细化的权限设计。前端一旦拿到 Admin Key，就拥有了全部权限。你无法限制用户 A 只能操作自己的项目，而用户 B 无法访问。
			- **业务逻辑耦合：**
				- 前端直接处理与 APISIX API 的复杂交互。如果未来更换网关（如从 APISIX 换成 Kong），所有前端代码都需要重写，维护成本极高。
		- **总结：**在几乎所有正式的生产环境中，让前端直接操作第三方 API 都是严格禁止的。
	- **方案二：后端作为中间层代理**
		- **工作方式：**
			- 前端只调用你的后端 API。后端负责：
				- 验证前端用户的身份和权限。
				  logseq.order-list-type:: number
				- 使用服务器端安全存储的 Admin API Key 调用 APISIX Admin API。
				  logseq.order-list-type:: number
				- 处理结果并返回给前端。
				  logseq.order-list-type:: number
		- **优点：**
			- **极致安全：**Admin API Key 始终在服务器端，前端无法接触。彻底杜绝了凭证泄露的风险。
			- **完全可控的权限：**你的后端能够利用复杂的 RBAC 或 ABAC 逻辑，来实现精细化的权限设计。
			- **解耦与抽象：**
				- 你的后端 API 成为一个稳定的“契约”。即使未来更换 APISIX 网关，只要后端做好适配，前端代码几乎无需改动，系统灵活性和可维护性极高。
		- **缺点：**
			- 增加了后端的开发工作量。但相比带来的安全性、可控性和长期可维护性收益，这点成本微乎其微。
- **应该这样做：**
	- **简化的请求体：**
		- 请求体应该是简化的。前端只需要传递核心业务参数。
		- 你的 Kratos 后端接收到这个前端传来的简化版 JSON 请求后，会把它转换为 APISIX 需要的完整、复杂的 JSON 结构，可能会补充默认的插件配置、优先级等。
	- **权限控制：**
		- 任何对 APISIX 的请求都必须先经过你 Kratos 服务中的权限校验。校验通过后，才能由你的服务使用预置的、高权限的 `Admin API Key` 去请求 APISIX。
	-
- **不应该这样做：**
	- **不要透传：**
		- 你的 Kratos API **不应该** 是 APISIX Admin API 的 1:1 镜像。
		- 你需要根据你的前端页面需求，设计一套对前端更友好的、面向业务场景的 API。
		- 你的后端负责将前端的简单请求“翻译”成 APISIX 能理解的复杂请求。
	-
- **最小权限原则：**
	- 前端用户能操作的 API 粒度，应该严格受限于你的权限模型。例如，一个用户可能只能管理属于他自己“项目A”的路由，而不能染指“项目B”的路由。
-
- 不用把整个 APISIX 返回 schema 完全建模，只要写你业务要用的字段。
- 定义只包含你关心字段的结构体(匿名的，不是单独的 type)
-