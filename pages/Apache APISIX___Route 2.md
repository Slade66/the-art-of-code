-
- #### 路由有什么用？
	- **作用：**路由用于根据预设的规则匹配客户端发来的请求，然后加载并执行对应的插件，最后把请求转发到指定的上游。
	- **简单来说：**一条 Route 就是一条完整的指令，它告诉 APISIX：如果一个请求匹配 URL，就用这几个插件处理它，然后转发到上游。
- #### Route API
	- **请求地址**: `/apisix/admin/routes/{id}`
	- `{id}` 是路由的唯一标识。你可以自己指定（比如 `my_route_1`），也可以让 APISIX 自动生成。
	- **ID 语法规则**: ID 只能包含大小写字母、数字，以及三种特殊字符：`-`（中划线）、`.`（点）、`_`（下划线）。
	- **临时路由**: 地址后面可以跟一个 `?ttl=秒数` 的参数，用于创建一个在指定秒数后会自动删除的临时路由。
	- `PUT http://.../routes/1`：`PUT` 方法表示“创建或更新”。`/routes/1` 表示我们正在操作 ID 为 `1` 的路由。
	- `GET`获取单个或所有路由的列表。“查一下”
	- `PUT`**创建或完整替换**一个指定 ID 的路由。“给我按这个样子创建一个（如果已存在就用新的完全覆盖）”
	- `POST`创建一个路由，APISIX 会为它**自动生成 ID**。“给我创建一个，ID你随便给”
	- `DELETE`删除一个指定 ID 的路由。“删掉它”
	- `PATCH`**局部更新**一个已存在路由的属性。“只改一下它的这个部分，其他别动”
- 路由包含了三个部分：
	- **匹配规则 (Matching Rules)**：定义了什么样的请求会命中这条规则。
	- **插件配置 (Plugin Configuration)**：定义了命中规则后，要对这个请求执行哪些额外的操作。
	- **上游信息 (Upstream Information)**：定义了请求经过插件处理后，最终应该被发往哪个后端服务。
- 方法
	- ### ## GET 方法：查询 (“给我看看”)
	  
	  `GET` 是一个**只读**操作，它用于获取信息，绝不会修改任何配置。
	-
	- #### `GET /apisix/admin/routes`
		- **作用**：获取**所有**已配置的路由列表。
		- **大白话**：就像在图书馆问管理员：“把你们馆里所有书的目录给我一份。”
		- **场景**：当你想概览一下网关里都配置了哪些路由时使用。
	-
	- #### `GET /apisix/admin/routes/{id}`
		- **作用**：获取**某一个指定 ID** 的路由的详细配置。
		- **大白话**：就像在图书馆按书的编号（ID）查找某一本书的详细信息。
		- **场景**：当你想查看某条特定路由（比如 `dev_model_route`）的具体配置时使用。
		  
		  ---
	- ### ## PUT 方法：创建或完全替换 (“就得是这个样子”)
	  
	  `PUT` 是一个具有**幂等性**的写入操作，主要用于**创建或完全覆盖**一个资源。
	-
	- #### `PUT /apisix/admin/routes/{id}`
		- **作用**：客户端**指定一个 ID**，然后用请求体中的 JSON 内容来创建或更新这条路由。
		- **大白话**：这就像保存一个文件。你指定了文件名（ID），然后用新内容去保存。
			- 如果这个文件**不存在**，就创建它。
			- 如果这个文件**已存在**，就用你的新内容把它**彻底覆盖**掉，旧的内容完全消失。
		- **关键点**：ID 是由你来决定的。无论你执行这个操作多少次，只要内容不变，最终服务器上的状态都是一样的（这就是幂等性）。
		- **场景**：
			- 我们之前一直在用的就是 `PUT`，因为我们想自己控制路由的 ID（比如 `dev_model_route`）。
			- 非常适合自动化部署，你可以把路由配置写在文件里，然后用 `PUT` 来确保服务器上的状态和你的文件保持一致。
			  
			  ---
	- ### ## POST 方法：创建 (“你帮我创建一个”)
	  
	  `POST` 主要用于**新建**一个资源，ID 由服务器分配。
	-
	- #### `POST /apisix/admin/routes`
		- **作用**：客户端只提供路由的配置内容（不指定 ID），由 APISIX **自动为这条路由生成一个唯一的 ID**。
		- **大白话**：就像去银行开户，你提交了个人信息（路由配置），银行会给你一个随机的、不重复的账号（ID）。你不能自己选账号。
		- **关键点**：`POST` 不是幂等的。你每执行一次，就会创建一个**全新的**路由。
		- **场景**：当你想快速添加一条路由，并且不关心它的具体 ID 是什么时使用。
		  
		  ---
	- ### ## DELETE 方法：删除 (“把它删掉”)
	  
	  `DELETE` 用于**移除**一个已存在的资源。
	-
	- #### `DELETE /apisix/admin/routes/{id}`
		- **作用**：根据指定的 ID，删除对应的路由。
		- **大白话**：把图书馆里编号为 `{id}` 的那本书彻底下架销毁。
		- **场景**：当你不再需要某条路由时，用它来清理配置。
		  
		  ---
	- ### ## PATCH 方法：局部更新 (“只改这一点”)
	  
	  `PATCH` 是最灵活的**更新**方法，它只修改你提供的那些属性，而**保持其他属性不变**。
	-
	- #### `PATCH /apisix/admin/routes/{id}`
		- **作用**：用请求体中的 JSON 内容，**合并**到已有的路由配置中。
		- **大白话**：就像给一本书的某一页贴一张便签或勘误表，只修改了那一页的内容，书的其他部分完全不变。
		- **场景**：你只想修改 `dev_model_route` 的限流插件的 `count` 值，而不想动它的 `uri`、`upstream` 等其他配置。这时 `PATCH` 是最佳选择。
		- **特殊用法**：文档提到，将某个属性的值设为 `null`，等同于删除这个属性。
	-
	- #### `PATCH /apisix/admin/routes/{id}/{path}`
		- **作用**：一种更精确的更新方式，直接在 URL 中指定要修改的属性路径。
		- **大白话**：直接告诉图书管理员：“请把编号为 `{id}` 的书的第5章第3节 (`/{path}`) 的内容，**整个替换**成我给你的新内容。”
		- **场景**：当你只想**完全替换**路由配置中的某一个子对象或数组时（比如整个 `upstream.nodes` 列表），用这种方式最直接。
- 请求体参数
	- ### `name`
	- **解释**：给路由起一个方便人类阅读和识别的名字。
	- **示例**：`"name": "用户服务API路由"`
	  
	  ---
	- ### `desc`
	- **解释**：为路由添加一段描述，说明它的用途或场景。
	- **示例**：`"desc": "处理所有关于用户信息的增删改查接口"`
	  
	  ---
	- ### `uri`
	- **解释**：**核心匹配规则**之一。用于匹配一个**单一的**请求路径 (URL Path)。
	- **示例**：`"uri": "/api/user/profile"` (只匹配 `/api/user/profile` 这个路径)
	  
	  ---
	- ### `uris`
	- **解释**：`uri` 的复数版本，用于匹配一个**列表中的任意一个**请求路径。
	- **示例**：`"uris": ["/api/orders", "/api/invoices"]` (访问这两个路径中任意一个都会命中)
	  
	  ---
	- ### `host`
	- **解释**：匹配**单一的**请求域名。支持 `*` 通配符。
	- **示例**：`"host": "api.example.com"`
	  
	  ---
	- ### `hosts`
	- **解释**：`host` 的复数版本，匹配一个**列表中的任意一个**请求域名。
	- **示例**：`"hosts": ["a.example.com", "*.b.example.com"]`
	  
	  ---
	- ### `remote_addr`
	- **解释**：匹配**单一的**客户端 IP 地址或 IP 段。
	- **示例**：`"remote_addr": "192.168.1.100"` (匹配单个IP) 或 `"remote_addr": "10.0.0.0/8"` (匹配一个网段)
	  
	  ---
	- ### `remote_addrs`
	- **解释**：`remote_addr` 的复数版本，匹配一个**列表中的任意一个** IP 地址或 IP 段。
	- **示例**：`"remote_addrs": ["127.0.0.1", "192.168.1.0/24"]`
	  
	  ---
	- ### `methods`
	- **解释**：匹配 HTTP 请求方法。如果不配置，则代表匹配所有方法。
	- **示例**：`"methods": ["GET", "POST"]` (只允许 GET 和 POST 请求通过)
	  
	  ---
	- ### `priority`
	- **解释**：路由的优先级。当一个请求可能被多条路由同时匹配时，`priority` **数值越大**的路由将**优先被匹配**。默认值为 0。
	- **示例**：`"priority": 100` (这条路由会比优先级为 99 的路由先进行匹配)
	  
	  ---
	- ### `vars`
	- **解释**：**高级匹配规则**。允许你根据请求的任意变量（如请求头、URL参数、Cookie）进行复杂的逻辑匹配。
	- **示例**：`"vars": [["arg_id", ">", "100"], ["cookie_user", "==", "admin"]]` (匹配 URL 参数 `id` 大于 100，并且 Cookie `user` 等于 `admin` 的请求)
	  
	  ---
	- ### `filter_func`
	- **解释**：**终极匹配规则**。当 `vars` 也无法满足你复杂的匹配逻辑时，可以自定义一段 Lua 代码来进行判断。
	- **示例**：`"filter_func": "function(vars) return vars.host == 'example.com' and vars.uri_args.id ~= nil end"` (匹配域名是 `example.com` 并且 URL 参数里有 `id` 的请求)
	  
	  ---
	- ### `plugins`
	- **解释**：为这条路由绑定并配置插件。这是 APISIX 功能的核心。
	- **示例**：`"plugins": { "limit-count": { "count": 10, "time_window": 60, "key": "remote_addr" } }`
	  
	  ---
	- ### `script`
	- **解释**：直接在这条路由上执行一段自定义的 Lua 脚本，可以看作是一个“内联”的、一次性的插件。
	- **示例**：`"script": "if ngx.var.arg_token == nil then return ngx.exit(401) end"` (如果 URL 参数中没有 `token`，就直接返回 401 错误)
	  
	  ---
	- ### `upstream`
	- **解释**：直接在路由中定义后端服务（上游）的配置。
	- **示例**：`"upstream": { "type": "roundrobin", "nodes": { "127.0.0.1:8080": 1, "127.0.0.1:8081": 1 } }`
	  
	  ---
	- ### `upstream_id`
	- **解释**：引用一个**已经单独创建好**的 Upstream 对象的 ID。适用于多个路由共享同一组后端服务的场景。
	- **示例**：`"upstream_id": "my-backend-server-cluster"`
	  
	  ---
	- ### `service_id`
	- **解释**：将路由绑定到一个 Service 对象。Service 是插件配置和 Upstream 配置的组合，可以让路由配置更简洁。
	- **示例**：`"service_id": "user-management-service"`
	  
	  ---
	- ### `plugin_config_id`
	- **解释**：引用一个**已经单独创建好**的插件配置对象的 ID。适用于多个路由需要共享同一套复杂插件配置的场景。
	- **示例**：`"plugin_config_id": "global-jwt-auth-config"`
	  
	  ---
	- ### `labels`
	- **解释**：为路由打上一系列“标签”，方便对路由进行分组、管理和搜索。
	- **示例**：`"labels": { "env": "production", "team": "backend", "version": "v2" }`
	  
	  ---
	- ### `timeout`
	- **解释**：专门为这条路由设置连接后端、发送数据和接收数据的超时时间（单位：秒）。会覆盖 Upstream 中的全局设置。
	- **示例**：`"timeout": { "connect": 5, "send": 10, "read": 10 }`
	  
	  ---
	- ### `enable_websocket`
	- **解释**：是否为这条路由开启 WebSocket 代理功能。
	- **示例**：`"enable_websocket": true`
	  
	  ---
	- ### `status`
	- **解释**：路由的开关。`1` 代表启用（默认），`0` 代表禁用。可以在不删除路由的情况下，临时让它失效。
	- **示例**：`"status": 0` (这条路由现在被禁用了)
-
-
- 1
	- 根据你提供的 APISIX Route API 文档，我来详细解释 APISIX 网关的路由转发请求流程：
	- ## APISIX 路由转发请求流程
	- ### 1. 路由创建阶段
	  当你通过 Admin API 创建一个路由时：
	  ```bash
	  curl http://127.0.0.1:9180/apisix/admin/routes/1 -H "X-API-KEY: $admin_key" -X PUT -d '
	  {
	    "uri": "/api/users",
	    "methods": ["GET", "POST"],
	    "upstream": {
	        "type": "roundrobin",
	        "nodes": {
	            "127.0.0.1:8080": 1,
	            "127.0.0.1:8081": 2
	        }
	    }
	  }'
	  ```
	  
	  APISIX 会将路由配置存储到 etcd 中，并实时同步到所有网关节点。
	- ### 2. 客户端请求到达
	  ```
	  客户端 → APISIX 网关 (端口 9080)
	  GET http://gateway.example.com:9080/api/users
	  ```
	- ### 3. 路由匹配阶段
	  APISIX 按以下顺序进行路由匹配：
	  
	  1. **优先级匹配**：按 `priority` 值从高到低排序
	  2. **URI 匹配**：检查请求 URI 是否匹配路由的 `uri` 或 `uris`
	  3. **方法匹配**：检查请求方法是否在 `methods` 列表中
	  4. **Host 匹配**：检查 Host 头是否匹配 `host` 或 `hosts`
	  5. **其他条件**：检查 `remote_addr`、`vars`、`filter_func` 等
	- ### 4. 插件执行阶段
	  匹配到路由后，按顺序执行插件：
	  
	  ```
	  请求阶段插件 → 认证插件 → 限流插件 → 其他插件
	  ```
	  
	  例如你的路由配置了 `limit-count` 插件：
	  ```json
	  {
	    "plugins": {
	        "limit-count": {
	            "count": 10,
	            "time_window": 60,
	            "key": "remote_addr",
	            "rejected_code": 429
	        }
	    }
	  }
	  ```
	- ### 5. 负载均衡阶段
	  根据 `upstream` 配置选择后端服务：
	- **roundrobin**：轮询算法
	- **chash**：一致性哈希
	- **ewma**：指数加权移动平均
	- **least_conn**：最少连接数
	  
	  基于权重分配：
	  ```json
	  {
	    "127.0.0.1:8080": 1,  // 权重1
	    "127.0.0.1:8081": 2   // 权重2，获得更多流量
	  }
	  ```
	- ### 6. 请求转发阶段
	  ```
	  APISIX → 后端服务
	  GET http://127.0.0.1:8080/api/users
	  ```
	  
	  APISIX 会：
	- 保持原始请求路径
	- 转发请求头
	- 处理超时设置
	- 建立连接池
	- ### 7. 响应处理阶段
	  ```
	  后端服务 → APISIX → 客户端
	  ```
	  
	  APISIX 会：
	- 执行响应阶段插件
	- 处理响应头
	- 返回给客户端
	- ## 完整流程示例
	  
	  假设你创建了这样一个路由：
	  ```json
	  {
	    "id": "user-api",
	    "uri": "/api/users/*",
	    "methods": ["GET", "POST"],
	    "plugins": {
	        "limit-count": {
	            "count": 100,
	            "time_window": 60
	        }
	    },
	    "upstream": {
	        "type": "roundrobin",
	        "nodes": {
	            "user-service-1:8080": 1,
	            "user-service-2:8080": 1
	        }
	    }
	  }
	  ```
	  
	  当客户端发送请求：
	  ```
	  POST http://gateway.example.com:9080/api/users/123
	  ```
	  
	  流程如下：
	  1. **匹配**：URI `/api/users/123` 匹配 `/api/users/*`，方法 `POST` 在允许列表中
	  2. **限流**：检查客户端IP在60秒内的请求次数是否超过100次
	  3. **负载均衡**：轮询选择 `user-service-1:8080` 或 `user-service-2:8080`
	  4. **转发**：`POST http://user-service-1:8080/api/users/123`
	  5. **返回**：将后端响应返回给客户端
	  
	  这就是 APISIX 网关完整的路由转发流程！
	- 路径是直接匹配转发的。
	- 如果要写到不同的路径，那么yao1使用 proxy-rewrite 插件重写路径
	- 默认情况下：APISIX 会保持原始路径不变
	- 使用插件时：可以通过 proxy-rewrite 等插件对路径进行重写、添加前缀、移除前缀等操作
-