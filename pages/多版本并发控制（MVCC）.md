有什么用？
heading:: true
	- 传统的锁机制因读写阻塞而存在并发性能瓶颈。MVCC（Multi-Version Concurrency Control）在不牺牲数据一致性的前提下，极大地提高了读操作的并发性。
	- MVCC 主要用于优化读写冲突，它使普通的 `SELECT` 语句读取事务开始时或语句开始时的数据快照，从而无需加锁。
	- 用于实现“读已提交”和“可重复读”隔离级别，这两个隔离级别依赖 MVCC 机制来提供它们所定义的可见性规则：
		- 在“读已提交”下，每次读取都会看到已提交事务的最新版本（通过获取新的 Read View）。
		- 在“可重复读”下，事务在其生命周期内通常看到的是事务启动时的数据版本快照（通过复用同一个 Read View）。
- 实现原理
  heading:: true
	- 行记录中和事务有关的隐藏字段
	  heading:: true
		- `DB_TRX_ID`
			- 这个字段记录了最后修改该行数据的事务 ID，将数据行的特定版本与相应事务关联。
		- `DB_ROLL_PTR`
			- 这个字段指向存储在 Undo Log 中的前一个数据版本。
	- Undo Log
	  heading:: true
		- 行数据的版本链，记录了数据的历史版本。
		- InnoDB 会为每一行数据维护多个版本。在事务进行快照读时，系统会根据事务 ID 和可见性规则，查找在该事务看来“可见”的数据版本，而不需要获取会阻塞写操作的读锁。当数据被修改时，系统不会直接覆盖旧数据，而是创建一个新版本，并让其指向旧版本。
	- Read View
	  heading:: true
		- 每个事务开始时，会获得一个数据库在那个时间点的“快照”。该事务读取数据时，只能看到这个快照中对应的数据版本，即使其他并发事务在这之后修改了数据。
		- Read View 的创建时机：
			- 在 `READ COMMITTED` 隔离级别下：每次执行快照读语句时都会创建一个新的 Read View。
			- 在 `REPEATABLE READ` 隔离级别下（InnoDB 默认）：通常只在事务第一次执行快照读语句时创建一个Read View，后续该事务中的所有快照读都复用这个 Read View。
		- 组成部分：
			- `m_ids`：生成 Read View 时，当前系统中所有活跃事务的 ID 列表。
			- `min_trx_id`：生成 Read View 时，当前活跃事务中的最小事务 ID。
			- `max_trx_id`：创建 Read View 时，数据库应该给下一个事务分配的 ID。
			- `creator_trx_id`：创建这个 Read View 的事务自身的 ID。
	- 工作流程
	  heading:: true
		- MVCC 的核心算法是在事务读取数据时，通过可见性判断算法来确定能看到哪个版本的行数据。具体做法是，事务根据 Read View，读取数据行中的隐藏字段 `DB_TRX_ID`，并按照以下规则逐一判断每个行版本是否可见：
			- 版本是否来自已提交的旧事务？
				- 如果 `row_trx_id` 小于 `min_trx_id`（Read View 中最早的活跃事务 ID），则该版本可见。
			- 版本是否来自尚未开始的新事务？
				- 如果 `row_trx_id` 大于或等于 `max_trx_id`（Read View 中预分配的下一个事务 ID），则该版本不可见，需查找更旧版本。
			- 版本是否由当前事务自己创建？
				- 如果 `row_trx_id` 等于 `creator_trx_id`（创建 Read View 的事务 ID），则该版本可见。
			- 版本是否由创建 Read View 时活跃的事务创建？
				- 检查 `row_trx_id` 是否在 `m_ids`（Read View 创建时的活跃事务列表）中：
					- 如果在：说明创建该版本的事务当时未提交，该版本不可见，需查找更旧版本。
					- 如果不在：说明创建该版本的事务当时已提交，该版本可见。
		- 如果根据算法判断某个行版本不可见，事务不会停止，而是通过该行版本的隐藏字段 `DB_ROLL_PTR` 访问 Undo Log，获取上一个版本的数据。然后对这个上一个版本继续执行可见性判断。事务会沿着版本链不断回溯，直到找到第一个符合可见性规则的版本，或者确认没有任何可见版本为止。
- 快照读和当前读
  heading:: true
	- 快照读
	  heading:: true
		- **实现机制**：依赖于数据库的 MVCC 机制。读取的是数据库在某个时间点的“快照”版本，不一定是最新数据。如果期间有其他事务提交了修改，快照读将无法看到这些更改。读取操作不会阻塞其他事务的写入，反之亦然，从而大大提高了数据库的并发性能。
		- **触发场景**：普通的 `SELECT`。
		- **不同隔离级别的区别**：
			- 在可重复读（Repeatable Read, RR）隔离级别下（ InnoDB 默认），一个事务中的所有快照读都会读取该事务启动时创建的那个快照版本。即使其他事务在此期间提交了更新，该事务内的后续快照读看到的数据也不会改变，从而避免了“不可重复读”（事务内每次读到的数据都不一样）问题。
			- 在读已提交（Read Committed, RC）隔离级别下，每次快照读都会创建一个新的快照，读取语句执行时最新的已提交版本。这可能导致同一个事务内的两次快照读结果不同（即“不可重复读”）。
	- 当前读
	  heading:: true
		- **实现机制**：锁机制，当前读不采用 MVCC 的快照，而是直接读取数据库中最新已提交的数据版本。同时，依据语句类型施加相应的锁（共享锁或排他锁）。
		- **触发场景**：
			- `SELECT ... LOCK IN SHARE MODE`：读取最新数据并加共享锁（S锁）。其他事务可以继续加共享锁读取，但不能加排他锁进行修改。
			- `SELECT ... FOR UPDATE`：读取最新数据并加排他锁（X锁）。其他事务既不能加共享锁，也不能加排他锁，直到当前事务提交或回滚释放锁。
			- `INSERT`，`UPDATE`，`DELETE`：这些写操作在执行前，为了确保操作基于最新数据并且防止冲突，会进行当前读，并对涉及的行加排他锁（X锁）。