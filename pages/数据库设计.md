- **用数据库设计软件设计模型并生成建表语句：**
	- 不应该先写 SQL 和代码：
		- 代码改很麻烦，不如图形拖拽快。
		- 不要手写 `CREATE TABLE`，容易错且慢。
	- 应该先用数据库设计软件，把模型设计好（字段和关系），然后提交审批，上级通过之后就自动生成 SQL。
- **为什么这一步快且不废武功？**
	- 你跳过了敲代码的繁琐，但保留了“设计表结构”和“设计表关系”的核心思考过程。
- **模型的版本控制：**
	- 模型本身必须能进 Git。
	- 设计即文档：Design as Code
	  id:: 693b83db-b4e9-4c9c-a777-a40949b980f4
	- 数据库结构变更必须有迹可循
	- 不要直接在数据库里建表，你需要一个能生成代码的中间件文件，并将其纳入版本控制。
	- 选用工具的标准：软件保存的文件可以直接提交到 Git 仓库。这样你们团队的“数据库设计文档”永远跟代码仓库在一起，不会丢失，且能看到是谁改了字段。
	- 只要这个 `.json` 或 `.pdman` 文件在 Git 里，以后任何人接手项目，打开工具就能看到完整的 ER 图和字段注释，不需要去翻数据库。
- **数据库的命名规范：**
	- **库名：**全小写+下划线
	- **表名：** 强制 `t_` 开头？全小写下划线。（例如：`t_order_detail`）
	- **字段：** 是否禁止缩写？布尔值是否强制 `is_` 开头？
	- **类型：** 所有的“钱”强制用 `Decimal(16,2)`，所有的“枚举”强制用 `TinyInt`。
- **定下“基类”字段标准：**
	- 上级只给出了“用户看得见”的字段，但作为架构师，表不能只有业务字段，我们要补充“系统跑得转”的字段。
	- 名称、地址、编号是业务数据，额外加的 `id`, `create_time`, `is_deleted` 是系统底座。没有这些，以后数据误删了找不回（靠 is_deleted），出了问题不知道是谁什么时候改的（靠 update_time）。
	- 初创团队最容易乱的就是公共字段。你要在建模工具里设置一个“公共字段组”，所有表必须继承：
		- `id` (主键, BigInt/SnowflakeID)
		- `create_time` / `created_at` (创建时间)
		- `update_time` / `updated_at` (更新时间)
		- `create_by` (创建人ID)
		- `update_by` (更新人ID)
		- `is_deleted` (逻辑删除标记)
- **确立“数据库变更”标准：**
	- 初创团队最怕的就是：开发库改了，测试库没改，上线报错。
	- **操作标准：**
		- **禁止手动修改 DB：** 告诉团队，禁止直接用 Navicat 修改表结构。
		- **Go:** Golang-Migrate 或 Goose。
	- **工作流：**
		- 当你在建模工具（PDManer）里修改了字段。
		- 导出为 SQL 变更脚本（例如 `V1.0.1__add_user_phone.sql`）。
		- 将脚本放入项目的 `resources/db/migration` 目录。
		- 项目启动时自动执行，或者 CI/CD 流程中自动执行。
	- 数据库的表结构进入了版本管理，数据库可以回滚表结构。
	- 只要跑一遍 Migration 脚本，数据库就能百分百还原，没有任何人工干预的误差。
- **确立“定制化代码生成”标准：**
	- 通用的代码生成器生成的 CRUD 代码往往很丑，或者不符合你们的项目结构，要编写团队专属的代码模板。
	- 以后不管招的是初级还是高级开发，他们点击“生成”按钮后，产出的代码结构、命名、注释风格与你写的完全一致。Code Review 只需要关注业务逻辑，不需要关注代码风格。
- ### 表设计
	- **主键：**
		- 直接上 Snowflake (BIGINT)，分布式 ID，方便以后分库分表或数据迁移，系统就能毫无阻塞地横向扩展。
		- 分布式 ID：在一堆不同的机器上，都能生成“全局唯一、不重复、顺序大致递增”的 ID，而不需要依赖数据库的自增主键。
		- Snowflake：
			- **64 位整数（BIGINT）**
			- 时间戳 | 工作机器编号 | 序列号
-