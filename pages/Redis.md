是什么？
heading:: true
	- Redis（Remote Dictionary Server）是一个开源的、基于内存的高性能键值对（Key-Value）数据库，可以看作是一个外置的 HashMap。
	- **高性能**：Redis 将数据存储在内存中，因此读写速度极快，适用于对性能要求较高的场景。这是 Redis 与传统基于磁盘的数据库的根本区别。在单实例下，Redis 的 [[QPS]] 可轻松达到 10 万以上。
	- **键值对数据库**：
		- Redis 中的所有数据都以键值对的形式存储，而不是以表的形式组织。键是字符串，值则可以是多种数据类型，包括字符串、列表、哈希、集合、有序集合等。
		- 正是由于对多样化数据结构的支持，Redis 不再仅仅是一个简单的“键值存储”，这也意味着开发者在使用 Redis 时，需要根据具体问题进行数据建模，选择最适合的结构来存储和操作数据。
	- **单线程架构**：
		- Redis 采用单线程来执行命令，按顺序依次处理客户端请求，从而避免了并发竞争问题，也无需加锁。但在处理其它如网络通信或持久化等操作时，Redis 仍会使用多线程以提高性能。
		- Redis 命令在单线程中执行，这意味着耗时较长的命令可能成为服务器的性能瓶颈。如果某个命令执行时间过长（例如在大型数据集上运行 `KEYS *` 或执行复杂的 Lua 脚本），所有其它客户端的请求都将被阻塞，必须等待其完成。
	- **命令的原子性**：
		- 每条命令在 Redis 中都是一个不可分割的最小执行单元，具有原子性：要么完全执行成功，要么完全不执行，不会在中途被中断。
		- 需要注意的是，这种原子性仅适用于单条命令。如果需要保证多个操作的整体原子性，可以通过事务机制或 Lua 脚本来实现。
- 有什么用？
  heading:: true
	- **缓存**：用于存储数据库查询结果，减少重复访问，降低数据库压力，提升响应速度，常用于热点数据的快速读取。
	- **消息队列**：通过 Stream 实现消息的发布与消费，适用于异步任务处理和系统模块之间解耦的场景。
	- **分布式锁**：在分布式系统中协调对共享资源的访问，防止并发冲突，确保数据一致性和操作安全。
- 怎么用？
  heading:: true
	- [[Redis Commands]]
	- [[Spring Data Redis]]
- [[Redis 的持久化机制]]
- [[SQL vs NoSQL]]
- [[缓存雪崩]]
- [[缓存击穿]]
- [[缓存穿透]]