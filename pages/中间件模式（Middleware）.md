- **什么是中间件？**
	- 想象一下工厂的流水线。一个产品在成为最终成品之前，需要经过多个工站，每个工站对它进行一些处理：安装一个零件、检查一下质量、贴上一个标签等等。
	- 在 Web 开发中，一个用户的 HTTP 请求就像是这个待加工的产品，而中间件就是流水线上的一个个工站。
	- 中间件模式是将各个“工站”串联成一个处理管道（Pipeline）。每个请求按顺序通过管道，经过多层处理后到达核心业务逻辑（例如 HTTP 处理器）。处理完成后生成的响应会沿相反方向返回，同样经过管道的各层，最终发送给用户。
	- 中间件就是一个函数，它接收请求并执行特定操作（如验证、记录日志或限流），然后决定是否将请求传递给下一个中间件或最终处理器。将多个中间件按顺序串联起来，就形成了一条处理链。最终处理器则负责执行真正的业务逻辑。
	- 它接收一个 `http.Handler` 并返回一个新的 `http.Handler`。通过这种“责任链模式”，请求可以在到达最终处理函数之前，经过一系列中间件的处理。
- **中间件有什么用？**
	- 中间件模式在不侵入业务代码的前提下，为业务逻辑扩展了额外功能。它允许你像洋葱一样层层包裹核心处理器，在请求处理流程中添加日志、认证、压缩等横切关注点，而无需修改核心业务逻辑代码。
- **中间件的优势：**
	- **灵活组合：**中间件可以像搭积木一样按需组合，应用到不同的路由组。例如，后台管理的 API 需要认证和授权，而公开的登录接口只需要日志记录和限流。
	- **关注点分离：**中间件将横切关注点（如日志、安全、监控）从核心业务逻辑中剥离，使业务代码保持简洁，专注于业务本身。
	- **可重用性：**一个编写好的认证中间件可以轻松应用到项目中的任意路由，甚至复用于其它项目。
- **中间件的应用场景：**
	- **日志记录：**记录请求的 IP、路径、方法、耗时等信息，用于调试和监控。
	- **身份认证：**检查请求头中是否包含合法的 JWT 或 Session，并解析出用户信息。
	- **权限校验：**验证解析出的用户是否有权限访问当前接口。
	- **跨域处理：**在响应中添加 Access-Control-Allow-Origin 等头部，解决浏览器跨域问题。
	- **错误处理：**捕获处理链中抛出的任何错误，并生成统一格式的 JSON 错误响应。
	- **限流：**限制某个 IP 或用户在单位时间内的请求次数，防止服务被刷爆。
	- **请求压缩 / 解压：**对请求体进行解压，或对响应体进行 Gzip 压缩。
	- **请求 ID 生成：**为每个请求生成唯一 ID，便于在分布式系统中追踪完整调用链路。
- **代码示例：**
	- 在 Web 开发中，中间件就是一个接收 `Handler` 并返回新 `Handler` 的函数。
	- ```go
	  package main
	  
	  import (
	  	"fmt"
	  	"net/http"
	  )
	  
	  // 中间件类型：接收一个 http.Handler 并返回一个 http.Handler
	  func loggingMiddleware(next http.Handler) http.Handler {
	  	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	  		fmt.Println("请求路径:", r.URL.Path)
	  		next.ServeHTTP(w, r) // 调用下一个处理器
	  	})
	  }
	  
	  // 核心业务处理器
	  func helloHandler(w http.ResponseWriter, r *http.Request) {
	  	fmt.Fprintln(w, "Hello, World!")
	  }
	  
	  func main() {
	  	mux := http.NewServeMux()
	  	// 使用中间件包装核心处理器
	  	mux.Handle("/", loggingMiddleware(http.HandlerFunc(helloHandler)))
	  
	  	http.ListenAndServe(":8080", mux)
	  }
	  ```
-