基本数据类型
heading:: true
	- 基本数据类型是 Go 内置的类型，通常用于表示最简单的值。
	- 数值类型
	  heading:: true
		- **整型（Integer Types）：**
			- **有符号：**
				- **int**：平台相关的整数类型，通常为 32 位或 64 位。是整数类型字面量的默认类型。
				- **int8**：8 位有符号整数，取值范围为 -128 到 127。
				- **int16**：16 位有符号整数，取值范围为 -32,768 到 32,767。
				- **int32**：32 位有符号整数，取值范围为 -2,147,483,648 到 2,147,483,647。
				- **int64**：64 位有符号整数，取值范围为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。
			- **无符号：**
				- **uint**：平台相关的无符号整数，通常为 32 位或 64 位。
				- **uint8**：8 位无符号整数，取值范围为 0 到 255。
				- **uint16**：16 位无符号整数，取值范围为 0 到 65,535。
				- **uint32**：32 位无符号整数，取值范围为 0 到 4,294,967,295。
				- **uint64**：64 位无符号整数，取值范围为 0 到 18,446,744,073,709,551,615。
			- **平台自适应整型：**
				- `int`, `uint`, `uintptr`
				- 这些类型的具体大小（32位还是64位）取决于你编译程序的操作系统。
				- 在 32 位系统上，它们是 32 位宽。
				- 在 64 位系统上，它们是 64 位宽。
				- **核心建议**：**除非有特殊需求（如内存优化、与底层系统交互），否则在需要整数时，应始终默认使用 `int`。**
		- **浮点型（Floating-point Types）：**
			- 用于表示带有小数的数字。
			- **float32**：32 位浮点数。
			- **float64**：64 位浮点数，提供的精度更高，是浮点类型字面量的默认类型。
		- **复数类型（Complex Types）：**
			- 用于科学和工程计算，表示复数（包含实部和虚部）。在常规业务开发中很少使用。
			- **complex64**：包含两个 32 位浮点数的复数。
			- **complex128**：包含两个 64 位浮点数的复数。是复数类型字面量的默认类型。
		- **代码示例：**
			- ```go
			  package main
			  
			  import "fmt"
			  
			  func main() {
			  
			  	// Go 数值类型测试
			  	var i int = 42
			  	var i8 int8 = -8
			  	var i16 int16 = 1600
			  	var i32 int32 = 32000
			  	var i64 int64 = 6400000000
			  	var ui uint = 42
			  	var ui8 uint8 = 8
			  	var ui16 uint16 = 1600
			  	var ui32 uint32 = 32000
			  	var ui64 uint64 = 6400000000
			  	var f32 float32 = 3.14
			  	var f64 float64 = 2.718281828
			  	var c64 complex64 = 1 + 2i
			  	var c128 complex128 = 2 + 3i
			  
			  	fmt.Println("int:", i)
			  	fmt.Println("int8:", i8)
			  	fmt.Println("int16:", i16)
			  	fmt.Println("int32:", i32)
			  	fmt.Println("int64:", i64)
			  	fmt.Println("uint:", ui)
			  	fmt.Println("uint8:", ui8)
			  	fmt.Println("uint16:", ui16)
			  	fmt.Println("uint32:", ui32)
			  	fmt.Println("uint64:", ui64)
			  	fmt.Println("float32:", f32)
			  	fmt.Println("float64:", f64)
			  	fmt.Println("complex64:", c64)
			  	fmt.Println("complex128:", c128)
			  }
			  ```
	- **布尔类型（Boolean Type）：**
		- **bool**：布尔类型，用于表示 `true` 或 `false`。
	- **字符串类型（String Type）：**
		- [[Go 的 string]]
	- **字节类型（Byte Type）：**
		- **byte**：是 `uint8` 的别名。通常用来表示原始的字节数据，比如处理文件或网络流。
	- **字符类型（Character Type）：**
		- **rune**：
			- Go 的字符类型是 `rune`，它是 `int32` 的别名，用来表示一个 Unicode 码点（即字符对应的数字编号），占用 32 位（4 字节）。
			- `rune` 类型的字面量使用单引号括起来。
			- **`byte` vs `rune` 的区别**：一个 `byte` 只能表示像 'a', 'b', 'c' 这样的 ASCII 字符，而一个 `rune` 可以表示世界上任何语言的任何字符，比如 '中' 或一个 emoji '😊'。
- 复合数据类型
  heading:: true
	- 复合数据类型是由基本数据类型组合而成的更复杂的数据结构。
	- **数组（Arrays）：**
		- [[Go 的数组]]
	- **切片（Slices）：**
		- [[Go 的切片]]
	- **字典（Maps）：**
		- [[Go 的 map]]
	- **结构体（Structs）：**
		- [[Go 的 struct]]
	- **接口（Interfaces）：**
		- [[Go 的接口]]
	- **函数类型（Function Types）：**
		- [[The Go Programming Language/Function]]
	- **指针类型（Pointer Types）：**
		- [[Go 的指针]]
	- **通道类型（Channel Types）：**
- 类型转换
  heading:: true
	- 类型转换用于将一个值从一种类型转换为另一种类型。
	- 在 Go 语言中，类型转换必须是显式的，Go 编译器不会自动进行隐式类型转换。你必须明确地告诉编译器你要将一个值从一种类型转换成另一种类型
	- 不同类型的变量不能直接进行数学或比较运算。
	- **语法：**`T(V)`
		- 目标类型(待转换的值)
		- **T**: 你想要转换成的**目标类型**。
		- **V**: 你要转换的**值或变量**。
		- 这个表达式会创建一个类型为 `T` 的新值，其值来源于 `v`。
	- ```go
	  示例：int(1.4) // 结果为 1
	  ```
	- **为什么 Go 如此严格？**
		- 在 C 语言中，类型转换常常是隐式的。这种自动转换虽然方便，但也隐藏着巨大的风险。它可能在不经意间导致数据精度丢失、符号错误或产生难以察觉的 bug。
		- 在 Go 语言中，没有隐式类型转换。Go 的设计者认为，类型的差异是程序正确性的重要保障。如果你需要转换，就必须明确地去做。
		- 你不能把一个 `int` 类型的值赋给一个 `float64` 类型的变量。编译器强制你停下来，思考这个转换是否是你真正想要的，并让你通过 `float64(i)` 的方式来确认你的意图。
		- Go 的这种严格性是其核心特性之一。为了安全、清晰、可预见。杜绝意外发生。它通过在编译时捕获潜在的类型错误，来换取运行时更高的安全性和代码的清晰度。
	- **注意：**
		- 浮点数转换为整数时，小数部分会被舍弃，不进行四舍五入。
		- 数值与字符串之间的转换通常需要使用 `strconv` 包。
		- 大整数转换为小整数时，丢弃多出来的比特，但不会报错。
		- 大浮点数转换为小浮点数时，可能会丢失精度，但不会报错。
- {{embed ((68f05b45-cb59-4906-8647-02713479d0c4))}}
-