有什么用？
heading:: true
	- 锁的作用
	  heading:: true
		- MySQL 支持多用户同时访问数据库，如果缺乏有效的并发控制，不同事务可能会同时读取或修改相同数据，导致数据不一致或更新丢失等问题。为避免这些情况，MySQL 使用锁机制来管理并发访问，确保多个事务在读取或修改数据时井然有序，避免操作冲突，从而保障数据的正确性和系统的稳定性。
	- 锁的弊端
	  heading:: true
		- 锁是一把双刃剑，它既能保障数据的可靠性，也可能在使用不当时成为性能瓶颈，甚至引发死锁（多个事务相互等待对方释放锁，最终陷入僵局）。
		- 数据库系统设计面临的核心挑战之一，是在保障数据完整性（依赖更严格的锁定）与提升性能和并发性（依赖减少锁定）之间取得平衡。深入理解 MySQL 的锁机制，对于构建高性能、高并发的应用程序以及排查数据库性能问题至关重要。缺乏对锁的理解，就如同在没有交通信号灯的道路上驾驶，混乱和冲突将难以避免；而理解锁，则意味着掌握了数据库并发控制的“交通规则”。
- 锁的分类
  heading:: true
	- 按锁的粒度
	  heading:: true
		- 锁按照作用范围的大小（即锁的粒度）可分为不同的级别。
		- 表级锁（Table-Level Lock）
		  heading:: true
			- 表级锁是最粗粒度的锁，它会一次性锁住整张数据表。
			- 虽然表级锁实现简单、内存开销小，但并发性能较差。即使多个线程操作的是不同的行，也必须等待当前持有表锁的线程释放。相比之下，行级锁只锁定相关记录，影响范围更小，允许其它线程并发访问不相关的数据，因此并发性能更优。
			- **表级共享读锁**
				- 使用 `LOCK TABLES table_name READ` 显式加锁。
			- **表级独占写锁**
				- 使用 `LOCK TABLES table_name WRITE` 显式加锁。
		- 行级锁（Row-Level Lock）
		  heading:: true
			- 仅锁定被访问或修改的具体行，而不是整张表。
			- 由于锁粒度小，不同会话可同时操作同一张表中的不同行，显著降低锁冲突，提升并发性能。
	- 按锁的性质
	  heading:: true
		- 共享锁（Shared Lock, S Lock）
		  heading:: true
		  id:: 6815c072-8413-4647-a53c-5f2b27728676
			- 当一个事务持有 S 锁时，其它事务仍可获取该行的 S 锁，但不能获取 X 锁。也就是说，“读读”可以并发，但“读写”互斥。换句话说：我在读数据时，别人也能读，但不能写。
			- **获取方式**
				- ((6815d171-8ffa-4d8c-8c34-299a6cebf595))
		- 排他锁（Exclusive Lock, X Lock）
		  heading:: true
		  id:: 6815c08a-aa35-43e7-aef2-2cd3b1c78d8f
			- 当一个事务持有 X 锁时，其他事务无法再获取该行的任何锁（包括 S 锁和 X 锁）。这意味着“写写”互斥，“写读”也互斥。也就是说：我在写数据时，别人既不能读，也不能写。
			- **获取方式**
				- 隐式获取：`UPDATE`, `DELETE`, `INSERT`
				- 显式获取：
					- ((6815d167-3a4e-4830-aad6-309f2ef84947))
	- 意向锁
	  heading:: true
		- 有什么用？
		  heading:: true
			- 意向锁是一种加在表级别的锁，用于表明事务打算对表中某些行加锁。它并不直接锁定具体的数据行，也不会阻塞对行锁的加锁请求。其主要作用是与表级锁互斥，避免表锁与行锁之间发生冲突。
			- 如果没有意向锁，MySQL 在尝试加表锁时，必须遍历整张表，检查是否存在任何行锁，这在高并发场景下会带来严重的性能问题。而意向锁的存在，使得 MySQL 只需检查表上是否已有意向锁，就能快速判断能否加表锁，大大提升效率。
			- 意向锁由 InnoDB 自动加锁，用户无需显式干预。
		- 举个例子
		  heading:: true
			- 假设某个事务执行了：`SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;`
			- 该操作会触发两种加锁行为：
				- 在 `users` 表上加一个 IS（意向共享锁）
				- 在 `id = 1` 这一行加一个 S（共享锁）
			- 此时，如果另一个事务想加表级排他锁：`LOCK TABLE users WRITE;`
			- InnoDB 会发现表上已有 IS 锁，说明有事务正在访问该表的某些行，因此会阻塞或等待，直到前一个事务释放锁。
		- 意向共享锁（Intention Shared Lock, IS Lock）
		  heading:: true
			- 表示事务打算在表中的某些行上加共享锁（S 锁）。
			- 在加行级 S 锁之前，事务会先在表上加 IS 锁。
		- 意向排他锁（Intention Exclusive Lock, IX Lock）
		  heading:: true
			- 表示事务打算在表中的某些行上加排他锁（X 锁）。
			- 在加行级 X 锁之前，事务会先在表上加 IX 锁。
	- 记录锁（Record Lock）
	  heading:: true
		- 记录锁是 InnoDB 引擎的一种行级锁，它锁定某一行数据，防止其他事务对该行进行读写（取决于锁类型）。
		- **记录锁由以下两种类型组成：**
			- ((6815c072-8413-4647-a53c-5f2b27728676))
			- ((6815c08a-aa35-43e7-aef2-2cd3b1c78d8f))
	- 间隙锁（Gap Lock）
	  heading:: true
		- 间隙锁是 InnoDB 在可重复读隔离级别下使用的一种锁机制。不同于记录锁直接锁定某一行数据，间隙锁锁定的是两条记录之间的间隙、索引中第一条记录之前的空间，或最后一条记录之后的空隙，从而防止其它事务在这些位置插入新的数据行。
		- 间隙锁的主要作用是防止幻读。在可重复读隔离级别下，一个事务在执行过程中，多次读取同一个范围的数据时，应该始终获得相同的结果集。如果没有间隙锁，其他并发事务可能会在该范围内插入新数据，导致当前事务后续读取时出现“幻影”行，从而破坏可重复读的一致性保障。
	- 临键锁（Next-Key Lock）
	  heading:: true
		- 临键锁是 InnoDB 在可重复读隔离级别下默认采用的一种行锁类型，是记录锁与间隙锁的结合。
		- 它不仅会锁定目标索引记录本身，还会锁定其前面的间隙。
		- 这是为防止在可重复读隔离级别下出现幻读现象。通过同时锁定记录及其前间隙，InnoDB 能阻止其他事务在当前事务的查询范围内插入可能影响结果集的新行。
	- 元数据锁（Metadata Locks, MDL）
	  heading:: true
		- 表锁和行锁用于保护表中的数据，而元数据锁则用于保护表结构，其加锁和解锁过程由系统自动完成。
		- 在执行 DDL 操作（如 `ALTER TABLE`、`DROP TABLE`、`CREATE INDEX`）时，系统需要获取排他的 MDL 写锁，以确保在变更表结构期间没有其他线程使用该表。这会阻塞所有新的 DML 和 DQL 操作，直到 DDL 完成。
		- DML 和 DQL 操作（如 `SELECT`、`INSERT`、`UPDATE`、`DELETE`）执行时会获取表的共享 MDL 读锁，支持多个 DML/DQL 操作并发进行。但在持有读锁期间，会阻塞试图获取排他 MDL 写锁的 DDL 操作，从而防止在查询或写入过程中表结构被修改。
		- **MDL 争用**
			- 执行 `ALTER TABLE` 时需要获取 MDL 写锁，但可能会被之前长时间持有的 MDL 读锁阻塞。由于写锁必须等待所有读锁释放，在此期间，新的读锁请求（如查询操作）也会被阻塞在写锁之后，从而引发“堵车”效应。因此，在执行 DDL 操作前，应确保没有大量活跃连接。
			- MDL 锁按申请顺序排队，不允许插队，以避免写锁长期无法获得（即“写饿死”）。一旦有写锁进入等待队列，后续的读锁请求也必须等待该写锁完成，不能插队。
- 锁定读
  heading:: true
	- 标准的 `SELECT` 语句读取的是数据的快照，不会加锁。但在某些场景下，为了防止数据被其他事务修改，需要在读取的同时对数据加锁，这就是锁定读的用途。
	- 在 `REPEATABLE READ` 隔离级别下，普通的 `SELECT` 读取的是事务开始时的快照；而锁定读总是读取并锁定最新的已提交数据。
	- 锁定读获取的锁（共享锁 S 或排他锁 X）会一直持有到当前事务提交或回滚。
	- 当锁定读的 `WHERE` 条件缺乏有效索引支持时，MySQL 往往需要扫描全表来定位数据，并锁定扫描过程中检查的每一行。这种做法会导致大范围的行被锁定，其效果可能类似于表锁，从而严重降低并发性能。
	- `SELECT ... FOR UPDATE`
	  heading:: true
	  id:: 6815d167-3a4e-4830-aad6-309f2ef84947
		- 对读取的数据加排他锁（X 锁），阻止其他事务对这些行进行读写。
		- 当你需要读取一行数据并基于其值进行更新，同时确保在更新完成前该行不被其他事务修改时使用。
	- `SELECT ... FOR SHARE` 或 `SELECT ... LOCK IN SHARE MODE`
	  heading:: true
	  id:: 6815d171-8ffa-4d8c-8c34-299a6cebf595
		- 对读取的数据加共享锁（S 锁），允许其他事务读取这些行，但阻止写入。
		- 当你需要读取一行或多行数据，并确保在事务结束前这些数据不被其他事务修改，但允许被读取时使用。
		- `SELECT ... LOCK IN SHARE MODE` 是 MySQL 5.7 及以前版本支持的旧语法，而 MySQL 8.0 引入了等价的 `SELECT ... FOR SHARE` 新语法。
- 死锁
  heading:: true
	- InnoDB 的死锁检测机制
	  heading:: true
		- InnoDB 默认启用死锁检测（`innodb_deadlock_detect=ON`）。一旦发生死锁，系统会回滚其中一个事务以解除僵局。
		- 为实现死锁检测，InnoDB 内部维护一个“事务等待图”。当一个事务请求的锁被另一个事务持有时，会在图中添加一条边，表示该事务在等待。系统会在锁等待发生时或定期检查该图是否存在环路，若存在，则说明发生了死锁。
		- 检测到死锁后，InnoDB 会选定一个“牺牲事务”进行回滚。该选择通常基于事务的“代价”——例如修改的行数或 undo log 的大小——优先回滚代价较小的事务。回滚后，其所持有的锁被释放，其他事务可以继续执行。
		- 如果禁用死锁检测（`innodb_deadlock_detect=OFF`），InnoDB 将依赖参数 `innodb_lock_wait_timeout`（默认值为 50 秒）。当事务等待锁的时间超过该值时，会自动超时并回滚。这种方式虽可间接解除死锁，但效率较低，且可能回滚那些仅因长时间等待而非真正死锁的事务。
	- 使用 `SHOW ENGINE INNODB STATUS` 诊断死锁
	  heading:: true
		- 该命令用于查看 InnoDB 存储引擎的当前运行状态。
		- 其中的 `LATEST DETECTED DEADLOCK` 部分记录了最近一次死锁的详细信息，有助于分析和定位死锁原因。
-