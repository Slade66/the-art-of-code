- **`uniqueIndex` 与 `not null`**
	- **`uniqueIndex`（唯一索引）的作用：**
		- **核心作用**：确保一列（或多列组合）中的所有值都是唯一的，不能重复。
		- **如何工作**：当你插入（`INSERT`）或更新（`UPDATE`）记录时，数据库会检查该列的值是否已存在于索引中。如果已存在，操作将被拒绝，并返回唯一性冲突的错误。
		- **额外好处**：作为索引，它还能显著提高查询（`SELECT`）的速度。当根据此列查找数据时，数据库可以通过索引快速定位记录，而无需扫描整个表（Full Table Scan）。
	- **`not null` （非空约束）的作用：**
		- **核心作用**：确保一列中的每个值都不能为空，必须有一个有效值。
		- **如何工作**：当插入或更新记录时，如果该列未赋值或显式赋值为 `NULL`，数据库会拒绝操作，并返回错误，提示该列不能为空。
	- **`uniqueIndex` + `not null`**
		- `uniqueIndex` 只确保所有 **“有值的”** 记录是唯一的，而 `not null` 确保 **“所有记录都有值”**。
		- 将这两个约束结合在一起，形成了一个完美的逻辑闭环：
			- `not null` 约束首先确保每一行记录的该列都必须有一个确切的值，从根本上避免了 `NULL` 的出现。
			- 在此基础上，`uniqueIndex` 约束进一步确保这些 **“存在的、非空的值”** 是唯一的。
		- **最终结果**：该列中的每个值都必须存在（`not null`），且必须是唯一的（`uniqueIndex`）。这实现了我们期望的“真正的”唯一性，没有任何例外或特殊情况。
- **数据库如何看待 `NULL`**
	- 在 SQL 标准中，`NULL` 是一个特殊的值，既不代表 `0`，也不代表空字符串 `''`，更不代表任何具体的值。**`NULL` 代表的是“未知”、“缺失”或“不适用”**。
	- 基于这一哲学，`NULL` 与任何值进行比较的结果都是“未知（`unknown`）”，而不是 `true` 或 `false`，包括 `NULL` 与另一个 `NULL` 的比较。
	- 考虑这个逻辑问题：“一个未知的值” 是否等于 “另一个未知的值”？
	- 答案是：**不确定**。由于我们无法知道它们分别代表什么，因此不能判断它们是否相等。
	- 因此，在 SQL 中，`NULL = NULL` 的结果不是 `true`，而是 `unknown`（在实际操作中，`WHERE` 子句会将其视为 `false`）。
- **`uniqueIndex` 如何看待 `NULL`**
	- 当 `uniqueIndex` 检查新插入的 `NULL` 值是否“重复”时，它会查看索引中是否已有 `NULL` 值。根据 `NULL != NULL` 的原则，数据库认为新插入的 `NULL` 与任何已存在的 `NULL` 都不相等。
	- 数据库的处理逻辑如下：
		- 插入一个值，例如 `name` 列的值是 `NULL`。
		  logseq.order-list-type:: number
		- 检查 `uniqueIndex`：`name` 列中是否已有 `NULL` 值？
		  logseq.order-list-type:: number
		- 由于 `NULL` 不等于任何值，包括它自己，数据库得出结论：“没有找到与 `NULL` 相等的值”。
		  logseq.order-list-type:: number
		- 检查通过，允许插入。
		  logseq.order-list-type:: number
	- 因此，数据库允许在唯一索引列中插入多个 `NULL` 值。
-