- **方法接收者的类型：**
	- 我们可以为类型定义方法，但这些方法是和“接收者”绑定的，接收者可以是值类型，也可以是指针类型。
	- **`person` 和 `*person` 是两个不同的类型**。前者是值类型，表示存储具体数据的结构体值；后者是前者的指针类型，表示指向 `person` 类型值的指针。它们在 Go 语言的类型系统中被视为完全不同的类型。
- **方法集的规则：**
	- Go 语言有一个很重要的规则：**指针类型的接收者拥有的能力（方法）比值类型相等或更多。**
	- 值类型只有值接收者定义的方法。
	- 指针类型不仅有指针接收者的方法，还包含了值接收者的方法。
	- 值接收者的方法同时属于 `T` 和 `*T` 的方法集；指针接收者的方法只属于 `*T` 的方法集，不属于 `T`。
- **为什么接口变量能接受指针？**
	- 接口就像是一个能力清单，它规定了一个类型必须要具备哪些方法。如果一个类型（比如结构体）有这个清单上的所有方法，它就“实现”了这个接口，可以被赋值给接口类型的变量。
	- 接口只认“你有没有这套方法”，不看你是值还是指针。
	- 只要某个值（无论是“值类型”还是“指针类型”）的方法集，至少包含接口声明的全部方法，它就可以赋给那个接口变量。
	- **示例（接口变量传入指针）：**
		- ```go
		  // 定义接口
		  type Greeter interface {
		  	Greet()
		  }
		  
		  // 定义结构体
		  type person struct {
		  	name string
		  }
		  
		  // 指针接收者实现接口方法
		  func (p *person) Greet() {
		  	fmt.Println("Hello,", p.name)
		  }
		  
		  func main() {
		  	var g Greeter // 接口变量
		  
		  	// --- 值类型赋值失败 ---
		  	// g = person{"小泽"}  // ❌ 编译错误：person 类型没有实现 Greet 方法（它没有指针接收者）
		  
		  	// --- 指针类型赋值成功 ---
		  	g = &person{"小泽"}  // ✅ OK：*person 实现了 Greet 方法（指针接收者）
		  	g.Greet()            // 输出：Hello, 小泽
		  }
		  ```
		- `g = person{"小泽"}`：编译器会检查 `person` 的方法集，发现它没有值接收者的 `Greet()` 方法，因此无法赋值给 `Greeter` 接口。
		- `g = &person{"小泽"}`：这时 `*person` 拥有了 `Greet()` 方法，因为 `*person` 类型的方法集包含了 `Greet()`（指针接收者），因此赋值成功。
-