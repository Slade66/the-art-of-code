## 创建 slice
collapsed:: true
	- **语法：**`make(type, len, cap)`
		- **type（类型）：**必须是切片类型，例如 `[]int`, `[]string`。
		- **len（长度 ）：**决定了你能读写多少。切片初始化后的元素个数。这些元素会被自动初始化为类型零值。
			- 你只能访问 `0` 到 `len - 1` 范围内的下标。越界程序会直接崩溃（Panic）。
				- **形象的比喻：**
					- Cap = 5：你买了一张能放 5 个盘子的餐桌。
					- Len = 0：此时桌面上还没有真正摆上任何盘子。
					- s[0] = 5：你直接把菜往“第 1 个盘子”的位置倒。
					- 结果：服务员（Go Runtime）会拦住你：“先生，这个位置现在还没有盘子，虽然位置预留好了，但不能直接倒菜。”
					- append：服务员随即拿来一个盘子放到第 1 个位置，这样你才能把菜放进去。
		- **cap（容量）：**可选参数。底层数组实际分配的空间大小。决定了你在不换底层数组（不扩容）的情况下能 append 多少。如果不传这个参数，默认 `cap` = `len`。
	- **len vs cap：**
		- **长度 (`len`)**：是你**现在**能看见、能读写的数据个数。就像是一个“窗口”。
		- **容量 (`cap`)**：是底层实际预留的总座位数。虽然现在的窗口没开那么大，但座位已经留好了。
	- **make vs new**
		- `new` 返回的是指针。
	- **注意：**
		- 如果你知道将来会追加数据，提前把 `cap` 设大，可以避免 Go 在追加数据（`append`）时频繁地“搬家”（重新分配内存并复制数据）。
	- **示例：**
		- **用法 A：我要一个固定大小的容器，直接用下标操作**
			- ```go
			  s1 := make([]int, 5)
			  // len=5, cap=5
			  // 结果: [0, 0, 0, 0, 0]
			  ```
			- **底层内存模型：**
				- ```
				  切片描述符 (s)                  底层数组 (分配了 5 个 int 的内存)
				  +----------------+            +---+---+---+---+---+
				  | array (ptr)  --|----------> | 0 | 0 | 0 | 0 | 0 |
				  | len: 5         |            +---+---+---+---+---+
				  | cap: 5         |              ^               ^
				  +----------------+              |               |
				                             s[0] (起点)       s[4] (终点)
				  ```
			- **含义**：分配 5 个整数的空间，全部初始化为 0。
			- 如果你去访问 `s[5]`，会报错（越界）。
			- 如果你调用 `append(s1, 1)`，因为容量已满（5/5），Go 必须重新分配更大的内存数组（通常扩容为 10），然后把数据拷过去。
		- **用法 B：指定长度，并预留更大的容量（性能优化）**
			- ```go
			  s2 := make([]int, 3, 5)
			  ```
			- **底层内存模型：**
				- ```
				  切片描述符 (s)                  底层数组 (分配了 5 个 int 的内存)
				  +----------------+            +---+---+---+---|---|
				  | array (ptr)  --|----------> | 0 | 0 | 0 | x | x |
				  | len: 3         |            +---+---+---+---|---|
				  | cap: 5         |              ^       ^   ^   ^
				  +----------------+              |       |   |   |
				                             s[0] (可见)  |   |   底层数组的末尾
				                                          |   |
				                                       s[2]   (不可见，是垃圾数据或默认0)
				                                      (边界)  (一旦 append，就会覆盖这里)
				  ```
			- **含义**：你申请了 5 个位置，但只让程序看到前 3 个。
			- `s2[0]`, `s2[1]`, `s2[2]` 是可以直接读写的（值为 0）。
			- 后面那两个格子（`x`）是存在的，占用了内存，但是 `len` 限制了你的视野，你无法直接通过下标访问它们。
			- 如果你访问 `s2[3]`，程序会 Panic（`index out of range`），因为虽然底层有空间，但你的“窗口(len)”没开到那里。
			- 当你执行 `s = append(s, 99)` 时，不会发生内存分配，直接把第一个 `x` 变成 `99`，然后把 `len` 改为 4，`cap` 依然是 5。
		- **用法 C：我要往里 append 数据，但我知道大概有多少条**
			- ```go
			  s3 := make([]int, 0, 5)
			  ```
			- **底层内存模型：**
				- ```
				  切片描述符 (s)                  底层数组 (分配了 5 个 int 的内存)
				  +----------------+            +---|---|---|---|---|
				  | array (ptr)  --|----------> | x | x | x | x | x |
				  | len: 0         |            +---|---|---|---|---|
				  | cap: 5         |              ^
				  +----------------+              |
				                             (当前没有任何元素可见)
				                             (一上来 append 就会写入第一个位置)
				  ```
			- **含义**：我知道后面可能会存 5 个数据，底层确实预留了 5 个位置，但我现在一个都没有。
		- **用法 D：我完全不知道会有多少数据**
			- `var s []int`
			- 此时不需要 `make`，直接声明为 nil 切片即可，由 `append` 自动管理。
		- **切片的切片**
			- 如果你基于一个现有的切片切一刀，它们共享同一个底层数组。
			- ```go
			  // 假设原文数组 data = [10, 20, 30, 40, 50]
			  s1 := data[1:3] // 也就是取 20, 30
			  ```
			- **底层内存模型：**
				- ```
				  原始数组 data:        [ 10 | 20 | 30 | 40 | 50 ]
				                          ^    ^         ^    ^
				                          |    |         |    |
				  s1 的视角 (ptr 指向 20):     |-------s1------|
				                               |         |    |
				  s1 的结构体:                 Start     End  Cap End
				  +---------------+
				  | ptr: 指向 20   |
				  | len: 2 (20,30)|
				  | cap: 4 (20~50)|  <-- 注意！容量是“从指针位置到底层数组的尽头”
				  +---------------+      所以是 20, 30, 40, 50 这四个位置
				  ```
			- **内存泄漏风险：**
				- 如果你有一个 100MB 的大数组，你只切片取了其中一小段 `small := bigData[0:1]`，只要 `small` 还在使用，这 100MB 的底层数组内存都不会被释放！因为它被 `small` 的 `ptr` 引用着。
- ## 创建 map
  collapsed:: true
	- Map 没有“容量（Cap）”的概念。
	- **语法：两种写法**
		- ```go
		  // 写法 1：不指定大小（最常用）
		  m1 := make(map[string]int)
		  
		  // 写法 2：指定“初始容量提示 (Hint)”
		  m2 := make(map[string]int, 100)
		  ```
	- 在 Map 中，`make(..., 100)` 的 `100` 只是一个 “建议”。
		- 你告诉 Go 运行时，“我大概要往这个 Map 里放 100 个键值对，请帮我提前准备好足够的桶。”
		- **为了性能优化：**
			- 如果不写 100：Go 会先开辟一个很小的空间。当你不断往里 `m["a"]=1`, `m["b"]=2`... 时，Map 会发现空间不够，然后进行 “扩容”。
			- **扩容代价很大：**它需要申请新内存，把旧数据重新计算哈希值并搬运到新桶里。
			- 如果你一开始就写了 100，Go 会一次性分配足够的桶，避免后续频繁搬家。
			- **一句话建议：**如果你大概知道 Map 会存多少数据（比如你知道用户列表有 5000 人），一定要写上这个数字 `make(map[string]User, 5000)`，这能显著减少内存分配次数和 GC 压力。如果你不知道，留空也没问题。
	- **不能对 Map 用 `cap()`：**
		- ```go
		  m := make(map[string]int, 100)
		  
		  fmt.Println(len(m)) // 输出 0 (正确)
		  fmt.Println(cap(m)) // ❌ 编译错误！(Invalid argument for cap)
		  ```
		- **为什么？**
			- 因为 Map 的底层结构（Hash Table）非常复杂，它不是像数组那样连续排列的。它的“容量”是根据负载因子（Load Factor）动态计算的，对于普通开发者来说，知道它底层有多少个 Bucket 并没有实际意义，所以 Go 语言设计者直接屏蔽了 `cap()` 函数。
- ## 注意
	- `make` 函数不能创建数组（Array），只能创建切片（Slice）、Map 和 Channel。
-