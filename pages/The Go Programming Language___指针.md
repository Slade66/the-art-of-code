- **指针是什么？**
  collapsed:: true
	- 当你声明一个变量，比如 `i := 42`，计算机会在内存中找一块地方，把 `42` 这个值存进去。变量就像内存中的房子，里面存放着具体的值。
	- “内存地址” 就像是这个值在内存中的“门牌号”。它是一个数字，唯一标识了数据存储的位置。通过地址，就能找到这间房子并访问其中的内容。
	- 指针（pointer）也是一个变量，但它比较特殊：它里面存的不是一个普通的值（比如 42），而是另一个变量的内存地址。
	- **指针为什么叫指针？**因为指针类型的变量用于存储另一个变量的内存地址，它指向另一个变量在内存中的位置，所以叫它指针。
- **Go 没有指针运算**
  collapsed:: true
	- 在 C/C++ 语言中，你可以对一个指针进行数学运算，比如 `p++`，让指针指向“下一个”内存地址。
	- 这种“指针运算” 非常强大，但极其容易出错，导致内存访问越界、程序崩溃。
	- Go 语言**禁止**了这种行为。在 Go 里，你**不能**对指针做 `p++` 或 `p + 1` 这样的计算。
- **指针操作的两个核心动作：**
  collapsed:: true
	- 用两个特殊符号 `&` 和 `*` 来完成。
	- **取地址：**
		- `&` 符号是“取地址”操作符，用于获取一个已存在的变量的内存地址。
		- ```go
		  i := 42
		  p = &i
		  ```
			- 执行完 `p = &i` 后，`p` 就指向 `i` 了。`p` 的值就是 `i` 的地址，类型是 *int
	- **解引用：**
		- `*` 是通过地址（指针）找到它指向的内存地址，获取其中存储的值。
		- 使用 `*` 符号作用于指针变量，可以获取或更改它所指向的变量的值。
			- `fmt.Println(*p)` (读取)：
				- `p` 是一个指针（存着 `i` 的地址）。
				- `*p`：Go 会“顺着”`p` 里的地址，找到 `i` 的那块内存。
				- `...(*p)`：读取那块内存里的值，也就是 `i` 的值 `42`。
				- 所以这行代码会打印 `42`。
			- `*p = 21` (写入)：
				- `p` 存着 `i` 的地址。
				- `*p`：Go 同样“顺着”`p` 里的地址，找到 `i` 的那块内存。
				- `= 21`：把 `21` 这个新值**写入到那块内存中**。
				- 因为 `i` 和 `*p` 指向的是**同一块内存**，所以修改 `*p` **就是在修改 `i`**。
				- 这就是所谓的“通过指针修改值”。
- **指针类型：**
  collapsed:: true
	- 指针本身是一种特殊的类型。一个指针类型由它所指向的基础类型决定，并以星号作为前缀：`*T`。
	- 如果 `T` 是一个类型（比如 `int`、`string` 或 `MyStruct`），那么 `*T` 就是一个“指向 `T` 的指针类型”。
	- `var p *int`
		- 这行代码声明了一个变量 `p`，它的类型是 `*int`（指向整数的指针类型）。它只能用来存储 `int` 类型变量的地址。
	- 一个指针“指向”什么类型的值，它本身就是“什么类型的指针”，不能指向其它类型的变量。
		- `*int` 和 `*string` 是两种不兼容的类型。您不能将一个 `*int` 类型的值赋给一个 `*string` 类型的变量。
	- 几乎所有类型在 Go 中都有对应的指针类型。
	- **存储大小：**无论一个指针指向 `int` 还是一个巨大的 `struct`，在同一架构下（例如 64 位系统），指针类型本身的大小是固定的（通常是 8 字节），因为它只需要存储一个内存地址。
- **指针的零值：**
  collapsed:: true
	- **指针的零值是 `nil`**。`nil` 是一个特殊的标识符，表示这个指针**不指向任何地方**。它就像一张空白的纸条，上面没写任何地址。
	- 对一个 `nil` 指针进行解引用会导致程序崩溃（panic）。
- **函数与指针：**
  collapsed:: true
	- 函数可以返回指针，只需将返回类型声明为指针类型。在 Go 中，返回指向函数内部局部变量的指针是允许的。即使变量已超出作用域，只要指针仍被使用，Go 会确保该值依然可访问。只有当不再有任何活动引用指向该变量时，垃圾回收器才会对其进行清理。
	- 函数的参数也可以是指针类型，此时应传入变量的地址。如果尝试将值直接传给期望指针类型参数的函数，将导致编译错误。
- **指针的作用：**
  collapsed:: true
	- **修改原始数据：**
	  collapsed:: true
		- 当你把一个变量传给一个函数时，Go 默认会**复制**一份。函数里对这个副本的修改，**不会**影响外面的原变量。
		- 如果你想让函数**能修改**外面的原变量，你就必须传这个变量的**指针 (`&variable`)**。函数接收指针 (`*Type`)，然后通过解引用 (`*p`) 来修改。
	- **提高性能，避免大对象复制：**
	  collapsed:: true
		- 复制一个大 `struct` (结构体) 会占用很多内存和时间。
		- 而复制一个指针，无论它指向多大的数据，指针本身的大小都是固定的（比如 8 字节）。
		- 传递指针可以避免对结构体等大对象的复制，极大提高程序效率。
- **声明用于保存指针的变量：**
  collapsed:: true
	- ```go
	  var myInt int
	  var myIntPointer *int      // 声明一个指向 int 的指针
	  myIntPointer = &myInt      // 将 myInt 的地址赋给指针
	  
	  myInt := 1
	  myIntPointer := &myInt     // 自动推断为 *int 类型
	  
	  ```
- **不可对函数的返回值直接取地址**
  collapsed:: true
	- 在 Go 语言中，不能对**不可寻址的值**使用取址操作符 `&`。
	- 函数返回值属于临时值，通常存储在 CPU 寄存器或临时栈空间中，没有固定的内存地址，因此不可寻址。
	- 若需要取地址，必须先将返回值赋给一个变量，因为局部变量在栈上拥有固定且可寻址的内存地址。
-