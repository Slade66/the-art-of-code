- **包是什么？**
	- 在 Go 语言中，包（package）是最基本的代码组织和复用单元。它本质上就是一个文件夹，里面装着一堆功能相关的 `.go` 源代码文件，也可以包含其他包（即子包）。
	- 包是编程中最小的可独立管理、可复用的代码集合，它既负责组织代码结构，也提供对外可重用的功能。
- **包名的命名规范：**
	- 使用全小写字母；
	- 多个单词直接连写，不使用下划线或驼峰命名。
	- 包的名称通常与其所在文件夹的名称一致。
- **包的作用：**
	- **避免命名冲突**：避免函数、变量命名冲突，使得相同名称的函数或变量在不同包中互不影响；
	- **实现代码复用**：将通用的功能封装在包里，可以被其他项目导入使用；每个 Go 程序都是由一个或多个包（Package）组成的，而整个 Go 项目则是由这些功能独立的包共同构建而成。
	- **组织功能相近的代码**：将功能相近的代码集中在一个包中，结构清晰，便于维护。
	- **封装与访问控制：**Go 通过首字母大小写来控制可见性。一个包内首字母大写的函数或变量（如 `fmt.Println`）可以被包外的代码访问，称为导出 (exported)。首字母小写的（如 `fmt.print`) 则只能在包内部使用，外部无法访问。
- **注意：**
	- **子包独立**：导入一个包不会自动导入其子包。例如，导入 `net` 并不会让你能直接使用 `net/http` 中的内容，后者需要被显式导入。
	- **文件声明**：每个 `.go` 源文件的第一行必须是 `package <包名>` 声明，指明该文件所属的包。
- **包的导入：**[[The Go Programming Language/import]]
- **包的导出：**
	- 在 Go 中，一个东西（变量、常量、函数、类型等）能不能被其他包（package）访问，只看它名字的第一个字母是大写还是小写。
	- 在同一包中，所有函数、变量和常量可以相互访问。以大写字母开头的标识符可被包外访问（即“导出”），小写字母开头的标识符仅在包内可见（即“未导出”）。
	- **核心规则：大小写决定“公有”与“私有”**
		- 想象一下，你开了一家店（这就是一个包 `package`）。
		- **首字母大写 (Capital Letter)** = **公开的 (Exported / Public)** 对所有包可见，作为包的 API 对外提供功能。🏛️这就像你把商品放在店门口的橱窗里展示。任何路过的人（其他的包 `package`）都能看到它、使用它。
		- **首字母小写 (Lowercase Letter)** = **私有的 (Unexported / Private)** 仅在同一个包内可见，作为包的内部实现细节，不希望外部干预。🚪这就像你把东西放在仓库或者后厨里。只有你自己店里的员工（同一个包 `package` 内部的代码）才能看到和使用，外人是接触不到的。
		- Go 语言用这种极其简洁的方式取代了其他语言中常见的 `public`, `private`, `protected` 等关键字。这个设计是 Go 语言追求简洁哲学的一个完美体现。你不需要记忆复杂的关键字，只需要看一眼名字的大小写，就能立刻判断它的作用域和可见性。
- **特殊的  `main`  包：**
	- `main` 是一个特殊的包名称，表示该包是程序的入口，程序从 `main` 包开始运行。
	- 只有被声明为 `main` 的包，且包含 `main()` 函数时，程序才能被构建为可执行文件并运行。
- **为什么说包是“最基本的组织单元”**
	- 在编程里，我们要管理很多代码文件。
	- 如果没有“包”的概念，所有文件都堆在一起，会像一个杂乱无章的文件夹，根本分不清哪些文件是干什么的。
	- “包”就是一种分组方式。
		- 按功能归类（比如 `net` 网络相关，`io` 输入输出相关）
		- 按层级划分（比如 `service`、`dao`、`api`）
	- 没有比它更底层的组织形式（在 Go 中，函数、结构体都要放在某个包里），所以说它是最基本的“代码组织”单元。
- **包的比喻理解：**
	- 你可以把：
		- **函数**看成是一颗螺丝（零件）
		- **包**看成是一整个“零件袋”
		- **模块/项目**看成是一台完整的机器
	- 一个机器（项目）由很多零件袋（包）组成；
	- 每个零件袋里装了很多螺丝、齿轮、弹簧（函数、结构体等）。
	- 你要造别的机器时，不用重新做螺丝，只要拿这个“零件袋”过来用就行。
- **为什么说包是可独立管理的？**
	- 包拥有完整的内部实现和明确的外部接口，可以被单独开发、测试、编译、维护、发布，而不依赖于整个项目的其他部分。
	- 换句话说，一个包不需要知道“整个系统长什么样”，它只管自己的功能范围就行。
	- 比如你有一个项目结构：
		- ```go
		  myapp/
		    ├── main.go
		    ├── user/
		    │     └── user.go
		    └── utils/
		          └── string_utils.go
		  ```
		- `user` 包只负责用户相关逻辑（注册、登录等）
		- `utils` 包只负责字符串工具函数（比如去除空格、格式化等）
		- 你完全可以只修改 `utils` 包、测试它的功能，而不用动 `main.go` 或 `user.go`。
		- 你甚至可以把整个 `utils` 文件夹复制出来，放到另一个项目里继续用，这就是“独立管理”。
	- **生活类比：**
		- 你可以把“包”想成是一个独立生产的小工厂。
		- 每个工厂只生产自己那类零件（功能）。
		- 工厂内部的机器、工人（函数、结构体）自己安排、自己管理。
		- 外面的人只关心“你能提供什么产品（API）”，而不管你怎么生产。
		- 这样整个“工业区”（项目）就可以由多个独立工厂组成，每个工厂都能独立升级、测试、替换，而不会影响别的工厂。
- **为什么说包是“复用单元”**
	- “复用”就是“别的地方也能用”。
	- 当你写好一个包，比如：
		- ```go
		  package mathutils
		  
		  func Add(a, b int) int {
		      return a + b
		  }
		  ```
	- 别的程序可以直接：
		- ```go
		  import "yourproject/mathutils"
		  
		  fmt.Println(mathutils.Add(1, 2))
		  ```
	- 包是可以被其他程序直接导入、直接使用的，这就实现了代码复用，而不需要复制粘贴代码。因此它是最基本的复用单位。
- **Go 语言有两种类型的包：**
	- **可执行包：**任何包含一个无参数、无返回值的 `main` 函数的包，且其包声明为 `package main`，编译后都会生成一个可执行文件。当这个可执行文件运行时，它会从 `main` 包中的 `func main()` 函数开始执行。这个 `main` 函数就是整个程序的入口 (Entry Point)。操作系统运行你的程序时，就是从这个 `main` 函数开始执行的。
	  collapsed:: true
		- **示例：**
			- 一个最简单的 Go 程序长这样：
			- ```go
			  package main // 声明为 main 包，表明它是一个可执行程序
			  
			  import "fmt" // 导入 fmt 包
			  
			  // 程序入口函数
			  func main() {
			  	fmt.Println("Hello, World!")
			  }
			  ```
	- **库包：**如果一个包不叫 `main`，它就是一个库包，这种包的目的是提供功能给其他包使用，不能被直接执行，只能被其他程序导入使用。
	  collapsed:: true
		- 包名可以是除了 `main` 以外的任何名字，比如 `"fmt"`, `"net/http"`, `"math/rand"` 等。
- **包名和导入路径：**
	- 按照约定，包名（package name）与其导入路径（import path）的最后一个元素相同。导入路径的最后一部分必须和包名一致。
		- 以 `"math/rand"` 为例：
			- 导入路径：`"math/rand"`
			- 路径的最后一个元素：`rand`
			- 所以，这个包里的所有 `.go` 文件都必须以 `package rand` 开头。
	- **导入路径（Import Path）：**是用来唯一标识一个包的字符串，是你在 `import` 语句中写的那个字符串，例如 `"fmt"` 或 `"math/rand"`。Go 的工具链会根据这个路径去寻找对应的包文件。
	- **包名 (Package Name)**：是你在源代码文件第一行 `package <包名>` 中声明的名字，也是你在代码中实际使用的名字。
	- 导入路径由目录决定，而代码中的包名由 `package` 声明决定。
	- 当你在代码中使用包时，你用的是包名，而不是完整的导入路径：
		- ```go
		  package main
		  
		  import (
		  	"fmt"
		  	"math/rand" // 使用导入路径
		  )
		  
		  func main() {
		  	// 使用包名 `rand` 来调用里面的函数
		  	// 正确 ✅: rand.Intn(100)
		  	// 错误 ❌: math/rand.Intn(100)
		  	fmt.Println("A random number:", rand.Intn(100))
		  }
		  ```
- **如何导入本项目的包？**
	- `import "<模块名>/<从根目录到包的路径>"`
- **下划线导入**
	- 导入包只是为了执行该包的 `init()` 函数，不需要使用该包的任何导出标识符。
	- import 一个包，但不使用，只是用于执行该包的 `init()` 函数，例如注册数据库驱动，用空白符占位。
- **点导入**
	- 如果你使用 `import . "fmt"` 导入了 `fmt` 包，你应该**直接调用** `Println` 函数，不需要加包名作为前缀。
	- **省略包名：**
		- 通常，当你导入一个包（例如 `import "fmt"`）后，你需要使用包名来调用其中的函数或变量，如 `fmt.Println()`。
		- 使用点导入后，你**可以省略包名**，直接使用该包导出的标识符（如函数、变量、类型等），就好像它们是定义在你当前的包中一样。
	- **示例：**
		- ```go
		  package main
		  
		  import (
		      . "fmt" // 注意这里的点号（.）
		  )
		  
		  func main() {
		      // 直接调用 Println，就像它在当前包中定义一样
		      Println("Hello, World!")
		      Printf("Another example.\n")
		  }
		  ```
- **包的 `init()` 函数**
	- `init()` 函数是一个特殊的、不需要任何参数也不返回任何值的函数，它用于在程序执行前，完成包级别的初始化工作。
	- **核心特性：**
		- **没有参数和返回值：**它的定义格式固定为 `func init() {}`。
		- **自动调用：**`init()` 函数不能被程序中的其他代码显式调用，它会在包被导入时自动执行。
		- **一个包可以有多个 `init()`：**你可以在同一个包中定义多个 `init()` 函数，可以分散在不同的源文件（Source File）中。它们会按照一定的顺序（见下文）被依次调用。
		- **无需导出：**`init()` 函数不需要以大写字母开头，因为它不是供外部包调用的，它只在包加载时执行。
	- **`init()` 函数的执行时机和顺序**
		- `init()` 函数的执行发生在程序真正开始运行（即调用 `main.main()` 函数）之前。
		- **先初始化依赖：**Go 运行时会按照包的依赖关系，从底层到上层依次初始化。被当前包导入的包会先被初始化。
		- **常量和变量：**在调用 `init()` 函数之前，会先初始化包级别的所有常量（`const`）和变量（`var`）。如果变量的初始化需要调用函数，这些函数会先于 `init()` 函数执行。
		- **执行 `init()` 函数：**按文件名的字典序，依次执行文件中的 `init()` 函数。
		- **执行 `main()` 函数：**当所有导入包的 `init()` 函数都执行完毕后，才会执行主包中的 `main()` 函数，程序正式开始运行。
	- `init()` 函数的应用场景：
		- **注册驱动：**常用于注册数据库驱动。
		- **初始化配置：**进行一些复杂的、运行时才能确定的配置或校验。例如，读取配置文件、校验环境变量、设置复杂的全局状态等。
- **Go 运行时如何处理“钻石型”依赖（A 依赖 B 和 C，B 依赖 C）？**
	- **包只会被加载一次：**一个包无论被多少个其他包导入，它都只会被编译、加载和初始化一次。
	- Go 运行时在加载程序时会构建一个完整的包依赖图（Package Dependency Graph）。在初始化过程中，它会确保每个包都有一个状态标记，通常是“未初始化”、“正在初始化”或“已完成初始化”。
	- 当运行时尝试初始化一个包时：
		- 它会**递归地（Recursively）**优先初始化该包所依赖的所有包。
		- 在递归过程中，如果发现某个依赖包已经被标记为**“已完成初始化”**，则跳过对该包的初始化步骤，避免重复工作。
- **`internal` 目录有什么用？**
	- **`/internal`：** 存放**只能被本项目内部**使用的私有库代码。
	- **强制限制可见性：**任何包含在名为 `internal` 的目录或其子目录中的代码包，都只能被其**直接父目录**的代码（以及该父目录的子孙目录）导入。
	- **示例：**
		- 假设你的项目模块路径是 `github.com/your/module`。
		- 包路径是 `github.com/your/module/foo/internal/bar`。
		- 只有在 `github.com/your/module/foo` 目录树下的代码包（例如 `foo/baz`、`foo/main.go` 等）才能导入 `bar` 包。
		- 项目根目录下的其他包（例如 `github.com/your/module/cmd/api` 或 `github.com/your/module/pkg/utils`）**不能**导入 `bar` 包。
	- **总结：**`internal` 包只能被其父目录及其所有子目录中的代码导入。
	- **隔离实现细节：** 它可以用来存放那些仅供本项目内部逻辑使用的、不希望暴露给外部的实现细节。由于外部无法导入 `internal` 中的代码，开发人员可以放心地对 `internal` 中的代码进行重构（Refactor）、修改 API，而不用担心破坏（Breaking）其他外部依赖方。这极大地提高了内部代码的灵活性。
- **包循环依赖**
	- 当出现包 A 导入包 B，同时包 B 也导入包 A 的情况时，Go 编译器会立即报错，阻止代码编译通过。
	- 如果 A 依赖 B 且 B 依赖 A，那么 Go 运行时就无法确定哪个包应该先初始化。
		- 如果先初始化 A，A 需要 B 的初始化结果。
		- 如果先初始化 B，B 需要 A 的初始化结果。
	- 这将导致初始化过程陷入**死锁**，禁止循环依赖从根本上解决了这个问题。
- **包别名：**
	- **问题：**
		- 需要导入 `fmt` 和 `log` 包，但这两个包都有一个 `Println` 函数。你希望明确区分它们。
		- 使用包别名（如 `f` 和 `l`） `import f "fmt"` 和 `import l "log"` 可以解决命名冲突，为导入的包指定一个临时的、局部的替代名称。使得调用 `f.Println()` 和 `l.Println()` 非常清晰。
	- **格式：**`import 别名 包的导入路径`
	- **作用：**
		- **解决命名冲突：**当你的代码需要导入两个或多个**名称相同**（但导入路径不同）的包时，如果不使用别名，编译器会因为命名冲突而报错。使用别名可以为其中一个或两个包指定不同的本地名称。
		- **简化长包名：**有时候包的导入路径很长，或者包名（即导入路径的最后一个组件）较长且在代码中需要频繁使用。通过指定一个简短的别名，可以使代码更简洁。
-