- **Jenkins 是什么？有什么用？**
	- Jenkins 是一个专门负责自动化 “构建、测试、部署” 整个流程的机器人。
- **自动化构建：**
	- **过去的问题：** 程序员写完代码，需要在自己的电脑上手动运行编译命令、打包文件、跑测试脚本。这不仅浪费时间，还容易因为人的疏忽而出错。
	- **Jenkins 的解法：** 只要代码一提交，Jenkins 就会自动接管后续的所有脏活累活：编译、检查代码规范、单元测试、打包生成 `jar/exe/docker镜像` 等。
- **Pipeline as Code（流水线即代码）：**
	- **Pipeline：**工厂里的“生产脚本”。定义整个 “拉代码 → 构建 → 测试 → 推镜像 → 部署” 流程的详细工作步骤，Pipeline 就像一张详细的“生产工序说明书”，Agent 根据它一步一步执行。
	- 你可以通过一个叫 `Jenkinsfile` 的文本文件来定义整个构建过程。这意味着构建流程本身也变成了代码，可以被版本控制、审查和回滚，实现了“基础设施即代码”。
- **Jenkins 主从架构：**
	- **Controller：**负责调度、管理、分配任务。控制整个 Jenkins 集群。
		- 它负责：
			- 接收用户操作（比如你点了“构建”）
			- 调度任务（决定由谁来执行）
			- 管理配置、插件、凭据
			- 显示构建日志、结果
			- **注意：**通常不建议让 Controller 干重活（编译代码），防止它累垮了导致整个管理后台打不开。
		- 就像工厂的管理中心，不直接干活，但负责安排所有工作。
	- **Agent：**负责真正执行构建、测试、打包等任务。
- **Jenkins + Kubernetes：**
	- **如果不使用 Kubernetes：**
		- 通常采用的是传统的 “静态主从架构”：即 Master + 几台固定的虚拟机（VM）或物理机作为 Agent。
		- **问题：**
			- **资源浪费：**为了应对高峰期的构建任务，你可能买了 10 台强力服务器。但到了晚上或周末，没人提交代码，这 10 台机器依然开着机，CPU 和内存利用率为 0，但电费和云资源费照样扣。
			- **环境污染：**所有项目的构建都在这几台固定的机器上跑。项目 A 需要 Python 2.7，项目 B 需要 Python 3.10。项目 C 把全局的 GCC 库升级了，导致项目 D 编译失败。
			- **扩展性差，响应慢：**突然来了 100 个构建任务（比如在大促上线前），但你只有 5 台 Agent。后 95 个任务只能排队等待（Pending），开发人员干着急。
	- **把 Jenkins 部署在 K8s 上，使用的是动态 Agent 模式：**
		- **极致的弹性与成本节约：**
			- 平时没有构建任务时，K8s 上一个 Agent Pod 都没有（资源占用为 0）。
			- Jenkins Controller 可以借助 Kubernetes 插件动态创建临时 Agent Pod 执行构建任务：每次任务启动时，K8s 调度一个新的 Agent Pod，Pod 启动后立即执行构建，任务完成后 Pod 会被销毁，从而有效节省资源。
		- **环境隔离与“总是全新”：**
			- 每次构建都在一个全新的、干净的容器（Pod）里进行。
			- 构建结束 Pod 直接销毁。你永远不用担心上一次构建留下的垃圾文件会影响这一次，也不用担心软件版本冲突。
			- 如果需要升级构建环境（比如从 Java 8 升到 Java 11），你只需要修改 Jenkinsfile 里的镜像版本。Agent 变成了“用完即弃”的消耗品，不需要维护。
		- **高并发：**K8s 集群本身是个庞大的资源池。只要集群资源够，并发数几乎没有上限。
- **共享库（Shared Libraries）：**
	- 将通用的构建逻辑（DNS映射、SSH挂载、Git配置）封装成 Groovy 函数（如 `withGoEnv`）。
	- 业务流水线只需一行 `@Library` 调用，实现极简配置和统一维护。
- **语法：**
	- `pipeline`：声明式流水线的根节点。所有的流水线逻辑必须包裹在这个块中。
		- `agent`：定义了流水线在哪个节点（机器）上运行。
		  collapsed:: true
			- **示例：**`agent { label 'node149' }`
			- `label`：指定具体的节点标签。Jenkins 会查找拥有 `node149` 标签的 Slave 节点来执行任务。如果不指定 `label` 而用 `any`，则会在任意可用节点运行。
		- `stages`：包含所有执行阶段的容器。
			- `stage('阶段的名字')`：定义一个具体的逻辑阶段（如“拉取代码”、“构建”、“部署”）。
				- `steps`：每个 `stage` 必须包含一个 `steps` 块。这里面写具体的执行指令。
					- `git(...)`：从 Git 仓库下载代码到当前的构建工作空间（workspace）里，让接下来的 stage 都能基于这份代码进行。
					  collapsed:: true
						- **原理：**每一个 Jenkins 任务都会有自己的 workspace 目录，这个目录实际存在 Jenkins agent 的文件系统上，Pipeline 所有 stage 默认都在这个同一个 workspace 中执行，就行流水线上的工作台被不同的 stage 轮流使用。
						- `url`：代码仓库的地址。
						- `credentialsId`：在 Jenkins 系统管理中配置的凭据 ID（通常是 SSH 私钥），用于免密访问 Git。
						- `branch`：需要拉取的目标分支。
					- `script`：用来在流水线里执行一段纯 Groovy 脚本逻辑的地方。
						- `withEnv(["KEY=VALUE"]) { ... }`：临时设置环境变量。仅在花括号内的代码块有效。
						- `sshagent([...]) { ... }`：用来在一段代码块中临时加载指定的 SSH 私钥，在 `{}` 内的命令拥有 SSH 私钥，可以顺利执行 `git clone`、`git pull`、`scp` 等需要 SSH 的操作。
						- `docker`：让你的 Pipeline 在“指定的 Docker 容器里”执行步骤。在 `{ ... }` 块内的所有命令，实际上都是在容器内部执行的，块执行结束后，容器会自动销毁。
						  id:: 692fad98-5bd2-45f8-a438-aa983bc845a2
							- **没用它前：**
								- Jenkins 直接在宿主机里跑所有步骤。
								- 构建依赖什么环境，就必须在 Jenkins 服务器上提前安装好。
								- 环境容易“污染”：你装了 A 项目需要的 Node 16，另一项目可能需要 Node 18 → 冲突。
							- **使用它后：**
								- Jenkins 会根据你指定的镜像，启动一个临时的 Docker 容器。
								- Pipeline 阶段里的指令在容器内部执行。
								- 每次执行都是“干净环境”，构建稳定、可复现，步骤跑完后容器会被销毁，不会污染主机环境。
								- 产物依然会放在当前 Pipeline 的工作空间。
							- **示例：**
								- **指定一个容器运行整个 stage：**
									- ```groovy
									  pipeline {
									      agent {
									          docker {
									              image 'golang:1.22'
									          }
									      }
									      stages {
									          stage('Build') {
									              steps {
									                  sh 'go build ./...'
									              }
									          }
									      }
									  }
									  ```
									- 这条 Pipeline 从头到尾都在一个 `golang:1.22` 的容器里运行。
							- `docker.image('xxx').inside { ... }`：开启一个临时容器，将宿主机的工作目录挂载进去，把下面的命令全部丢进去执行。
	- `${...}`：字符串插值。在双引号 `"` 中，`${variable}` 会被替换成变量的实际值。
	-
-