- **Jenkins 是什么？有什么用？**
	- Jenkins 是一个专门负责自动化 “构建、测试、部署” 整个流程的机器人。
- **自动化构建：**
	- **过去的问题：** 程序员写完代码，需要在自己的电脑上手动运行编译命令、打包文件、跑测试脚本。这不仅浪费时间，还容易因为人的疏忽而出错。
	- **Jenkins 的解法：** 只要代码一提交，Jenkins 就会自动接管后续的所有脏活累活：编译、检查代码规范、单元测试、打包生成 `jar/exe/docker镜像` 等。
- **Pipeline as Code（流水线即代码）：**
	- **Pipeline：**工厂里的“生产脚本”。定义整个 “拉代码 → 构建 → 测试 → 推镜像 → 部署” 流程的详细工作步骤，Pipeline 就像一张详细的“生产工序说明书”，Agent 根据它一步一步执行。
	- 你可以通过一个叫 `Jenkinsfile` 的文本文件来定义整个构建过程。这意味着构建流程本身也变成了代码，可以被版本控制、审查和回滚，实现了“基础设施即代码”。
- **Jenkins 主从架构：**
	- **Controller：**负责调度、管理、分配任务。
		- 它负责：
			- 接收用户操作（比如你点了“构建”）
			- 调度任务（决定由谁来执行）
			- 管理配置、插件、凭据
			- 显示构建日志、结果
			- **注意：**通常不建议让 Controller 干重活（编译代码），防止它累垮了导致整个管理后台打不开。
		- 就像工厂的管理中心，不直接干活，但负责安排所有工作。
	- **Agent：**负责真正执行构建、测试、打包等任务。
	- 我们利用 Docker 实现了“动态 Agent”，用完即焚，环境隔离。
- **共享库（Shared Libraries）：**
	- 将通用的构建逻辑（DNS映射、SSH挂载、Git配置）封装成 Groovy 函数（如 `withGoEnv`）。
	- 业务流水线只需一行 `@Library` 调用，实现极简配置和统一维护。
- **语法：**
	- `pipeline`：声明式流水线的根节点。所有的流水线逻辑必须包裹在这个块中。
		- `agent`：定义了流水线在哪个节点（机器）上运行。
		  collapsed:: true
			- **示例：**`agent { label 'node149' }`
			- `label`：指定具体的节点标签。Jenkins 会查找拥有 `node149` 标签的 Slave 节点来执行任务。如果不指定 `label` 而用 `any`，则会在任意可用节点运行。
		- `stages`：包含所有执行阶段的容器。
			- `stage('阶段的名字')`：定义一个具体的逻辑阶段（如“拉取代码”、“构建”、“部署”）。
				- `steps`：每个 `stage` 必须包含一个 `steps` 块。这里面写具体的执行指令。
					- `git(...)`：从 Git 仓库下载代码到当前的构建工作空间（workspace）里，让接下来的 stage 都能基于这份代码进行。
					  collapsed:: true
						- **原理：**每一个 Jenkins 任务都会有自己的 workspace 目录，这个目录实际存在 Jenkins agent 的文件系统上，Pipeline 所有 stage 默认都在这个同一个 workspace 中执行，就行流水线上的工作台被不同的 stage 轮流使用。
						- `url`：代码仓库的地址。
						- `credentialsId`：在 Jenkins 系统管理中配置的凭据 ID（通常是 SSH 私钥），用于免密访问 Git。
						- `branch`：需要拉取的目标分支。
					- `script`：用来在流水线里执行一段纯 Groovy 脚本逻辑的地方。
						- `withEnv(["KEY=VALUE"]) { ... }`：临时设置环境变量。仅在花括号内的代码块有效。
						- `sshagent([...]) { ... }`：用来在一段代码块中临时加载指定的 SSH 私钥，在 `{}` 内的命令拥有 SSH 私钥，可以顺利执行 `git clone`、`git pull`、`scp` 等需要 SSH 的操作。
						- `docker`：让你的 Pipeline 在“指定的 Docker 容器里”执行步骤。在 `{ ... }` 块内的所有命令，实际上都是在容器内部执行的，块执行结束后，容器会自动销毁。
						  id:: 692fad98-5bd2-45f8-a438-aa983bc845a2
							- **没用它前：**
								- Jenkins 直接在宿主机里跑所有步骤。
								- 构建依赖什么环境，就必须在 Jenkins 服务器上提前安装好。
								- 环境容易“污染”：你装了 A 项目需要的 Node 16，另一项目可能需要 Node 18 → 冲突。
							- **使用它后：**
								- Jenkins 会根据你指定的镜像，启动一个临时的 Docker 容器。
								- Pipeline 阶段里的指令在容器内部执行。
								- 每次执行都是“干净环境”，构建稳定、可复现，步骤跑完后容器会被销毁，不会污染主机环境。
								- 产物依然会放在当前 Pipeline 的工作空间。
							- **示例：**
								- **指定一个容器运行整个 stage：**
									- ```groovy
									  pipeline {
									      agent {
									          docker {
									              image 'golang:1.22'
									          }
									      }
									      stages {
									          stage('Build') {
									              steps {
									                  sh 'go build ./...'
									              }
									          }
									      }
									  }
									  ```
									- 这条 Pipeline 从头到尾都在一个 `golang:1.22` 的容器里运行。
							- `docker.image('xxx').inside { ... }`：开启一个临时容器，将宿主机的工作目录挂载进去，把下面的命令全部丢进去执行。
	- `${...}`：字符串插值。在双引号 `"` 中，`${variable}` 会被替换成变量的实际值。
	-
-