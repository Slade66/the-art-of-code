- **基本概念：**
	- 数组是一种存储相同类型元素的数据结构。
- **你几乎不会直接使用数组。你会一直使用切片**
	- **固定长度太死板：** 你无法在运行时动态添加或删除元素。
	- **值类型（传参复制）开销巨大：**传递大数组会导致性能问题。
- **声明数组：**
	- **语法：**`[n]T`
		- `n`：数组的长度，最多能保存多少个元素。
		- `T`：数组要保存的元素是什么类型，比如 `int`、`string` 或 `float64`。
		- 类型 `[n]T` 是一个包含 n 个 T 类型值的数组。
	- **示例：**
		- ```go
		  var a [3]int // 声明一个保存 3 个 int 类型值的数组
		  ```
- **数组的零值：**
	- 当你只声明而不初始化时，数组中的每个元素会被 Go 自动用其类型零值填满。
	- **举例：**
		- `var a [10]int`：这行代码声明了一个变量 `a`，它是一个包含了 10 个 int 类型值的数组。
		- `int` 的零值是 `0`。所以，`a` 此时是一个包含 10 个 `0` 的数组：`[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`。
- **初始化数组：**
	- **使用数组字面量初始化数组**：
		- 如果你已经知道数组的初始值，可以在声明的时候直接用数组字面量来进行初始化。
		- ```go
		  var a [3]int = [3]int{1, 2, 3} // 显式指定数组类型和长度
		  ```
	- **类型由值推断**：
		- 如果你不想显式指定类型，可以省略类型，由编译器自动推断。
		- ```go
		  var a = [3]int{1, 2, 3} // 编译器会根据值推断类型
		  ```
	- **推荐：用短变量声明省略 = 号左边的类型和 var**：
		- 如果你使用 `:=` 语法，编译器会自动推断出类型。
		- ```go
		  a := [3]string{"Go", "Rust", "Python"} // 编译器推断出a是一个长度为3的string类型数组
		  ```
	- **自动推导数组长度**：
		- 使用 `...`，编译器在编译时会根据初始化的值的数量自动推导出数组的长度。
		- ```go
		  a := [...]float64{3.14, 2.71, 1.41} // 数组的长度会根据元素的个数自动推导
		  ```
	- **指定索引进行初始化**：
		- 可以通过指定某个索引来初始化数组的部分元素，其他未指定的元素将被初始化为零值。
		- ```go
		  a := [...]int{100, 3: 400, 500} // 指定索引 3 初始化为 400，输出结果是：[100 0 0 400 500]
		  ```
- **长度是数组类型的一部分**
	- **数组不能被重设大小：**数组的长度在创建时确定，在编译时就固定死的。
	- **数组的类型由元素类型和长度共同决定：**
		- ```go
		  var a [10]int
		  var b [20]int
		  ```
		- 在 Go 看来，`a` 和 `b` 是**完全不同、互不兼容**的类型。`a` 的类型是 `[10]int`，`b` 的类型是 `[20]int`。
		- 你**不能**这样做：`a = b` (编译错误)。
		- 你**不能**把 `[10]int` 传递给一个需要 `[20]int` 的函数。
- **多维数组：**
	- ```go
	  // 声明一个 2x3 的二维数组 (2 行 3 列)
	  var matrix [2][3]int
	  
	  // 赋值
	  for i := 0; i < 2; i++ {
	      for j := 0; j < 3; j++ {
	          matrix[i][j] = i*10 + j
	      }
	  }
	  
	  fmt.Println(matrix)
	  // 输出: [[0 1 2] [10 11 12]]
	  
	  // 也可以用字面量初始化
	  matrixLiteral := [2][3]int{
	      {1, 2, 3}, // 第 0 行
	      {4, 5, 6}, // 第 1 行
	  }
	  fmt.Println(matrixLiteral)
	  // 输出: [[1 2 3] [4 5 6]]
	  ```
	- 多维数组在内存中仍然是**连续**的。`matrixLiteral` 在内存中的布局就是 `[1, 2, 3, 4, 5, 6]`。
- **数组是值类型**
	- **含义：** 当一个数组变量被赋值给另一个变量，或者被**传递给一个函数**时，Go 会**完整地复制**这个数组的所有元素。
	- **结果：** 函数接收到的是原始数组的一个**副本 (copy)**，而不是指向原始数组的引用。在函数内部修改这个副本，**不会**影响到函数外部的原始数组。
	- **示例：传递数组给函数**
		- ```go
		  package main
		  
		  import "fmt"
		  
		  // 这个函数接收一个 [3]int 类型的数组
		  // 注意：它接收的是一个副本！
		  func modifyArray(arr [3]int) {
		      arr[0] = 100 // 修改副本的第一个元素
		      fmt.Println("Inside function:", arr) // 输出: [100 2 3]
		  }
		  
		  func main() {
		      // 1. 定义一个原始数组
		      original := [3]int{1, 2, 3}
		      fmt.Println("Before function:", original) // 输出: [1 2 3]
		  
		      // 2. 将数组传递给函数
		      //    Go 在这里复制了 'original' (3 个 int)
		      //    'modifyArray' 函数里的 'arr' 是一个新数组
		      modifyArray(original)
		  
		      // 3. 检查原始数组
		      //    'original' 根本没有被修改！
		      fmt.Println("After function:", original) // 输出: [1 2 3]
		  }
		  ```
		- **性能警告：**想象一下，如果数组不是 `[3]int`，而是 `[1000000]int`（包含一百万个整数）。当你调用 `modifyArray(largeArray)` 时，Go 会在内存中复制整个数组，也就是复制这一百万个整数。这将消耗大量时间和内存，带来严重的性能问题。
	- **用数组指针在函数中修改原数组**
		- 传递指针时，Go 只会复制这个指针（一个内存地址，通常 8 字节），这个开销非常小。
		- 函数的参数类型从 `[n]T` 变为 `*[n]T`。
		- 无需对数组的指针解引用，用 `[]` 的时候 Go 会自动解引用。
		- **示例：传递数组指针**
			- ```go
			  package main
			  
			  import "fmt"
			  
			  // 这个函数接收一个 *[3]int 类型 (指向 [3]int 数组的指针)
			  func modifyArrayWithPointer(arr *[3]int) {
			      // arr 是一个指针，我们用 (*arr) 解引用来获取数组本身
			      // 然后修改它的第一个元素
			      // (*arr)[0] = 100 
			      
			      // Go 同样为数组指针提供了语法糖，允许你省略括号
			      arr[0] = 100 // 编译器会自动处理为 (*arr)[0] = 100
			  
			      fmt.Println("Inside function:", *arr) // 输出: [100 2 3]
			  }
			  
			  func main() {
			      original := [3]int{1, 2, 3}
			      fmt.Println("Before function:", original) // 输出: [1 2 3]
			  
			      // 2. 传递 original 的内存地址 (&)
			      modifyArrayWithPointer(&original)
			  
			      // 3. 检查原始数组，它被成功修改了！
			      fmt.Println("After function:", original) // 输出: [100 2 3]
			  }
			  ```
-