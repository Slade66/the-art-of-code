基本概念
heading:: true
	- 缓冲池的作用
	  heading:: true
		- Buffer Pool（缓冲池）是 InnoDB 用于缓存磁盘数据页的一块内存区域，旨在缓解数据库系统面临的关键性能瓶颈——内存与磁盘之间巨大的速度差异。由于数据库必须将数据持久化存储在磁盘上，而磁盘访问速度远低于内存。如果每次查询都必须从磁盘读取数据，系统性能将大幅下降。缓冲池通过将频繁访问的数据加载并保留在内存中，使得数据的读写操作大多可以直接在内存中完成，从而显著减少磁盘 I/O 次数，大幅提升整体性能。
	- 以页为单位进行缓存
	  heading:: true
		- InnoDB 将数据以页为单位进行存储，缓冲池的所有管理操作也是以页为单位进行的，而不是行。当查询某条记录时，系统会将该记录所在的整个页加载进缓冲池中。
	- 缓冲池的数据读写流程
	  heading:: true
		- 当需要读取某个数据页时，InnoDB 会先尝试从 Buffer Pool 中查找；若未命中，则从磁盘加载该页并缓存于 Buffer Pool，后续访问可直接从内存中获取，显著提升访问速度。对于数据页的修改操作，InnoDB 并不会立即将变更写入磁盘，而是将被修改的页标记为“脏页”。这些脏页将由后台线程在合适的时机异步刷新至磁盘，通过将多次小规模写入合并为一次更大的批量写操作，从而进一步优化磁盘 I/O 性能。
- 缓冲池的配置
  heading:: true
	- 容量配置
	  heading:: true
		- `innodb_buffer_pool_size` 参数用于设定 InnoDB 缓冲池的总大小。该参数以字节为单位，定义了 MySQL 服务器启动时为缓冲池一次性分配的内存总量。
		- 如果缓冲池设置过小，会导致命中率下降，数据页在内存与磁盘之间频繁交换（抖动），从而引发大量磁盘 I/O，显著降低数据库性能；而若缓冲池设置过大，使得其占用的内存加上其它进程所需的内存超过了系统的物理内存总量，操作系统将启用交换空间（Swap），引发频繁的页面置换，进而拖慢整个系统的响应速度。
		- 查看配置
		  heading:: true
			- ```sql
			  SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
			  ```
			- MySQL 默认的缓冲池大小为 128MB。
		- 修改配置
		  heading:: true
			- **通过配置文件修改：**
				- 编辑 MySQL 的配置文件（在 Linux 系统上通常是 `/etc/mysql/my.cnf`，在 Windows 上是 `my.ini`）。在该文件的 `[mysqld]` 段落下，添加或修改 `innodb_buffer_pool_size` 配置项。
				- ```ini
				  [mysqld]
				  innodb_buffer_pool_size = 1G
				  ```
				- 对配置文件所做的更改只有在重启 MySQL 服务后才会生效。重启后，该设置便会永久生效——只要不再修改配置文件，每次启动时都会沿用这一值。
		- 配置策略
		  heading:: true
			- 建议将缓冲池大小设置为系统总内存的 60%–80%，并为操作系统及其他关键进程预留足够内存，以避免因缓冲池过大导致内存不足，进而引发性能下降或服务不稳定。
	- 实例配置
	  heading:: true
		- 在早期的 MySQL 版本中，InnoDB 使用一个全局互斥锁（mutex）统一管理整个缓冲池。这意味着所有并发线程在访问缓冲池时都必须竞争这把唯一的锁。在高并发负载下，这种单一锁机制容易成为性能瓶颈，导致严重的线程争用，进而显著降低数据库的吞吐量。
		- 为了缓解这一问题并提升并发性能，MySQL 引入了 `innodb_buffer_pool_instances` 参数。将该参数设置为大于 1 的值，可以将缓冲池逻辑上划分为多个独立实例。每个实例拥有自己的锁和内部数据结构，从而减少了对共享资源的争用，显著提升了并发访问性能。
		- 需要注意的是，`innodb_buffer_pool_instances` 的生效依赖于前提条件：缓冲池总大小（由 `innodb_buffer_pool_size` 指定）必须至少为 1GB。如果不足 1GB，即使配置了多个实例，InnoDB 也会自动将实例数重置为 1。当多个实例成功启用后，`innodb_buffer_pool_size` 所定义的总内存将被平均分配给各个实例。
- 关键的内部数据结构
  heading:: true
	- InnoDB 使用多种内部数据结构来高效管理缓冲池中的页面。
	- LRU 列表（LRU List）
	  heading:: true
		- LRU（Least Recently Used，最近最少使用）算法
		  heading:: true
			- 当缓冲池已满且需加载新页面时，LRU 算法通过优先保留最近或频繁访问的“热”数据页，淘汰最久未被访问的“冷”页，从而为新页面腾出空间，提高缓存命中率。
			- 缓存命中率：
				- 命中：请求的数据已存在于缓冲池中。
				- 未命中：请求的数据不在缓冲池中，需要从磁盘读取。
		- InnoDB LRU 列表的特有结构
		  heading:: true
			- InnoDB 并非采用纯粹的 LRU 算法，而是使用了一种针对数据库特性优化的 LRU 变体。
			- 整个 LRU 链表在逻辑上被划分为两个子列表：
				- New 子列表：位于整个 LRU 列表的头部，存放最近频繁访问的页面。
				- Old 子列表：位于整个 LRU 列表的尾部，存放最近较少访问的页面。
			- 中点（Midpoint）：New 子列表和 Old 子列表之间的分界位置。
			- 子列表比例：默认情况下，Old 子列表约占整个缓冲池大小的 37%，New 子列表约占 63%。
		- InnoDB LRU 列表中的页面流动规则
		  heading:: true
			- 当页面首次从磁盘加载至缓冲池时，无论是通过用户查询还是预读机制，它都会被置于 Old 子列表的头部（即中点位置）。
			- 如果一个页面位于 Old 子列表中，当其被再次访问时，并不会立即被提升到 New 子列表的头部。InnoDB 会判断该页面是否“足够热”：只有当页面在 Old 子列表中停留超过一定时间（由 `innodb_old_blocks_time` 参数定义）并再次被访问时，它才会被移动到 New 子列表的头部。这个门槛是为了防止因偶然的少量访问就将页面移入 New 区，从而有效保护 New 区的热点数据。
			- 对于已存在于 New 子列表中的页面，当其再次被访问时，通常会被移至 New 子列表更靠近头部的位置，以反映其持续的“热度”。
			- 当缓冲池已满需要腾出空间时，位于 Old 子列表最尾端的页面最先被淘汰。
		- 中点插入策略
		  heading:: true
			- 缓冲池污染问题：
				- 传统的简单 LRU 算法在应对大规模表扫描（如 `mysqldump` 或不带 `WHERE` 条件的 `SELECT`）时效果较差。此类扫描会一次性加载大量页面，这些页面往往只被访问一次，却迅速占满缓冲池，将真正频繁访问的“热”数据页挤出，导致缓存命中率急剧下降，这种现象被称为“缓冲池污染”。
			- 解决方案：
				- 为缓解上述问题，InnoDB 引入了中点插入策略：将新加载的数据页优先插入到缓冲池的 Old 子列表中。由于这些页面通常不会被重复访问，它们难以满足“年轻化”条件而晋升到 New 子列表，因此会较快从 Old 子列表尾部被淘汰。这样，New 子列表中的热点数据页得以保留，避免被一次性扫描数据所淘汰，从而有效提升缓冲池的命中率。
	- 空闲列表（Free List）
	  heading:: true
		- 帧
		  heading:: true
			- 缓冲池在物理结构上被划分为一系列大小相等的内存块，每一个这样的块称为一个“帧”。每个帧的大小恰好可以容纳一个完整的数据页，因此帧是缓冲池中存放数据页的基本物理单位。
		- 有什么用？
		  heading:: true
			- 空闲列表是一种用于管理缓冲池中未被占用帧的数据结构。它的核心作用是跟踪所有当前可用的帧。可以将其形象地比喻为一张动态更新的“空车位清单”，清楚地记录了缓冲池中哪些帧尚未被使用。
			- **快速定位可用帧：**当数据库系统需要从磁盘加载一个新的数据页到缓冲池中时，必须先找到一个空闲的帧来存放该页。空闲列表提供了一种高效的方式来定位这些可用帧，避免了对整个缓冲池的遍历检查。倘若没有空闲列表，系统只能逐个检查所有帧的使用状态，这不仅低效，也会导致性能显著下降。空闲列表的存在极大地降低了这种操作的开销。
		- 工作流程
		  heading:: true
			- 当某个数据页不在缓冲池中（即发生缓存未命中），InnoDB 会发起磁盘 I/O 请求读取该页面，并尝试从空闲列表中获取一个可用帧，用于存放从磁盘加载的数据。
			- 若空闲列表中存在可用帧，系统会从中取出一个帧，将其用于存储数据页，并将其从空闲列表中移除，标记为“已使用”。
			- 若空闲列表为空，表示缓冲池已满。此时，InnoDB 会从 LRU 列表的尾部（即 Old 子列表的末端）选择一个或多个页面进行淘汰，从而释放出帧。这些被释放的帧即可用于存放新的数据页。
	- 刷新列表（Flush List）
	  heading:: true
		- 当缓冲池中的数据页因 `INSERT`、`UPDATE` 或 `DELETE` 操作被修改后，就会变成脏页（Dirty Page），也就是内存中的版本比磁盘上的新，这些脏页最终必须被刷新（Flush）到磁盘上的数据文件中。
		- 刷新列表记录了所有已被修改但尚未写回磁盘的页面，这些脏页就是刷新操作的目标。
		- 脏页的刷新时机
		  heading:: true
			- **Redo Log 即将写满或需复用时：**
				- InnoDB 遵循预写日志（Write-Ahead Logging, WAL）策略，即数据变更会优先记录到 Redo Log。由于 Redo Log 的物理空间有限，当其剩余空间不足或需要被循环覆盖写入新的日志记录时，系统必须确保这些即将被覆盖的 Redo Log 所对应的所有脏页都已成功刷新到磁盘。这样做是为了保证数据的一致性和 Redo Log 空间的安全重用。
			- **Buffer Pool 空间不足时：**
				- 当 Buffer Pool 需要为新读取的数据页腾出空间，进而需要淘汰一些现有的数据页时，如果被选中的淘汰对象恰好是脏页，那么该脏页必须先被刷新到磁盘，然后才能从 Buffer Pool 中移除，以防数据丢失。
			- **数据库正常关闭前：**
				- 为了确保所有在内存中所做的未持久化修改都能完整保存，在数据库服务接收到正常关闭指令并执行关闭流程时，InnoDB 会将 Buffer Pool 中的全部脏页都刷新到磁盘。
			- **系统空闲时：**
				- 在系统负载较低的空闲期，InnoDB 会在后台异步刷新脏页。此举旨在分散高并发时可能集中的磁盘写入压力来避免性能瓶颈，从而减少用户请求的延迟或卡顿。
		- 刷新完成后，这些页面被标记为干净页（Clean Page），同时从刷新列表中移除。
		- 页清理线程
		  heading:: true
			- InnoDB 使用专门的页清理线程在后台执行脏页的刷新写回。
			- 可通过 `innodb_page_cleaners` 参数调整清理线程数量，增加线程数可以提高脏页的刷新吞吐量，避免刷新操作成为性能瓶颈。
- 预读
  heading:: true
	- 想象你在图书馆看书。如果每看完一页就得去找管理员申请下一页，阅读效率将非常低。而如果你正在看第10 页时，管理员猜测你很快会看第 11、12、13 页，并提前将这些页放在你桌上，你便能顺畅地继续阅读。
	- 预读（Read-Ahead）是数据库管理系统（DBMS）中的一种磁盘 I/O 优化技术。其核心思想是：当系统发现数据访问存在“顺序性”或“局部性”时，会在数据被明确请求之前，主动将可能即将被访问的数据页提前加载到内存中，以减少磁盘 I/O 等待，提高整体性能。
	- **线性预读（Linear Read-Ahead）：**
		- 当 InnoDB 检测到某个区中的数据页正在被顺序访问，并且顺序访问的页数达到预设阈值（由参数 `innodb_read_ahead_threshold` 控制，默认值通常为 56），系统会判断这是一次可能的“顺序扫描”。此时，将触发预读机制，异步地将后续相邻的数据页（通常是整个区，或更多相关页）加载到缓冲池中，为后续访问做好准备。
	- **预读失效：**
		- 当预测错误时，预先加载的页面未被实际访问，导致预读失效。这些无效页面占用了缓冲池空间，造成内存资源浪费；若缓冲池空间紧张，甚至可能将真正有用的数据页淘汰，从而对系统性能产生负面影响。
		- 合理配置 `innodb_read_ahead_threshold`，避免太容易触发预读。
-