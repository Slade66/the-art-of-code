-
- ## Description
	- **题目链接：**https://leetcode.cn/problems/reordered-power-of-2/
	- **题目截图：**
		- ![869. Reordered Power of 2.png](../assets/869._Reordered_Power_of_2_1754813756856_0.png)
	- **题目意思：**
		- 判断一个数字 `n`，是否可以通过重新排列其数字得到一个 `2` 的幂（`2` 的某次方）。
			- 如果 `n = 46`：
				- 它的数字是 `4` 和 `6`。
				- 重新排列可以得到 `46` 和 `64`。
				- 因为 `64` 是 `2` 的 `6` 次方，所以对于 `n = 46`，答案是 `true`。
			- 如果 `n = 10`：
				- 它的数字是 `1` 和 `0`。
				- 重新排列可以得到 `10` 和 `01`。
				- `01` 因为有前导零，所以不是一个有效的数，我们只考虑 `10`。
				- `10` 不是 2 的幂。所以答案是 `false`。
		- 重新排列数字时，只能改变数字的位置，不能添加或删除数字，并且排序后的数字不能以 0 开头。
		- 如果排列后的数字是 2 的幂，则返回 `true`，否则返回 `false`。
- ## Wrong Approach
	- 如果直接排列 `n` 的各个数字，复杂度会非常高。以 `10` 位数为例，其全排列数量可达 `10! = 362,8800`，且每个排列都需判断是否为 `2` 的幂，效率极低，必然超时。
- ## Solution A
	- ### Algorithm
		- #### Principle
			- 如果两个数 `A` 和 `B` 的数字可以互相重新排列得到对方，那么它们必须满足一个充要条件：`A` 和 `B` 由完全相同的数字组成。换句话说，它们每个数字出现的次数必须一致。
			- 我们可以为一个数创建一个“数字指纹”，即记录 `0-9` 各个数字出现次数的计数器。如果两个数的数字指纹相同，那么它们就可以通过重新排序转换成对方。
			- 基于这个核心原理，问题从“将 `n` 重新排序，能否得到一个 `2` 的幂？”转变为“是否存在一个 `2` 的幂，它的数字指纹与 `n` 的数字指纹完全相同？”
			- 因此，我们不再需要对 `n` 进行全排列，而是遍历所有可能的 `2` 的幂，计算它们的数字指纹，并构成一个指纹集合，然后检查 `n` 是否能与该集合中的某个指纹匹配。
		- #### Steps
			- 先计算出输入 `n` 的数字指纹。
			  logseq.order-list-type:: number
			- 然后检查数据范围内是否存在一个 2 的幂，其数字指纹与 `n` 完全相同。
			  logseq.order-list-type:: number
	- ### Code
		- ```go
		  func reorderedPowerOf2(n int) bool {
		  	targetCounts := *countDigits(n)
		  	for p := 1; p <= 1_000_000_000; p <<= 1 {
		  		if targetCounts == *countDigits(p) {
		  			return true
		  		}
		  	}
		  	return false
		  }
		  
		  func countDigits(n int) *[10]int {
		  	var count [10]int
		  	n_str := strconv.Itoa(n)
		  	for _, c := range n_str {
		  		count[c-'0']++
		  	}
		  	return &count
		  }
		  ```
-