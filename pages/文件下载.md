-
- 平时我们用浏览器访问网页、查看图片，本质上也是在获取并下载资源。不同之处在于，文件下载会通过特定的方式告诉浏览器，不要直接展示资源，而是将其保存到用户的电脑上。
- ## HTTP Headers
	- 实现文件下载的关键在于后端返回的 HTTP 响应头，浏览器会根据这些头信息决定如何处理数据。其中最重要的两个是 `Content-Type` 和 `Content-Disposition`。
	- #### `Content-Disposition`
		- **作用：**该响应头告诉浏览器如何处理响应体，这是由 HTTP 标准定义的触发“下载”行为的核心。
		- **参数：**
			- `inline`：默认值，表示浏览器会尝试直接在页面中展示内容。例如图片、HTML 页面、PDF 文件。
			- `attachment`：强制浏览器弹出“另存为...”对话框，提示用户将响应内容保存为文件。为了让下载的文件有一个默认文件名，通常会在后面附加 `filename` 参数。
		- **示例：**
			- `Content-Disposition: attachment; filename="server-log-2025-08-18.log"`
			- 当浏览器收到这个头时，就会下载一个名为 `server-log-2025-08-18.log` 的文件。
	- #### `Content-Type`
		- **作用：**该响应头用于告诉客户端（通常是浏览器），响应体中的数据是什么类型，以便客户端能够正确地处理这些数据。
		- **举例：**浏览器看到 `text/html` 就会把内容渲染成网页；遇到 `image/jpeg` 就会显示为图片；如果是 `application/pdf`，则会尝试调用 PDF 阅读器插件。
		- **文本类型：**
			- `text/plain`，纯文本文档。
			- `text/html`，HTML 文档。
		- **图片类型：**
			- `image/jpeg`，JPEG 图像。
			- `image/png`，PNG 图像。
			- `image/gif`，GIF 图像。
			- `image/webp`，WebP 图像。
		- **音频和视频类型：**
			- `audio/mpeg`，MP3 音频。最常见的音频压缩格式。
			- `video/mp4`，MP4 视频。当前 Web 视频的事实标准。
			- `video/webm`，WebM 视频。由 Google 赞助的开放、免费的视频格式，专为 Web 设计。
		- **应用类型：**
			- 用于表示那些需要特定应用程序或插件来处理的数据，而不是由浏览器直接展示。
			- `application/octet-stream`，字节流。
				- 它本质上是在告诉浏览器：“我传给你的是一段二进制数据，不要尝试解析或展示它，就把它当作一个文件，完整地接收保存即可。”
				- 浏览器无法确定数据的具体类型，也就不知道如何打开，因此会默认将数据下载下来，由用户自行选择合适的软件去打开它。
				- 这个响应头可以强制浏览器下载文件，而不是预览。
			- `application/json`，JSON 数据格式。
	- #### 为什么 `Content-Disposition: attachment` 要和 `application/octet-stream` 一起用？
		- **起到双保险的作用：**`Content-Disposition` 明确发出了下载指令，而 `application/octet-stream` 则确保即使在某些极端情况下浏览器忽略了前者，也会因无法识别内容而倾向于执行下载操作。
- ## 下载的实现方式
	- **方式一：前端直接链接**
		- 如果要下载的文件存放在服务器的某个静态资源目录下，可以直接用 `<a>` 标签实现。
		- ```html
		  <a href="/logs/server-log-2025-08-18.log" download="my-custom-log-name.log">点击下载日志</a>
		  ```
		- `href`：指向文件的 URL。
		- `download` 属性有两个作用：
			- 强制浏览器下载链接指向的文件，即使它是浏览器可预览的类型（如 `.txt`、`.jpg`）。
			- `download` 属性的值可作为下载时的建议文件名；若省略，则使用原始文件名。
	- **方式二：后端接口驱动**
		- 前端请求一个 API 接口，后端读取文件内容并将其作为响应体返回。
		- **流程：**
			- **前端**：向后端发起下载请求。
			- **后端**：
				- 接收请求并解析参数。
				- 检查当前用户是否有权限下载该文件。
				- 根据参数找到服务器上的物理文件路径。
				- 读取文件内容。
				- 设置 HTTP 响应头。
				- 将文件内容写入 HTTP 响应体。
				- 发送响应给前端。
			- **前端：**接收到响应后，发现 `Content-Disposition: attachment`，于是弹出下载对话框。
- ## 高级下载技术
	- #### 处理大文件：流式传输
		- 如果文件非常大（如几百 MB 或几个 GB），一次性全部读入内存再发送，会导致：
			- **性能急剧下降**：服务器内存飙升，操作系统可能频繁使用虚拟内存（硬盘交换），使服务器响应变得极慢。
			- **应用崩溃**：更常见的情况是，应用程序因内存溢出而被操作系统强制终止。
		- **正确做法是使用“流式传输”**：不一次性将整个文件读入内存，而是创建一个数据“管道”，从数据源（文件）持续地、一小块一小块地读取数据，并立即写入 HTTP 响应然后发回，直到文件全部读取完成。
		- **流式传输的好处：**
			- **极低的内存占用：**服务器在任何时刻只需占用少量内存，使得处理超大文件成为可能。
			- **更快的响应时间：**用户几乎可以立即开始接收数据并看到下载开始，因为服务器无需等待整个文件读完再发送，这大大提升了用户体验。
			- **支持处理未知大小或动态生成的内容：**流式传输可以边生成数据边发送，无需在内存中构造完整文件，非常适合传输无法提前确定总大小的动态内容。
	- **提升用户体验：进度条与断点续传**
		- **进度条：**
			- 下载大文件时，用户希望看到下载进度。后端需在响应头中提供 `Content-Length`，即文件总字节数。
			- 浏览器拿到这个值后，可根据已接收的数据量计算下载进度。
		- **断点续传：**
			- 如果下载中断，用户希望从断点继续，而不是重新开始。
			- **流程：**
				- 服务器在响应头加入 `Accept-Ranges: bytes`，表示支持范围请求。
				- 客户端在后续请求头中可加入 `Range: bytes=5000-`，表示请求从第 5000 字节开始的数据。
				- 服务器返回 `206 Partial Content` 状态码，并在响应头中加入 `Content-Range: bytes 5000-10000/10000`，表示本次返回第 5000 到 10000 字节的数据，文件总大小为 10000 字节。
	- #### 性能优化
		- **压缩**：对于文本类文件，可在传输前进行 Gzip 压缩。通过设置 `Content-Encoding: gzip` 响应头，可显著减小传输体积，加快下载速度，浏览器会自动解压。
		- **使用 `X-Sendfile` / `X-Accel-Redirect`**：应用逻辑（如 Go 程序）只负责权限校验和设置响应头，然后通过特殊响应头（如 Nginx 的 `X-Accel-Redirect`）告知 Web 服务器，由服务器负责读取文件并发送给用户。这样可以将繁重的 I/O 操作从应用中剥离，使应用能够更快地处理其它请求。
	- **安全性：**
		- **权限控制：**必须确保只有授权用户才能下载敏感文件。
		- **路径遍历攻击：**
			- 绝对不要直接使用用户输入拼接文件路径，否则攻击者可以下载到服务器上的敏感文件。
			- **正确做法**：严格清洗和校验用户输入，确保文件名不包含 `..`、`/` 等特殊字符，或者将用户输入映射到安全的预定义文件列表中。
-