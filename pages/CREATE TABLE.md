- **外键行为：**
	-
- **字符集：**
	- 字符集的选择直接影响数据的存储空间和多语言支持能力。选择正确的字符集是迈向全球化的基石。
	- **utf8mb3 vs utf8mb4**
		- MySQL 中的 `utf8` 实际上是指 `utf8mb3`，它最多使用 3 个字节存储一个字符。这已经能覆盖世界上绝大多数常用字符，但无法容纳补充字符。典型例子是 Emoji（如 🐬）以及部分生僻汉字，这些字符需要 4 个字节才能表示。
		- `utf8mb4` 是真正的 UTF-8 实现，支持 4 字节字符，世界各地的文字都能正确表示，Emoji 不会变成乱码，是现代 Web 开发里通用、默认、最被广泛接受的编码标准。对于 ASCII 字符（如英文、数字），`utf8mb4` 和 `utf8mb3` 一样只占用 1 个字节。
		- **结论：**`utf8`（实为 `utf8mb3`）已不再适应现代需求，请使用 `utf8mb4`。
- **排序规则：**
	- 排序规则决定了字符的比较和排序方式。
	- `utf8mb4_general_ci`：较早期的默认值，比较时做了简化处理（例如把某些不同字符视作相同）。速度快，但准确性一般。
	- `utf8mb4_unicode_ci`：基于 Unicode 标准，排序更精确（例如能正确区分和处理德语 ß 等字符），但性能稍逊。
	- `utf8mb4_0900_ai_ci`：MySQL 8.0 的默认值，基于 Unicode 9.0。`ai` 表示不区分重音，`ci` 表示不区分大小写。利用了新的 CPU 指令优化，兼具高性能与高准确度，是目前建表时的最佳选择。
	- **结论：**所有新表应强制指定 `CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci`。
- ## 关系
	- **一对一关系：**
		- 通常用于将大表拆分或隔离敏感数据。
		- 实现方式是在任意一方（通常是访问频率较低的一方）添加外键指向另一方的主键，并对该外键设置唯一约束（UNIQUE Constraint）。
	- **一对多关系：**
		- 外键放置在多的一方。
			- 例如，一个部门（One）有多个员工（Many），则在"员工"表中添加"部门ID"作为外键。
	- **多对多关系：**
		- MySQL 不支持直接的多对多存储，必须引入关联表（Junction Table / Association Table）来分解关系。
		- 例如，"学生"和"课程"是多对多关系。
			- 我们需要创建一个名为 `student_courses` 的中间表：
				- ```sql
				  CREATE TABLE student_courses (
				      student_id INT NOT NULL,
				      course_id INT NOT NULL,
				      enrollment_date DATETIME DEFAULT CURRENT_TIMESTAMP,
				      PRIMARY KEY (student_id, course_id),
				      FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
				      FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE
				  ) ENGINE=InnoDB;
				  ```
			- 在此模型中，`student_courses` 表不仅解耦了多对多关系，还承载了关系本身的属性（如 `enrollment_date`）。
			- **关键索引策略：**在关联表中，联合主键 `(student_id, course_id)` 自然地为基于 `student_id` 的查询提供了索引。然而，为了高效地查询"某课程的所有学生"，必须为 `course_id` 单独创建索引或创建反向的联合索引 `(course_id, student_id)`。这是新手常犯的错误，导致反向查询全表扫描。
- ## 数据类型
	- **整数类型：**
		- | 类型      | 字节数 | 有符号范围              | 无符号 (UNSIGNED) 范围      |
		  |-----------|--------|--------------------------|------------------------------|
		  | TINYINT   | 1      | -128 ~ 127               | 0 ~ 255                      |
		  | SMALLINT  | 2      | -32,768 ~ 32,767         | 0 ~ 65,535                   |
		  | MEDIUMINT | 3      | -8.3M ~ 8.3M             | 0 ~ 16.7M                    |
		  | INT       | 4      | -21亿 ~ 21亿             | 0 ~ 42亿                     |
		  | BIGINT    | 8      | -9.22E18 ~ 9.22E18       | 0 ~ 1.84E19                  |
	- **定点数与浮点数：**
		- | 类型            | 特点                                         | 说明与示例                                                       | 适用场景                          |
		  |-----------------|----------------------------------------------|------------------------------------------------------------------|-----------------------------------|
		  | DECIMAL(M, D)   | 存储精确值                                   | 以字符串形式编码；如 DECIMAL(10,2) 可表示 99999999.99           | 金融、计费，任何需要绝对精度的场景 |
		  | FLOAT / DOUBLE  | 存储近似值，计算速度快                       | 可能出现精度误差，如 0.1 + 0.2 ≠ 0.3                            | 科学计算、对精度不敏感的业务       |
	- **字符串：**
		- **`CHAR(N)`：**定长字符串。如果内容长度固定（如 MD5 哈希、国家代码），`CHAR` 性能更好，且不容易产生内存碎片。
		- **`VARCHAR(N)`：**变长字符串。存储时会额外使用 1-2 个字节记录长度。对于长度波动大的数据（如名字、地址），它比 `CHAR` 更节省空间。但频繁更新导致长度变化时，可能引起页分裂。
		- **`TEXT` 系列：**`TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`。用于存储大文本。关键区别在于 `TEXT` 列通常存储在页外（Off-page storage），主索引中只保留指针。
			- 查询时应避免 `SELECT *` 包含不必要的 `TEXT` 列，以免引发大量的磁盘随机 I/O。
	- **日期时间：**
		- **`DATETIME`：**存储绝对的日期时间（1000-9999年）。它不包含时区信息，存什么取什么。占用 5 字节（MySQL 5.6+）。
		- **`TIMESTAMP`：**存储自 1970-01-01 UTC 以来的秒数（4 字节）。它具有时区感知能力：存入时由当前时区转为 UTC，取出时转回当前时区。
			- **2038 年问题：**标准 `TIMESTAMP` 将在 2038 年溢出。对于长期业务数据，推荐使用 `DATETIME` 或 `BIGINT`（存储毫秒时间戳）以规避此风险。
	- **JSON：**
		- **二进制存储：**JSON 数据不是作为文本字符串存储，而是被解析为优化的二进制格式（JDOM）。这使得读取子节点（如 `doc->"$.key"`）时无需解析整个文档，性能极高。
- ## 命名规范
	- **Snake Case：**推荐使用下划线分隔的小写字母（如 `user_orders`），避免使用 CamelCase。
	- **复数 vs 单数：**在 ORM 映射中，表名通常建议使用复数（`users`），代表记录的集合；而类名使用单数（`User`）。
	- **索引的名字应该能看出用途：**普通索引用 `idx_列名`，唯一索引用 `uq_列名`，外键则采用 `fk_子表_父表` 这样的前缀，方便识别和维护。
-