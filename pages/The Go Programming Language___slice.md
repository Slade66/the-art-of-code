- **基本概念：**
	- 切片本身不存储数据，底层数组才存储数据，切片是一个描述底层数组部分内容的结构体。你可以把它看作是聚焦数组某一部分内容的“窗口”或“视图”。
- **切片是底层数组的视图：**
	- 切片本质上是对底层数组的一种视图，它们共享相同的底层存储。
	- 因此，无论是通过切片修改元素，还是直接修改底层数组，这些更改都会相互反映。
	- **修改行为的影响：**
		- **修改切片中的元素**：会直接更改底层数组中对应的值。
		- **修改底层数组的元素**：会同步反映在所有基于该数组创建的切片中。
		- **多个切片共享数组：**如果多个切片引用了同一个底层数组，任何一个切片的更改都会影响其他切片看到的内容。
- **切片的本质**
	- 切片本质上是一个包含了指向数组的指针、长度和容量信息的结构体。
	- **切片包含三个字段：**
		- **指针（Pointer）**：指向底层数组中的某个元素。
		- **长度（Length）**：切片中当前包含多少个元素，可通过 `len(s)` 获取。
		- **容量（Capacity）**：从切片起始位置到底层数组末尾，总共能装多少个元素，可通过 `cap(s)` 获取。
- **为什么对 nil 切片取地址是合法的**
	- `var s []int` 会创建一个切片变量 `s`，它的值是：`s = {ptr: nil, len: 0, cap: 0}`。这个变量本身存在，也有自己的内存地址。
	- `&s` 取的是切片变量的地址，不是 nil 的地址。
- **切片运算符：**
	- 切片运算符用于从数组或已有切片中创建新切片。该操作非常轻量，因为不会复制底层数据，而是生成一个新的切片结构，指向原始数据。
	- **语法：`s[low:high]`**
		- **`low`**：起始索引，包含该索引上的元素。
		- **`high`**：结束索引，不包含该索引上的元素。
	- 如果省略左或右索引，默认值分别为 `0` 和 `len(s)`。
- **切片作为函数参数：**
	- Go 的函数参数都是**值传递**。
	- 传入切片时，复制的是包含指针、长度和容量的**切片结构体副本**，而不是底层数组。
	- 函数内外的切片**共享同一底层数组**，修改函数内切片中的元素会影响外面的原切片。
	- **类型灵活性**：函数参数 `[]int` 可以接收**任意长度**的切片。无论底层数组多大，切片的类型始终是 `[]int`。
- **`append`  操作：**
	- `append` 是 Go 的内建函数，用于向切片追加元素，容量不足时还可以动态扩容。
	- **当容量足够时**，`append` 会在原数组中添加元素，并返回一个与原切片共享底层数组的新切片。
	- **当容量不足时**，Go 会：
		- 分配一个更大的新数组；
		- 将旧数组元素复制过去；
		- 在新数组中追加新元素；
		- 返回一个指向新数组的切片。
	- **为什么 append 要返回一个新的切片？**
		- 由于 Go 是**值传递**，`append` 无法直接修改调用者的切片变量。
		- 无论是否扩容，`append` 都会返回一个**新的切片**：
			- 容量足够时：更新 `len`。
			- 容量不足时：更新 `ptr`（指向新数组）。
		- 因此，使用 `append` 时一定要**接收返回值**，否则修改不会反映到原切片上。
	- **为什么 Go 的 `append` 不设计成接收指针？**
		- 虽然让 `append` 接收切片指针（例如 `append(&s, ...)`）可以直接修改原切片、避免写 `s = append(...)`，但 Go 设计者最终选择了 `s = append(s, ...)`，这是一个**经过深思熟虑的设计权衡**。
		- **主要原因：**
			- **可读性与一致性更好**
				- `s = append(s, ...)` 明确地告诉你：`s` 会被更新。
				- 保持了 Go 一贯的“值传递、返回新值”的语义风格，与 `strings.TrimSpace(" hello ")` 等函数的设计一致。
			- **避免指针传入传出模式**
				- `append(&s, ...)` 类似 C/C++ 的“in-out 参数”，可读性差，也违背了 Go 倾向的简单语义。
- **遍历切片：**
	- 可以使用 `range` 迭代切片。`range` 会返回切片中每个元素的索引和值。
	- **示例：**
		- 在这里，我们只关心元素的值（即 `num`），所以用 `_` 忽略了索引。
		- ```go
		  nums := []int{2, 3, 4}
		  sum := 0
		  for _, num := range nums {
		      sum += num
		  }
		  fmt.Println("sum:", sum)
		  ```
- **创建切片的方式：**
	- **从数组或现有切片创建：**
		- ```go
		  arr := [5]int{10, 20, 30, 40, 50}
		  slice := arr[1:3] // 包含元素 20 和 30（索引 1 和 2）
		  ```
		- 这是最能体现切片“视图”特性的方式。
		- 切片通过切片表达式创建，直接引用已有数组或切片的一段数据。
		- 该方式创建的切片与原始数组或切片共享底层存储，相互修改会影响彼此。
	- **使用字面量初始化：**
		- 直接通过字面量创建切片，底层数组由 Go 自动隐式创建并由切片引用。
		- ```go
		  mySlice := []int{1, 2, 3}
		  ```
		- 适合在已知初始元素的情况下快速声明并初始化切片。
	- **使用 `make` 创建切片：**
		- 创建具有指定长度和容量的切片，底层数组由系统分配，默认值为零值。
		- ```go
		  mySlice := make([]int, 3, 5)
		  ```
		- 语法：`make([]T, length, capacity)`
			- `length` 是切片的初始长度；
			- `capacity` 是底层数组的容量（可选，不写时默认等于长度）。
		- 适用于需要预分配空间但暂不初始化所有元素的场景。
	- **声明但不初始化切片：**
		- 只声明切片变量而不进行初始化时，切片的默认值为 `nil`，即不指向任何底层数组。
		- **示例：**
			- ```go
			  var s []string
			  fmt.Println("uninit:", s, s == nil, len(s) == 0)
			  ```
		- **`nil` 切片的状态：**
			- **指针（Pointer）**：`nil` (不指向任何内存地址)
			- **长度（Length）**：`0`
			- **容量（Capacity）**：`0`
		- **`nil` 切片的行为：**
			- 虽然切片为 `nil`，但在大多数情况下，它的行为与空切片类似，且可以安全使用。
			- **获取长度和容量**：`len(mySlice)` 和 `cap(mySlice)` 返回 `0`。
			- **使用 `append` 添加元素**：
				- 对 `nil` 切片执行 `append` 操作是安全的。当 `append` 函数发现操作对象是一个 `nil` 切片时，它会自动在后台分配一个新的底层数组，以容纳新添加的元素。
				- 对于 `append` 操作而言，一个 `nil` 切片和一个通过 `make([]T, 0)` 创建的空切片（长度和容量都为0）的行为是完全一样的。
				- `append` 操作会返回一个新的切片。这个新切片包含了新的元素，其长度和容量都会更新，并且它不再是 `nil`。
			- **用于 `for...range` 遍历**：可以安全地用于循环，因切片为空，循环体不会被执行。
			- **注意**：不能访问任何索引（如 `mySlice[0]`），否则会触发运行时错误，因为切片长度为 0。
		- 这种声明方式简洁明了，无需显式初始化（如 `mySlice = make([]string, 0)`），即可直接传入函数或用于 `append` 操作，无需预先判断是否为 `nil`。
- **切片与数组的扩容机制区别**
	- 扩容的关键在于：**谁来执行扩容动作**。
		- 数组的扩容需要程序员**手动完成**。
		- 切片的扩容由 Go 的运行时（runtime）**自动管理**。
	- **数组的扩容（手动）**
		- 程序员必须自己：
			- 创建一个更大的新数组。
			- 用 `for` 循环把旧数组的元素逐个复制过去。
			- 把新元素插入新数组。
			- 改用新数组变量。
		- **总结**：数组扩容麻烦，完全由程序员手动管理。
	- **切片的扩容（自动）**
		- **场景 A：容量足够**
			- `append` 直接在原底层数组中追加元素，`len` 增加，`cap` 不变。
		- **场景 B：容量不足**
			- 运行时自动分配一个更大的数组。
			- 自动复制旧数据并插入新元素。
			- 返回一个新的切片，`ptr`、`len`、`cap` 都被更新。
		- **总结**：切片扩容完全自动化，`append` 会处理所有底层细节。
-