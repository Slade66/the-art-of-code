- **切片和数组在语法上的不同**
	- 数组类型：`[n]T` (例如 `[6]int`) -> **方括号内有固定的数字 `n`**。
	- 切片类型：`[]T` (例如 `[]int`) -> **方括号内是空的**。
	- 当你看到 `[]int`，你就知道这是一个“`int` 类型的切片”，它的大小是动态的。
	- 当你看到 `[6]int`，你就知道这是一个“`int` 类型的数组”，它的大小永远是 6。
- **切片是底层数组的视图**
	- 切片本身不存储数据，底层数组才是真正存储数据的容器。
	- 切片是一个结构体，它指向底层数组。
	- **比喻：视图**
		- 把底层数组想象成一条非常长的胶卷。
		- 一个切片就像一个“取景框”，你用这个框子“框选”了胶卷上的几格画面。
		- 你可以移动这个“取景框”（创建新的切片），或者（通过 `append`）让这个框子变大。
	- **多个切片共享数组：**如果多个切片引用了同一个底层数组，任何一个切片的更改都会影响其他切片看到的内容。
- **切片的本质**
	- 切片本质上是一个包含了指向数组的指针、长度和容量信息的结构体。
	- **切片包含三个字段：**
		- **指针（Pointer）**：指向底层数组中的某个元素。
		- **长度（Length）**：切片中当前包含多少个元素，可通过 `len(s)` 获取。
		- **容量（Capacity）**：从切片起始位置到底层数组末尾，总共能装多少个元素，可通过 `cap(s)` 获取。
- **为什么对 nil 切片取地址是合法的**
	- `var s []int` 会创建一个切片变量 `s`，它的值是：`s = {ptr: nil, len: 0, cap: 0}`。这个变量本身存在，也有自己的内存地址。
	- `&s` 取的是切片变量的地址，不是 nil 的地址。
- **切片运算符：**
	- 切片运算符用于从数组或切片中创建新切片。该操作非常轻量，因为不会复制底层数据，而是生成一个新的切片结构，指向原始数据。
	- **语法：`s[low:high]`**
		- **`low`**：起始索引，包含该索引上的元素。
		- **`high`**：结束索引，不包含该索引上的元素。
	- 如果省略左或右索引，则左右的默认值分别为 `0` 和 `len(s)`。
	- **示例：**
		- ```go
		  package main
		  
		  import "fmt"
		  
		  func main() {
		      // 6: 'primes' 是一个 [6]int 类型的 *数组*。
		      //    它是我们用来 "切片" 的原始数据。
		      //    索引: 0  1  2  3   4   5
		      //    值:   2, 3, 5, 7, 11, 13
		      primes := [6]int{2, 3, 5, 7, 11, 13}
		  
		      // 8: 关键行！
		      //    var s []int: 声明一个 []int 类型的 *切片* 's'
		      //    primes[1:4]: 执行 "切片" 操作
		      //    - low = 1: 包含 primes[1]，值是 3
		      //    - high = 4: 不包含 primes[4]
		      //    - 它取了索引 1, 2, 3 的元素
		      //    - 对应的值是 3, 5, 7
		      //
		      //    's' 现在是一个指向 'primes' 数组的 "视图"
		      //    s.ptr 指向 primes[1]
		      //    s.len = 3 (即 4-1)
		      //    s.cap = 5 (即 6-1，从 ptr 到数组末尾的容量，这个文档后面会讲)
		      var s []int = primes[1:4]
		  
		      // 9: 打印切片 's'
		      //    输出: [3 5 7]
		      fmt.Println(s)
		  }
		  ```
- **切片作为函数参数：**
	- Go 的函数参数都是**值传递**。
	- 传入切片时，复制的是包含指针、长度和容量的**切片结构体副本**，而不是底层数组。
	- 函数内外的切片**共享同一底层数组**，修改函数内切片中的元素会影响外面的原切片。
	- **类型灵活性**：函数参数 `[]int` 可以接收**任意长度**的切片。无论底层数组多大，切片的类型始终是 `[]int`。
- **`append`  操作：**
	- `append` 是 Go 的内建函数，用于向切片追加元素，容量不足时还可以动态扩容。
	- **当容量足够时**，`append` 会在原数组中添加元素，并返回一个与原切片共享底层数组的新切片。
	- **当容量不足时**，Go 会：
		- 分配一个更大的新数组；
		- 将旧数组元素复制过去；
		- 在新数组中追加新元素；
		- 返回一个指向新数组的切片。
	- **为什么 append 要返回一个新的切片？**
		- 由于 Go 是**值传递**，`append` 无法直接修改调用者的切片变量。
		- 无论是否扩容，`append` 都会返回一个**新的切片**：
			- 容量足够时：更新 `len`。
			- 容量不足时：更新 `ptr`（指向新数组）。
		- 因此，使用 `append` 时一定要**接收返回值**，否则修改不会反映到原切片上。
	- **为什么 Go 的 `append` 不设计成接收指针？**
		- 虽然让 `append` 接收切片指针（例如 `append(&s, ...)`）可以直接修改原切片、避免写 `s = append(...)`，但 Go 设计者最终选择了 `s = append(s, ...)`，这是一个**经过深思熟虑的设计权衡**。
		- **主要原因：**
			- **可读性与一致性更好**
				- `s = append(s, ...)` 明确地告诉你：`s` 会被更新。
				- 保持了 Go 一贯的“值传递、返回新值”的语义风格，与 `strings.TrimSpace(" hello ")` 等函数的设计一致。
			- **避免指针传入传出模式**
				- `append(&s, ...)` 类似 C/C++ 的“in-out 参数”，可读性差，也违背了 Go 倾向的简单语义。
- **遍历切片：**
	- 可以使用 `range` 迭代切片。`range` 会返回切片中每个元素的索引和值。
	- **示例：**
		- 在这里，我们只关心元素的值（即 `num`），所以用 `_` 忽略了索引。
		- ```go
		  nums := []int{2, 3, 4}
		  sum := 0
		  for _, num := range nums {
		      sum += num
		  }
		  fmt.Println("sum:", sum)
		  ```
- **创建切片的方式：**
	- **从数组或现有切片创建：**
		- ```go
		  arr := [5]int{10, 20, 30, 40, 50}
		  slice := arr[1:3] // 包含元素 20 和 30（索引 1 和 2）
		  ```
		- 切片通过切片表达式创建，直接引用已有数组或切片的一段数据。
		- 该方式创建的切片与原始数组或切片共享底层存储，相互修改会影响彼此。
	- **使用字面量初始化：**
		- 直接通过字面量创建切片，底层数组由 Go 自动隐式创建并由切片引用。
		- ```go
		  mySlice := []int{1, 2, 3}
		  ```
		- 适合在已知初始元素的情况下快速声明并初始化切片。
	- **使用 `make` 创建切片：**
		- 创建具有指定长度和容量的切片，底层数组由系统分配，默认值为零值。
		- ```go
		  mySlice := make([]int, 3, 5)
		  ```
		- 语法：`make([]T, length, capacity)`
			- `length` 是切片的初始长度；
			- `capacity` 是底层数组的容量（可选，不写时默认等于长度）。
		- 适用于需要预分配空间但暂不初始化所有元素的场景。
	- **声明但不初始化切片：**
		- **示例：**
			- ```go
			  package main
			  
			  import "fmt"
			  
			  func main() {
			  	var s []string
			  	fmt.Println(s, s == nil, len(s) == 0)
			  }
			  
			  // [] true true
			  ```
		- **未初始化的切片的状态：**
			- **指针（Pointer）**：`nil` (不指向任何内存地址)
			- **长度（Length）**：`0`
			- **容量（Capacity）**：`0`
		- **`nil` 切片的行为：**
			- 虽然切片为 `nil`，但在大多数情况下，**它的行为与空切片类似，且可以安全使用**。
			- **获取长度和容量**：`len(mySlice)` 和 `cap(mySlice)` 返回 `0`。
			- **使用 `append` 添加元素**：
				- 对 `nil` 切片执行 `append` 操作是安全的。当 `append` 函数发现操作对象是一个 `nil` 切片时，它会自动在后台分配一个新的底层数组，以容纳新添加的元素。
				- 对于 `append` 操作而言，一个 `nil` 切片和一个通过 `make([]T, 0)` 创建的空切片（长度和容量都为0）的行为是完全一样的。
				- `append` 操作会返回一个新的切片。这个新切片包含了新的元素，其长度和容量都会更新，并且它不再是 `nil`。
			- **用于 `for...range` 遍历**：可以安全地用于循环，因切片为空，循环体不会被执行。
			- **注意**：不能访问任何索引（如 `mySlice[0]`），否则会触发运行时错误，因为切片长度为 0。
			- 这种声明方式简洁明了，无需显式初始化（如 `mySlice = make([]string, 0)`），即可直接传入函数或用于 `append` 操作，无需预先判断是否为 `nil`。
- **切片与数组的扩容机制区别**
	- 扩容的关键在于：**谁来执行扩容动作**。
		- 数组的扩容需要程序员**手动完成**。
		- 切片的扩容由 Go 的运行时（runtime）**自动管理**。
	- **数组的扩容（手动）**
		- 程序员必须自己：
			- 创建一个更大的新数组。
			- 用 `for` 循环把旧数组的元素逐个复制过去。
			- 把新元素插入新数组。
			- 改用新数组变量。
		- **总结**：数组扩容麻烦，完全由程序员手动管理。
	- **切片的扩容（自动）**
		- **场景 A：容量足够**
			- `append` 直接在原底层数组中追加元素，`len` 增加，`cap` 不变。
		- **场景 B：容量不足**
			- 运行时自动分配一个更大的数组。
			- 自动复制旧数据并插入新元素。
			- 返回一个新的切片，`ptr`、`len`、`cap` 都被更新。
		- **总结**：切片扩容完全自动化，`append` 会处理所有底层细节。
-