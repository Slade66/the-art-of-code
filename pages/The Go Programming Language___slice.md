- **基本概念：**
	- 切片（slice）是 Go 中一种动态大小的数据结构，可以类比于 Java 中的 `ArrayList`。它建立在数组之上，提供了对底层数组的一个“视图”。
	- 切片本身不存储数据，底层数组才存储数据，切片是一个描述底层数组部分内容的结构体。你可以把它看作是聚焦数组某一部分内容的“窗口”。
- **切片是底层数组的视图：**
	- 切片是引用类型，它指向一个数组的片段。
	- 切片本质上是对底层数组的一种视图，它们共享相同的底层存储。
	- 因此，无论是通过切片修改元素，还是直接修改底层数组，这些更改都会相互反映。
	- **修改行为的影响：**
		- **修改切片中的元素**：会直接更改底层数组中对应的值。
		- **修改底层数组的元素**：会同步反映在所有基于该数组创建的切片中。
		- **多个切片共享数组：**如果多个切片引用了同一个底层数组，任何一个切片的更改都会影响其他切片看到的内容。
- **每个切片包含三个字段：**
	- **指针（Pointer）**：指向底层数组中切片第一个元素的位置。
	- **长度（Length）**：切片中当前元素的个数，可通过 `len(s)` 获取。
	- **容量（Capacity）**：从切片起始位置到底层数组末尾的元素数量，可通过 `cap(s)` 获取。
- **切片运算符：**
	- 切片运算符用于从数组或已有切片中创建新切片。该操作非常轻量，因为不会复制底层数据，而是生成一个新的切片结构，指向原始数据。
	- **语法：`s[low:high]`**
		- **`low`**：起始索引，包含该索引上的元素。
		- **`high`**：结束索引，不包含该索引上的元素。
	- 如果省略左或右索引，默认值分别为 `0` 和 `len(s)`。
- **切片作为函数参数：**
	- Go 中所有函数参数都是值传递。
	- 对于切片来说，传递的是包含指针、长度和容量的结构体副本。
	- 函数内外的切片指针指向同一底层数组，因此函数中修改切片元素会影响原切片。
	- 如果函数中使用 `append` 导致底层数组扩容，新的切片将指向新分配的数组，原切片不会受到影响。
- **`append`  操作：**
	- `append` 是 Go 的内建函数，用于向切片追加元素。
	- **当容量足够时**，`append` 会在原数组中添加元素，并返回一个与原切片共享底层数组的新切片。
	- **当容量不足时**，Go 会：
		- 分配一个更大的新数组；
		- 将旧数组元素复制过去；
		- 在新数组中追加新元素；
		- 返回一个指向新数组的切片。
	- 因此，必须使用 `s = append(s, ...)` 的形式来接收返回值。
- **切片的复制：**
	- `copy` 函数可以将一个切片的元素复制到另一个切片中。
	- ```go
	  c := make([]string, len(s))
	  copy(c, s)
	  fmt.Println("cpy:", c)
	  ```
- **遍历切片：**
	- 可以使用 `range` 迭代切片。`range` 会返回切片中每个元素的索引和值。
	- **示例：**
		- 在这里，我们只关心元素的值（即 `num`），所以用 `_` 忽略了索引。
		- ```go
		  nums := []int{2, 3, 4}
		  sum := 0
		  for _, num := range nums {
		      sum += num
		  }
		  fmt.Println("sum:", sum)
		  ```
- **创建切片的方式：**
	- **从数组或现有切片创建：**
		- ```go
		  arr := [5]int{10, 20, 30, 40, 50}
		  slice := arr[1:3] // 包含元素 20 和 30（索引 1 和 2）
		  ```
		- 这是最能体现切片“视图”特性的方式。
		- 切片通过切片表达式创建，直接引用已有数组或切片的一段数据。
		- 该方式创建的切片与原始数组或切片共享底层存储，相互修改会影响彼此。
	- **使用字面量初始化：**
		- 直接通过字面量创建切片，底层数组由 Go 自动隐式创建并由切片引用。
		- ```go
		  mySlice := []int{1, 2, 3}
		  ```
		- 适合在已知初始元素的情况下快速声明并初始化切片。
	- **使用 `make` 创建切片：**
		- 创建具有指定长度和容量的切片，底层数组由系统分配，默认值为零值。
		- ```go
		  mySlice := make([]int, 3, 5)
		  ```
		- 语法：`make([]T, length, capacity)`
			- `length` 是切片的初始长度；
			- `capacity` 是底层数组的容量（可选，不写时默认等于长度）。
		- 适用于需要预分配空间但暂不初始化所有元素的场景。
	- **声明但不初始化切片：**
		- 只声明切片变量而不进行初始化时，切片的默认值为 `nil`，即不指向任何底层数组。
		- **示例：**
			- ```go
			  var s []string
			  fmt.Println("uninit:", s, s == nil, len(s) == 0)
			  ```
		- **`nil` 切片的状态：**
			- **指针（Pointer）**：`nil` (不指向任何内存地址)
			- **长度（Length）**：`0`
			- **容量（Capacity）**：`0`
		- **`nil` 切片的行为：**
			- 虽然切片为 `nil`，但在大多数情况下，它的行为与空切片类似，且可以安全使用。
			- **获取长度和容量**：`len(mySlice)` 和 `cap(mySlice)` 返回 `0`。
			- **使用 `append` 添加元素**：
				- 对 `nil` 切片执行 `append` 操作是安全的。当 `append` 函数发现操作对象是一个 `nil` 切片时，它会自动在后台分配一个新的底层数组，以容纳新添加的元素。
				- 对于 `append` 操作而言，一个 `nil` 切片和一个通过 `make([]T, 0)` 创建的空切片（长度和容量都为0）的行为是完全一样的。
				- `append` 操作会返回一个新的切片。这个新切片包含了新的元素，其长度和容量都会更新，并且它不再是 `nil`。
			- **用于 `for...range` 遍历**：可以安全地用于循环，因切片为空，循环体不会被执行。
			- **注意**：不能访问任何索引（如 `mySlice[0]`），否则会触发运行时错误，因为切片长度为 0。
		- 这种声明方式简洁明了，无需显式初始化（如 `mySlice = make([]string, 0)`），即可直接传入函数或用于 `append` 操作，无需预先判断是否为 `nil`。
-