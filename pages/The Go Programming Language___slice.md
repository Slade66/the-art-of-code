- **切片和数组在语法上的不同**
  collapsed:: true
	- 数组类型：`[n]T` (例如 `[6]int`) -> **方括号内有固定的数字 `n`**。
	- 切片类型：`[]T` (例如 `[]int`) -> **方括号内是空的**。
	- 当你看到 `[]int`，你就知道这是一个“`int` 类型的切片”，它的大小是动态的。
	- 当你看到 `[6]int`，你就知道这是一个“`int` 类型的数组”，它的大小永远是 6。
- **切片是底层数组的视图**
  collapsed:: true
	- 切片本身不存储数据，底层数组才是真正存储数据的容器。
	- 切片是一个结构体，它指向底层数组。
	- **比喻：视图**
		- 把底层数组想象成一条非常长的胶卷。
		- 一个切片就像一个“取景框”，你用这个框子“框选”了胶卷上的几格画面。
		- 你可以移动这个“取景框”（创建新的切片），或者（通过 `append`）让这个框子变大。
	- **多个切片共享底层数组：**当你从一个切片复制出多个切片时，它们都引用同一个底层数组，因此修改任意一个切片的元素，都会影响到其他切片的内容。
- **切片的本质**
  collapsed:: true
	- 切片本质上是一个包含了指向底层数组的指针、当前长度和容量信息的结构体。
	- **切片包含三个字段：**
		- **指针（`ptr`）**：指向底层数组中的某个元素的内存地址。
		- **长度（`len`）**：切片中当前包含多少个元素，你的“窗口”现在有多大。可通过 `len(s)` 获取。
		- **容量（`cap`）**：从切片起始位置到底层数组末尾，总共能装多少个元素。你的“窗口”最多能开多大。可通过 `cap(s)` 获取。
- **为什么对 nil 切片取地址是合法的**
  collapsed:: true
	- `var s []int` 会创建一个切片变量 `s`，它的值是：`s = {ptr: nil, len: 0, cap: 0}`。这个变量本身存在，也有自己的内存地址。
	- `&s` 取的是切片变量的地址，不是 nil 的地址。
	- **nil 切片和空切片的区别：**前者没有指向任何数组，后者指向了一个长度为 0 的底层数组。
	- Go 的很多内置函数（如 `len`、`cap` 和 `append`）都可以**安全地**处理 `nil` 切片，你不需要做额外的检查：
	  collapsed:: true
		- ```go
		  package main
		  
		  import "fmt"
		  
		  func main() {
		  	var s []int // s 是 nil
		  	// s := []int{1, 2, 3} // s 不是 nil
		  
		  	fmt.Println(s == nil)   // true
		  	fmt.Println(len(s))     // 0
		  	fmt.Println(cap(s))     // 0
		  	for _, val := range s { // range nil 切片会直接跳过
		  		fmt.Println(val)
		  	}
		  
		  	// 关键：append 可以直接在 nil 切片上工作！
		  	s = append(s, 1) // Go 会自动为你分配一个新数组
		  	fmt.Println(s)   // [1]
		  }
		  
		  输出：
		  true
		  0
		  0
		  [1]
		  ```
- **切片运算符：**
  collapsed:: true
	- 切片运算符用于从数组或切片中创建新切片。该操作非常轻量，因为不会复制底层数据，而是生成一个新的切片结构，指向同一个底层数组。
	- **语法：`s[low:high]`**
		- **`low`**：起始索引，包含该索引上的元素。
		- **`high`**：结束索引，不包含该索引上的元素。
	- **语法默认值：**如果省略左或右索引，则左右的默认值分别为 `0` 和 `len(s)`。
	- **不能超过 `cap`：**切片操作 `s[low:high]` 中的 `high` 可以超过原 `len(s)`，但**绝不能超过 `cap(s)`**（旧切片的容量），否则会立即 `panic` (运行时恐慌)。
	- **切片表达式 `s[low:high]` 的结果：**
		- 新的 `ptr` 指向原来底层数组的 `low` 位置；
		- 新 `len = high - low`；
		- 新 `cap = oldCap - low`（也可以理解为从新 ptr 到底层数组末尾还能用多少元素）。
	- **示例：**
		- ```go
		  package main
		  
		  import "fmt"
		  
		  func main() {
		      // 6: 'primes' 是一个 [6]int 类型的 *数组*。
		      //    它是我们用来 "切片" 的原始数据。
		      //    索引: 0  1  2  3   4   5
		      //    值:   2, 3, 5, 7, 11, 13
		      primes := [6]int{2, 3, 5, 7, 11, 13}
		  
		      // 8: 关键行！
		      //    var s []int: 声明一个 []int 类型的 *切片* 's'
		      //    primes[1:4]: 执行 "切片" 操作
		      //    - low = 1: 包含 primes[1]，值是 3
		      //    - high = 4: 不包含 primes[4]
		      //    - 它取了索引 1, 2, 3 的元素
		      //    - 对应的值是 3, 5, 7
		      //
		      //    's' 现在是一个指向 'primes' 数组的 "视图"
		      //    s.ptr 指向 primes[1]
		      //    s.len = 3 (即 4-1)
		      //    s.cap = 5 (即 6-1，从 ptr 到数组末尾的容量，这个文档后面会讲)
		      var s []int = primes[1:4]
		  
		      // 9: 打印切片 's'
		      //    输出: [3 5 7]
		      fmt.Println(s)
		  }
		  ```
- **切片作为函数参数：**
  collapsed:: true
	- Go 的函数参数都是**值传递**。
	- 传入切片时，复制的是包含指针、长度和容量的**切片结构体副本**，而不是底层数组。这非常快！
	- 函数内外的切片**共享同一底层数组**，修改函数内切片中的元素会影响外面的原切片。
	- **类型灵活性**：函数参数 `[]int` 可以接收**任意长度**的切片。无论底层数组多大，切片的类型始终是 `[]int`。
	- **什么时候用切片的指针接收者？**
	  collapsed:: true
		- 只有当你想让方法直接修改切片本身，才需要用指针。
		- 这样做的效果是：
		  collapsed:: true
			- 方法内部可以修改底层数组；
			- 方法外的切片变量也会被更新。
		- **例子：**
		  collapsed:: true
			- ```go
			  package main
			  
			  import "fmt"
			  
			  type Todo struct {
			  	Title string
			  }
			  
			  type Todos []Todo
			  
			  // 值接收者
			  func (todos Todos) AddValue(t Todo) {
			  	todos = append(todos, t)
			  }
			  
			  // 指针接收者
			  func (todos *Todos) AddPtr(t Todo) {
			  	*todos = append(*todos, t)
			  }
			  
			  func main() {
			  	t := Todos{}
			  
			  	t.AddValue(Todo{Title: "A"}) // 值接收者
			  	fmt.Println("After AddValue:", t)
			  
			  	t.AddPtr(Todo{Title: "B"})   // 指针接收者
			  	fmt.Println("After AddPtr:", t)
			  }
			  
			  ```
			- ```go
			  After AddValue: []
			  After AddPtr: [{B}]
			  
			  ```
			- 值接受者复制切片头给方法，方法内部可以读取并修改切片中的某个元素，但是使长度增加或扩容的操作不会反映到外部的切片。指针接收者不复制切片头，而是直接把切片头的地址传入方法，在方法内部修改的就是外部的原始切片。
			- 外部调用的语法是一样的，Go 会自动帮你做指针取值或取地址的转换：
			  collapsed:: true
				- 如果方法是值接收者，而你用指针调用，Go 会自动取值；
				- 如果方法是指针接收者，而你用值调用，Go 会自动取地址。
			- `t.AddPtr(Todo{Title: "B"})` 这一行一步步拆开看，看看 Go 语言底层到底做了什么：
			  collapsed:: true
				- `AddPtr` 的接收者类型是 `*Todos`，但你传的是 `t`（值类型）。
				- Go 看到这种情况，会**自动取地址**，帮你变成：`(&t).AddPtr(Todo{Title: "B"})`，也就是说，它相当于把 `t` 的地址传进了方法。
				- 方法签名是：`func (todos *Todos) AddPtr(t Todo)`
				- 传入的是切片的指针，现在 `todos` 指向外部变量 `t` 的地址。
				  collapsed:: true
					- ```go
					  todos  --->  t  --->  底层切片结构（ptr, len, cap）
					  ```
				- 当你执行：`*todos = append(*todos, t)`
				  collapsed:: true
					- `*todos` 是解引用操作，获取了 `todos` 指针指向的外部的实际的 `Todos` 结构体（值），拿到外部原始切片；
					  logseq.order-list-type:: number
					  id:: 690ece44-45a9-40e2-a94e-a08008a676cc
					- `append(*todos, t)` 会创建一个新切片（长度从 0 变成 1），返回一个新的切片头（包含指针、长度、容量）；
					  logseq.order-list-type:: number
					- `*todos = ...` 再把这个新切片赋值回原来的变量 `t`，也就是说，这次 `append` 的结果直接回写给了外部变量 `t`，更新了外部变量。
					  logseq.order-list-type:: number
- **`append`  操作：**
  collapsed:: true
	- `append` 是 Go 的内置函数，你无需 `import` 任何包就可以使用它。
	- **扩容机制：**
		- 当你执行 `append` 时，Go 会看容量够不够。
		- **当容量足够时**，底层数组还有空位，所以 `append` 会在原数组末尾添加元素，并返回一个与原切片共享底层数组的新切片。
		- **当容量不足时**，Go 会：
			- 分配一个更大的新数组；
			- 将旧数组元素复制过去；
			- 在新数组中追加新元素；
			- 返回一个指向新数组的切片。
		- 不发生扩容时，这个新切片和旧的共用底层数组，发生扩容时不共用。
	- **为什么 append 要返回一个新的切片？**
		- 由于 Go 是**值传递**，`append` 可能会改变传入切片的 `len`、`cap`，甚至 `ptr`，但它无法直接修改调用者传入（外部）的切片变量，所以必须把这个修改后的切片返回给外部。
		- 无论是否扩容，`append` 都会返回一个**新的切片**：
			- 容量足够时：更新 `len`。
			- 容量不足时：更新 `ptr`（指向新数组）、`len`、`cap`。
		- 因此，使用 `append` 时一定要**接收返回值**，否则修改不会反映到原切片上。
	- **为什么 Go 的 `append` 不设计成接收指针？**
		- 虽然让 `append` 接收切片指针（例如 `append(&s, ...)`）可以直接修改原切片、避免写 `s = append(...)`，但 Go 设计者最终选择了 `s = append(s, ...)`，这是一个**经过深思熟虑的设计权衡**。
		- **主要原因：**
			- **可读性与一致性更好**
				- `s = append(s, ...)` 明确地告诉你：`s` 会被更新。
				- 保持了 Go 一贯的“值传递、返回新值”的语义风格，与 `strings.TrimSpace(" hello ")` 等函数的设计一致。
			- **避免指针传入传出模式**
				- `append(&s, ...)` 类似 C/C++ 的“in-out 参数”，可读性差，也违背了 Go 倾向的简单语义。
	- **代码示例：**
		- ```go
		  package main
		  
		  import "fmt"
		  
		  func main() {
		      // 1. 从一个 nil 切片开始
		      var s []int
		      fmt.Printf("1. 初始: %v\n", s)
		  
		      // 2. 添加单个元素
		      s = append(s, 10)
		      fmt.Printf("2. 添加 10: %v\n", s)
		  
		      // 3. 一次添加多个元素
		      s = append(s, 20, 30)
		      fmt.Printf("3. 添加 20, 30: %v\n", s)
		  
		      // 4. 添加另一个切片 (s2) 的所有元素
		      s2 := []int{40, 50}
		      s = append(s, s2...) // <-- 关键：使用 '...' 将 s2 "解包"
		      
		      fmt.Printf("4. 添加 s2: %v\n", s)
		  }
		  ```
- **遍历切片：**
  collapsed:: true
	- `for i, v := range slice` 是 Go 遍历切片的主要方式，每次循环返回索引 `i` 和值 `v`。
	- **三种用法：**
	  collapsed:: true
		- `for i, v := range s`: 获取**索引**和**值**。
		- `for i := range s`: **只获取索引**。（常用于修改切片 `s[i] = ...`）
		- `for _, v := range s`: **只获取值**。（常用于只读数据）
		- `_` 是“空标识符”，用于丢弃你不需要的变量。
	- **陷阱 1：`v` 是副本 (Copy)**
	  collapsed:: true
		- 循环中的 `v` 只是一个**副本**，修改 `v` **不会**改变原切片。
		- **正确修改：** 必须使用索引 `slice[i] = ...`。
	- **陷阱 2：`for _, v := range s` 循环中 `v` 的地址不变**
	  collapsed:: true
		- 如果你在循环中收集 `v` 的地址，会发现所有指针都指向同一个变量。
		- 在 `for range` 循环中，**`v` 在内存中只有一个实例**。每次迭代只是用新的值覆盖这个 `v`，而不会创建新的变量。
		- 因此，`&v` 每次得到的都是**同一个内存地址**，使用 `append(&v)` 会多次追加相同地址。
		- 正确做法是始终使用切片元素的真实地址 `&s[i]`，而不是临时变量 `v` 的地址。
	- **示例：**
	  collapsed:: true
		- 在这里，我们只关心元素的值（即 `num`），所以用 `_` 忽略了索引。
		- ```go
		  nums := []int{2, 3, 4}
		  sum := 0
		  for _, num := range nums {
		      sum += num
		  }
		  fmt.Println("sum:", sum)
		  ```
- **创建切片的方式：**
  collapsed:: true
	- **从数组或现有切片创建：**
		- ```go
		  arr := [5]int{10, 20, 30, 40, 50}
		  slice := arr[1:3] // 包含元素 20 和 30（索引 1 和 2）
		  ```
		- 切片通过切片表达式创建，直接引用已有数组或切片的一段数据。
		- 该方式创建的切片与原始数组或切片共享底层存储，相互修改会影响彼此。
		- **适用场景：**已有数组或切片。
	- **使用切片字面量初始化：**
		- Go 会在幕后自动帮你做两件事：
			- **创建数组：** Go 编译器会自动在内存中创建一个数组来存储这些数据。
			- **创建切片：** Go 紧接着创建一个**切片**，这个切片**指向**刚刚创建的那个数组。
			- 你最终得到的变量是一个切片，它引用了一个由 Go 自动为你创建和管理的底层数组。
		- **例子：**
			- ```go
			  mySlice := []int{1, 2, 3} // 方括号 [] 里没有指定长度。
			  ```
		- **适用场景：**适合在已知所有数据的情况。
	- **使用 `make` 创建切片：**
		- 创建具有指定长度和容量的切片，底层数组由系统分配，默认值为零值。
		- **适用场景：**`make` 适用于当你不知道切片里要放什么数据，预先分配内存，暂不初始化元素的场景。
		- **工作原理：**`make` 会创建一个隐藏的、填满零值（如 0, false, nil）的底层数组，并返回一个指向它的切片。
		- **两种形式：**
			- **`make([]T, len)` (两参数):**
				- `a := make([]int, 5)` 会创建 `len=5`, **`cap=5`**。
				- 你得到一个包含 `5` 个零值的切片 (`[0 0 0 0 0]`)。
			- **`make([]T, len, cap)` (三参数):**
				- `[]T`：切片的类型
				- `len`：切片初始化时包含的元素数量（所有元素默认为 `0` 或空值）。
				- `cap`：切片底层数组能容纳的最大元素数量。如果省略，容量等于长度。
				- `b := make([]int, 0, 5)` 会创建 `len=0`, `cap=5`。你得到一个空切片 (`[]`)，但它预留了 5 个元素的容量。
				- **用途：** **最常用、性能最佳**的方式。配合 `append` 使用，前 5 次 `append` 不会触发新的内存分配，效率极高。
	- **声明但不初始化切片：**
		- **示例：**
			- ```go
			  package main
			  
			  import "fmt"
			  
			  func main() {
			  	var s []string
			  	fmt.Println(s, s == nil, len(s) == 0)
			  }
			  
			  // [] true true
			  ```
		- **未初始化的切片的状态：**
			- **指针（Pointer）**：`nil` (不指向任何内存地址)
			- **长度（Length）**：`0`
			- **容量（Capacity）**：`0`
		- **`nil` 切片的行为：**
			- 虽然切片为 `nil`，但在大多数情况下，**它的行为与空切片类似，且可以安全使用**。
			- **获取长度和容量**：`len(mySlice)` 和 `cap(mySlice)` 返回 `0`。
			- **使用 `append` 添加元素**：
				- 对 `nil` 切片执行 `append` 操作是安全的。当 `append` 函数发现操作对象是一个 `nil` 切片时，它会自动在后台分配一个新的底层数组，以容纳新添加的元素。
				- 对于 `append` 操作而言，一个 `nil` 切片和一个通过 `make([]T, 0)` 创建的空切片（长度和容量都为0）的行为是完全一样的。
				- `append` 操作会返回一个新的切片。这个新切片包含了新的元素，其长度和容量都会更新，并且它不再是 `nil`。
			- **用于 `for...range` 遍历**：可以安全地用于循环，因切片为空，循环体不会被执行。
			- **注意**：不能访问任何索引（如 `mySlice[0]`），否则会触发运行时错误，因为切片长度为 0。
			- 这种声明方式简洁明了，无需显式初始化（如 `mySlice = make([]string, 0)`），即可直接传入函数或用于 `append` 操作，无需预先判断是否为 `nil`。
- **切片与数组的扩容机制区别**
  collapsed:: true
	- 扩容的关键在于：**谁来执行扩容动作**。
	  collapsed:: true
		- 数组的扩容需要程序员**手动完成**。
		- 切片的扩容由 Go 的运行时（runtime）**自动管理**。
	- **数组的扩容（手动）**
	  collapsed:: true
		- 程序员必须自己：
		  collapsed:: true
			- 创建一个更大的新数组。
			- 用 `for` 循环把旧数组的元素逐个复制过去。
			- 把新元素插入新数组。
			- 改用新数组变量。
		- **总结**：数组扩容麻烦，完全由程序员手动管理。
	- **切片的扩容（自动）**
	  collapsed:: true
		- **场景 A：容量足够**
		  collapsed:: true
			- `append` 直接在原底层数组中追加元素，`len` 增加，`cap` 不变。
		- **场景 B：容量不足**
		  collapsed:: true
			- 运行时自动分配一个更大的数组。
			- 自动复制旧数据并插入新元素。
			- 返回一个新的切片，`ptr`、`len`、`cap` 都被更新。
		- **总结**：切片扩容完全自动化，`append` 会处理所有底层细节。
- **切片中的切片**
  collapsed:: true
	- **核心定义**：`[][]T` 是一个切片，它的每个元素都是另一个切片 (`[]T`)。这是 Go 创建**动态二维数组**（如矩阵或网格）的标准方式。
	- **例子解析：`[][]string`**
	  collapsed:: true
		- `[]string`：一个切片，元素类型为 `string`。
		- `[][]string`：一个切片，元素类型为 `[]string`，即每一行都是一个字符串切片。
	- **动态 vs. 固定**
	  collapsed:: true
		- **二维数组 `[3][3]string]`**：大小固定，每行每列长度固定。
		- **切片的切片 `[][]string`**：动态大小，外层切片可通过 `append` 增加行，每个内层切片（行）长度也可以不同。
	- **示例：**
	  collapsed:: true
		- ```go
		  package main
		  
		  import "fmt"
		  
		  func main() {
		      // 1. 创建 (Create)
		      // 创建一个 2x3 (2行3列) 的二维 int 切片
		      grid := [][]int{
		          {1, 2, 3}, // 第 0 行
		          {4, 5, 6}, // 第 1 行
		      }
		  
		      fmt.Println("--- 初始状态 ---")
		      printGrid(grid)
		  
		      // 2. 访问 (Access)
		      // 访问第 0 行, 第 1 列的元素 (值是 2)
		      element := grid[0][1]
		      fmt.Printf("\n访问 grid[0][1] 的值: %d\n", element)
		  
		      // 3. 修改 (Modify)
		      // 修改第 1 行, 第 2 列的元素 (从 6 改为 100)
		      grid[1][2] = 100
		      fmt.Println("\n--- 修改后 ---")
		      printGrid(grid)
		  }
		  
		  // 辅助函数，用于打印网格
		  func printGrid(grid [][]int) {
		      for _, row := range grid {
		          fmt.Println(row)
		      }
		  }
		  ```
		- ```
		  --- 初始状态 ---
		  [1 2 3]
		  [4 5 6]
		  
		  访问 grid[0][1] 的值: 2
		  
		  --- 修改后 ---
		  [1 2 3]
		  [4 5 100]
		  ```
- **通过 append 函数删除切片中的某个元素：**
  collapsed:: true
	- ```go
	  *todos = append(t[:index], t[index+1:]...)
	  ```
	- 通过拼接两个子切片来达到“跳过”一个元素，从而实现删除的效果。
	- collapsed:: true
	  
	  **获取可修改的值 (`t := *todos`):**
		- 由于方法使用了**指针接收者** `*Todos`，首先通过解引用操作符 `*` 获取到实际的 `Todos` 结构体值 `t`，因为我们最终要修改它内部的切片引用。
	- collapsed:: true
	  
	  **构建左侧子切片 (`t[:index]`):**
		- 创建一个新切片，包含所有位于被删除元素（索引 `index`）**左侧**的元素（从头到 `index-1`）。
	- collapsed:: true
	  
	  **构建右侧子切片 (`t[index+1:]...`):**
		- 创建一个新切片，包含所有位于被删除元素**右侧**的元素（从 `index+1` 到结尾）。
		- 使用 **`...` (展开操作符)** 将其视为独立的参数传递给 `append`。
	- collapsed:: true
	  
	  **拼接 (`append(...)`):**
		- 使用 `append` 函数将**左侧切片**与**展开的右侧切片**拼接在一起，生成一个**不包含**原 `index` 元素的、更短的新切片。
	- collapsed:: true
	  
	  **更新原始数据 (`*todos = ...`):**
		- 它通过 `todos` 指针找到对应的内存地址，并将该地址中的整个数据块用新生成的切片完整替换，从而实现对调用者传入切片的修改。
- `copy(a, b)` 把 b 切片的元素拷贝到 a 切片。
- `slices.Equal` 比较两个切片的元素是否相等。
-