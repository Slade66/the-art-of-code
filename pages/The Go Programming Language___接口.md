- **接口是什么：**
	- 接口是一个标准，用于让两个不同的事物合作。如果没有统一的标准，大家各搞各的，最后在集成时就会出现对接不上的情况。
	- 接口变量可以存储任何实现了该接口的类型的值，从而实现多态。这使函数能够接受多种类型的参数，无需为每种类型单独编写函数版本。
	- 接口不关心数据，接口只关心行为，它只列出类型必须有的方法。
- **接口的定义：**
	- ```go
	  type 接口名 interface {
	      方法1(参数列表) 返回值
	      方法2(参数列表) 返回值
	  }
	  ```
	- 接口是由一组方法签名组成的类型。内部只有方法签名（即方法名、参数和返回值），不包含具体实现。
	- 接口通过定义一组方法，描述一个值应该具备的行为，而不关心值的具体类型或实现方式。一个值要想符合这个标准，必须实现接口中定义的所有方法。
- **接口的实现：**
	- **隐式实现：**Go 中的接口是隐式实现的，接口类型指定了一个方法集合，任何实现了接口中定义的所有方法的类型，就被视为实现了该接口，无需显式声明。
	- **接口实现的定义：**一个类型要实现某个接口，它必须完整地实现接口定义的所有方法，它的方法集必须是接口方法集的超集，且方法的名称、参数和返回值必须完全一致。类型可以有其他额外的方法，但不能缺少接口要求的方法，否则就不符合该接口。
	- 一个类型可以实现多个接口，一个接口也可以被多个类型实现。
- **调用接口变量的方法：**
	- 接口变量可以调用接口中定义的所有方法，即使你不知道值的具体类型，但可以确定它具备这些行为。如果传入的值未实现接口要求的方法，就不满足接口，将导致编译错误。
	- 使用接口时，关注的是值是否实现了所需的方法，而不是它属于哪种具体类型。这意味着你可以在不了解值得具体类型的情况下，调用这些方法。
- **类型断言：**
	- 将具体类型的值赋给接口变量后，就只能调用接口中定义的那些方法，不能访问该类型的其它方法。
	- 类型断言用于从接口变量中提取其实际的具体类型，只有在知道具体类型后，才能调用该类型中定义但未在接口中声明的方法。
	- ```go
	  值, ok := 接口值.(目标类型)
	  ```
	- 如果类型断言只返回一个值，而类型不匹配，将会引发运行时错误。
	- 使用带有两个返回值的断言形式可以避免此类错误。第二个返回值是一个布尔值，通常命名为 `ok`，表示断言是否成功。
	- 一旦断言成功，就可以调用目标类型中定义、但接口未定义的方法。
- **空接口：**
	- 空接口（`interface{}`）是一个不包含任何方法的特殊接口，它代表了“没有任何限制的容器”。
	- 在现代 Go（1.18 及以上版本）中，`interface{}` 拥有一个更易读的别名 `any`。两者完全等价。
	- 因为所有类型都自动满足不包含任何方法的接口（所有类型都至少实现了零个方法），所以空接口可以存储任意类型的值。因此，接收空接口参数的函数可以接受任何类型的实参。
	- **适用场景：**当你需要编写一个函数，它必须能接收任何类型的参数时，`interface{}` 就是你的唯一选择。你不知道传进来的是 `int` 还是 `string` 还是 `struct`。
	- 由于空接口没有定义任何方法，无法直接调用其上的方法。若要使用具体类型的方法，需通过类型断言获取其真实类型。
	- `interface{}` (或 `any`) 是 Go 语言的“万能类型”。它允许你暂时“抛弃”类型安全，以编写能处理任何类型的通用代码。代价是你丢失了关于它是什么的具体信息，直到你用“类型断言”去检查它。
- **方法集的规则：**
	- 在 Go 语言中，每一个类型都有一个与它关联的“方法集”。“方法集”就是一份清单，上面列出了这个类型“拥有”哪些方法。
	- Go 语言有一个很重要的规则：**指针类型的接收者拥有的能力（方法）比值类型相等或更多。**
		- 值类型只有值接收者定义的方法。指针类型不仅有指针接收者的方法，还包含了值接收者的方法。
- **值接收者和指针接收者是不同的类型：**
	- 方法的接收者可以是值类型，也可以是指针类型。
	- 我们可以为类型定义方法，但这些方法是和“方法的接收者”绑定的。
	- `person` 和 `*person` 在 Go 语言的类型系统中被视为完全不同的类型。
- **接口变量**
	- **接口变量是 Go 语言实现多态的方式。**“多态”意味着“多种形态”。
	- 接口变量就是一个万能容器，它不在乎它装的是什么具体类型，它可以“持有”任何类型的值。它只在乎这个类型是否能“做事”（即是否实现了接口的方法）。
	- 接口就像是一个能力清单，它规定了一个类型必须要具备哪些方法。如果一个类型（比如结构体）的值有这个清单上的所有方法，它就“实现”了这个接口，就可以被赋值给接口类型的变量。
	- 接口只认“你有没有这套方法”，不看你是什么类型。
	- **接口变量里装了什么？**
		- 一个接口变量就是一个**包含两个插槽的容器 `(value, type)`**：
			- **`type` (动态类型)：** 存放值的具体类型信息。
			- **`value` (动态值)：** 存放该类型的值的拷贝。
		- 当你调用 `i.M()` 时，Go 运行时会执行以下操作：
			- **查看 `type` 插槽**：Go 检查 `i` 目前装的是什么类型。
			- **查找方法**：Go 查找该类型的 `M()` 方法。
			- **执行**：Go 从 `value` 插槽中取出数据，并将其作为接收者来调用那个 `M()` 方法。
			- 这个过程（在运行时查找并调用正确的方法）被称为动态分派
	- **接口变量的零值：**
		- 接口变量的零值是 `nil`。
		- 当你声明 `var i I` 时，`i` 就是一个 `nil` 接口。此时，`i` 的内部状态是：`(value = nil, type = nil)`
		- 一个 `nil` 接口值既不持有值，也不持有具体类型。
		- 如果你尝试在一个 `nil` 接口上调用方法，程序会崩溃，因为它里面什么都没有，根本不知道该去调用哪个方法。
			- 当你调用 `i.M()` 时，Go 的**动态分派**机制会启动。
			- Go 会查看 `i` 的 `type` 插槽。
			- Go 发现 `type` 插槽是 **`nil`**！
			- Go 陷入了困惑：“我应该调用哪个 `M()` 方法？是 `F.M()` 吗？还是 `T.M()`？还是其他某个类型的 `M()`？我**不知道**！”
			- 由于 Go 无法确定要执行哪个具体的方法，它别无选择，只能立即**恐慌**，并抛出一个运行时错误。
	- **示例：**
		- ```go
		  // 定义接口
		  type Greeter interface {
		  	Greet()
		  }
		  
		  // 定义结构体
		  type person struct {
		  	name string
		  }
		  
		  // 指针接收者实现接口方法
		  func (p *person) Greet() {
		  	fmt.Println("Hello,", p.name)
		  }
		  
		  func main() {
		  	var g Greeter // 接口变量
		  
		  	// --- 值类型赋值失败 ---
		  	// g = person{"小泽"}  // ❌ 编译错误：person 类型没有实现 Greet 方法（它没有指针接收者）
		  
		  	// --- 指针类型赋值成功 ---
		  	g = &person{"小泽"}  // ✅ OK：*person 实现了 Greet 方法（指针接收者）
		  	g.Greet()            // 输出：Hello, 小泽
		  }
		  ```
		- `g = person{"小泽"}`：编译器会检查 `person` 的方法集，发现它没有值接收者的 `Greet()` 方法，因此无法赋值给 `Greeter` 接口。
		- `g = &person{"小泽"}`：这时 `*person` 拥有了 `Greet()` 方法，因为 `*person` 类型的方法集包含了 `Greet()`（指针接收者），因此赋值成功。
- **`nil` 接口 vs. 持有 `nil` 值的接口**
	- **nil 接口：**例如 `var i I`。此时接口内部表示为 `(type=nil, value=nil)`，因此 `i == nil` 的结果为 `true`。
	- **持有 nil 值的接口：**
		- ```go
		  var t *T // t 的值是 nil
		  i = t
		  ```
		- 此时接口内部表示为 `(type=*T, value=nil)`。
		- 在这种情况下，`i == nil` 的结果为 `false`，因为接口中仍然包含类型信息 `(*T)`。
	- **接口只要包含类型信息，即使其内部值为 nil，依然可以正常调用方法。**
		- 此时 Go 会调用接口中保存的类型（`*T`）的 `M()` 方法，并将内部的 `nil` 值作为接收者传入。方法的实现者必须在方法中添加 “`nil` 守卫”，否则在访问接收者字段时会导致程序发生恐慌（panic）。
-