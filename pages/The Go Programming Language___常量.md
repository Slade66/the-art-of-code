- 在 Go 语言中，`const` 用于声明在编译期间值已确定且不可更改的常量。
- **不可变性：**一旦声明，常量的值就不能被修改。
- **常量是高精度值：**
	- 你可以把 Go 的数字常量想象成一个纯粹的数字，而不是一个已经存入计算机内存的变量。
		- **变量**: 就像一个**固定容量的杯子** 🥛。它只能装特定大小（例如64位）的数字，超出范围就会溢出。
		- **常量**: 就像**无限的数学海洋** 🌊。它代表一个精确的、没有大小限制的数值。
	- 常量在定义时，它就是一个高精度的数学值，并没有被“塞进”任何一种具体的整型中，它们在默认情况下是 无类型的
	- 一个常量会根据它被使用的上下文，来决定自己最终应该变成什么类型。
	- 一个无类型的常量会“适应”它被赋值或传递给的变量或函数参数的类型，前提是它的值在该类型中能够被精确表示。
	- 一个高精度的常量只有在它的值能够被目标类型容纳时，才能被成功使用。
	- 理论上，只要编译器有足够的内存和计算能力来处理这个数字的文本表示，你就可以定义一个任意大的常量。但一个常量最终的价值在于它能够被程序使用。 而使用的那一刻，就是它必须从“无限的数学海洋”被装入一个“有限的物理杯子”（即有类型的变量）的时刻。如果你定义的常量如果最终不能被 Go 的任何一个基础数据类型所表示，那么它在程序中几乎是无用的，因为它无法被赋值给任何变量。
- **声明常量的语法：**
	- **注意：**
		- 常量必须在声明时赋值，不能在之后再赋。
		- 不支持使用短变量声明（`:=`）的方式，必须使用 `const` 关键字。
	- **单个常量声明：**
		- **语法：**`const 常量名 类型 = 值`
		- ```go
		  const Pi float64 = 3.14159
		  const Pi = 3.14 // 类型可以省略，Go 会根据赋的值自动推断类型
		  ```
	- **批量声明常量：**
		- ```go
		  const (
		      A = 1
		      B = 2
		      C = 3
		  )
		  
		  如果某行没有显式赋值，则默认与上一行相同：
		  const (
		      A = 1
		      B        // B = 1
		      C = 3
		  )
		  ```
	- **使用 `iota` 生成递增值：**
		- `iota` 是一个在 `const` 声明块中从 0 开始自动递增的标识符，常用于定义枚举类常量。
		- ```go
		  const (
		      Monday = iota // 0
		      Tuesday       // 1
		      Wednesday     // 2
		  )
		  ```
-