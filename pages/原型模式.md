- 原型模式是一种创建型设计模式，它允许你通过复制一个现有的对象来创建新的对象，而无需关心这个对象的具体创建细节。“现有的对象”被称为原型（Prototype）。后续所有的新对象都是这个原型的克隆体。
- **举例：**
	- **核心思想：**将创造过程委托给“原型”。
	- 在传统的面向对象编程中，我们创造一个新对象时，通常的“蓝图”是类。我们告诉系统：“请按照 `Car` 这个类的定义，给我创建一个新对象。” 这个过程叫做实例化。
	- 原型模式提出了一个不同的问题：“如果我创造一个新对象的蓝-图，不是一个‘类’，而是一个‘已经存在的对象’，我该怎么做？”
	- 这是一种根本性的思想转变：从“基于类的创建”转向“基于实例的创建”。
	- 原型模式的答案非常优雅：不要由客户端或工厂来负责从零开始构建一个复杂的对象，而是将创建新对象的任务，委托给那个作为“蓝图”的已有对象本身。
	- 客户端代码不再说：“嘿，工厂，请用这些零件（参数）给我造一辆车。”
	- 而是说：“嘿，我找到了这辆我很满意的保时捷 911（一个已存在的对象），保时捷 911 啊，请你自己复制一个一模一样的出来给我。”
	- 这个过程，称之为克隆（Cloning）。那个被选为“蓝图”的、已经存在的对象，就是原型（Prototype）。
- **关键角色：**
	- **原型（Prototype）：**这是一个抽象概念，代表任何一个“知道如何复制自己”的对象。它必须提供一个“复制”或“克隆”的操作。
	- **具体原型（Concrete Prototype）：**这是一个具体的、已经存在的对象实例。它是克隆操作的源头。
	- **客户端（Client）：**需要新对象的代码。它不关心对象的具体类型和创建细节，只负责找到一个合适的原型，并命令它进行克隆。
- **核心流程如下：**
	- 客户端找到一个满足需求的原型对象。
	  logseq.order-list-type:: number
	- 客户端调用该原型对象的“克隆”方法。
	  logseq.order-list-type:: number
	- 原型对象在内部负责创建自身的一个副本。
	  logseq.order-list-type:: number
	- 原型对象将这个崭新的、与自己状态相同的副本返回给客户端。
	  logseq.order-list-type:: number
	- 客户端得到一个立即可用的新对象。
	  logseq.order-list-type:: number
- **原型模式解决了什么问题？**
	- **创建成本高昂：**如果一个对象的构造函数（constructor）非常复杂，需要进行数据库查询、网络 IO、或大量计算，那么每次 `new` 一个新对象都会非常耗时。通过克隆一个已初始化的原型，可以绕过这些耗时的步骤。
	- **需要一个特定状态的副本：**当你需要一个与现有对象状态完全相同的新对象时，与其重新创建并执行一系列 `setter` 方法来达到同样的状态，不如直接克隆来得方便快捷。
-