- 这个流程远不止“写代码”那么简单。一个专业、可靠的接口是“设计”出来的，然后才是“实现”出来的。
- ## 阶段一：需求分析
  collapsed:: true
	- 这是所有工作的起点。在敲任何代码之前，你必须百分之百清楚：**我们为什么要做这个接口？**
	- 在这个阶段，要像侦探一样不断追问 "Why"。一个模糊的需求会导致灾难性的设计。
	- **忘记 IDE，不要写一行代码。** 你现在的任务是“侦探”和“外交官”。
	- 跳过这个阶段直接写代码，往往会导致后期大量的返工（比如：“啊？原来还需要支持手动填写 IP？”或者“前端根本不知道正则表达式怎么填”）。
	- **产出物：**一个清晰的需求文档、用户故事（User Story）。
	- **调用方（Consumers）：**谁会来调用这个接口？是我们的前端 App？是另一个微服务？还是开放给第三方开发者？
	- **业务场景（Business Scenario）：**这个接口要解决什么业务问题？（例如：“用户需要在 App 上看到他们的订单列表”。），也就是用户故事，用户是如何使用这个功能的？
	- **核心功能（Core Function）：**这个接口具体要做什么事情？
- ## 阶段二：API 设计
  collapsed:: true
	- 遵循 "契约先行"（Contract-First）的原则：先定义好接口的“合同”，双方（前端和后端）都同意了，再开始施工。
	- **文档编写（贯穿始终）：**
		- **产出物：**API 规范文档。
		- 如果你的接口没有文档，那它就等于不存在。
		- 使用 OpenAPI（Swagger）规范来编写，它可以自动生成文档和客户端代码。
		- **为什么？**为了让前端同事、其他后端同事、以及未来的你，知道这个接口是干嘛的、怎么调用，它的组件架构图。
		- **文档必须包含：**
			- 接口描述（干什么用的）。
			- URL 和 HTTP 方法。
			- 所有请求参数（路径、查询、请求体）的含义、类型、是否必填。
			- 所有响应（包括成功和失败）的示例和字段含义。
	- **选择协议（Protocol）**
		- 对于大多数 Web 应用，你接触到的会是 **RESTful API**（基于 HTTP 协议）。当然，也有 GraphQL、gRPC 等，但我们先专注 REST。
	- **定义资源（Resource）**
		- 思考你要操作的“名词”是什么。例如：`用户 (User)`、`订单 (Order)`、`商品 (Product)`。
		  URI (统一资源标识符) 应该使用名词复数，例如：
			- `/api/users`
			- `/api/orders`
	- **确定动作 (HTTP Verbs)**
		- 使用标准的 HTTP 方法来描述你要对资源做什么“动作”：
			- `GET`：**读取**资源。（例如：`GET /api/users` 获取所有用户，`GET /api/users/123` 获取 ID 为 123 的用户）
			- `POST`：**创建**新资源。（例如：`POST /api/users` 创建一个新用户）
			- `PUT`：**完整替换**一个已存在的资源。（例如：`PUT /api/users/123` 替换 123 号用户的所有信息）
			- `PATCH`：**部分更新**一个已存在的资源。（例如：`PATCH /api/users/123` 只修改 123 号用户的电话号码）
			- `DELETE`：**删除**一个资源。（例如：`DELETE /api/users/123` 删除 123 号用户）
	- **设计“契约”（The Contract）**
		- 这是设计的核心，你需要精确定义输入 (Request) 和 输出 (Response)。
		- **请求（Request）：**
			- **路径参数 (Path Parameters):** 如 `$GET /api/users/{id}$` 中的 `id`。
			- **查询参数 (Query Parameters):** 用于过滤、排序、分页。如 `$GET /api/users?status=active&page=1$`。
			- **请求体 (Request Body):**长啥样？
		- **响应（Response）：**
			- **HTTP 状态码（Status Codes）：**必须准确！
				- `200 OK`：成功。
				- `201 Created`：资源创建成功（用于 `POST`）。
				- `204 No Content`：成功，但没有返回体（用于 `DELETE` 或 `PUT`）。
				- `400 Bad Request`：客户端请求错误（例如：参数格式不对）。
				- `401 Unauthorized`：未认证（没登录）。
				- `403 Forbidden`：已认证，但无权访问。
				- `404 Not Found`：资源不存在。
				- `500 Internal Server Error`：服务器内部出错了（这是你的 Bug！）。
			- **响应体（Response Body）：**同样，通常是 JSON 格式。返回给客户端的数据长什么样子？
	- **版本管理（Versioning）：**如果未来接口需要修改（例如：删除一个字段），如何保证旧的 App 不会崩溃？（例如：`/api/v1/users` 和 `/api/v2/users`）。
	- **安全（Security）：**谁能调用这个接口？需要登录吗？使用什么认证机制（例如：JWT, OAuth2）？
	- **性能（Performance）：**预估的 QPS（每秒请求数）是多少？响应时间（Latency）要求多快（例如：必须在 200ms 内返回）？
- ## 阶段三：开发实现
  collapsed:: true
	- **TDD（测试驱动开发）：**先写一个失败的测试用例，再写代码让它通过。
	- **实现业务逻辑...**
	- **错误处理：**必须周全！任何可能出错的地方（数据库查询失败、外部服务超时、用户输入无效）都要用 `try...catch` 或相应机制捕获，并返回定义好的错误状态码（如 400, 404, 500）。
- ## 阶段四：测试验证
  collapsed:: true
	- “我本地跑通了” 不等于 “开发完成了”。你必须证明你的接口在各种情况下都能正确工作。
	- **1. 单元测试 (Unit Tests):**
		- **目标：** 测试最小的代码单元（例如：Service 层的一个函数）的逻辑是否正确。
		- **特点：** 速度快，不依赖外部服务（如数据库，会用 "Mock" 替代）。
	- **2. 集成测试 (Integration Tests):**
		- **目标：** 测试多个组件协同工作是否正常（例如：测试 Controller + Service + 真实数据库）。
		- **特点：** 速度慢，但更接近真实环境。
	- **3. API / 契约测试 (API / Contract Tests):**
		- **目标：** 从“调用方”的视角测试。验证接口是否严格遵守了阶段二中定义的“契约”。
		- **工具：** **Postman** (手动测试首选), 或使用代码（如 RestAssured, pytest）进行自动化测试。
		- **你需要测试：**
			- **正向用例：** 传入正确参数，是否返回 `200 OK` 和正确的数据？
			- **异常用例：**
				- 传入错误的参数（例如：email 格式不对），是否返回 `400 Bad Request`？
				- 不带 Token 访问，是否返回 `401 Unauthorized`？
				- 查询一个不存在的 ID，是否返回 `404 Not Found`？
	- **4. 性能测试 (Performance Tests):**
		- 使用工具（如 JMeter, k6）模拟高并发，看接口的 QPS 和响应时间是否达标。
- ## 阶段五：部署与发布
  collapsed:: true
	- 代码在你的电脑上运行没意义，必须部署到服务器上。
	- **环境 (Environments):**
		- `Dev` (开发环境): 你自己调试用。
		- `Staging / QA` (测试环境): 提测给测试工程师（QA）用的环境。
		- `Production` (生产环境): 最终用户访问的真实环境。
	- **CI/CD (持续集成/持续部署):**
		- 这是一个自动化的流程。当你提交代码到 Git 仓库（如 GitLab/GitHub）时：
		- **CI (Integration):** 自动运行所有测试（阶段四）。
		- **CD (Deployment):** 测试通过后，自动打包（例如：打包成 Docker 镜像），并部署到 `Staging` 或 `Production` 环境。
	- **API 网关 (API Gateway):**
		- 在专业的架构中，你的接口不会直接暴露给公网。
		- 所有请求都会先经过一个“网关”。网关负责处理通用的逻辑，如：身份认证、限流 (Rate Limiting)、日志记录、路由转发。
- ## 阶段六：运维与监控
  collapsed:: true
	- 发布上线不是结束，而是真正“生命”的开始。
	- **监控 (Monitoring):** 你必须知道你的接口活得好不好。
		- **日志 (Logging):** 记录关键的请求信息和所有错误。当用户报告问题时，日志是你的第一破案现场。
		- **指标 (Metrics):**
			- **P99/P95 延迟 (Latency):** 95% 的请求响应时间是多少？
			- **错误率 (Error Rate):** 有多少百分比的请求返回了 5xx 或 4xx？
			- **吞吐量 (Throughput):** QPS 是多少？
		- **告警 (Alerting):** 当“错误率 > 5%” 或 “P99 延迟 > 1 秒” 时，必须自动发消息（邮件、钉钉、Slack）通知开发人员。
	- **维护 (Maintenance):**
		- **Bug 修复：** 出了 Bug，快速定位并修复。
		- **迭代 (Iteration):** 业务提出新需求，回到阶段一，开始 V2 版本的开发。
		- **弃用 (Deprecation):** 当 V2 上线后，你需要通知 V1 的调用方尽快迁移，并在约定时间后（例如 3 个月）正式下线 V1 接口。
- ## 原则
  collapsed:: true
	- **设计永远优先于编码。**
	  collapsed:: true
		- 拿到需求，先在纸上或文档里把 API “契约” 写下来，而不是一头扎进代码里。
		- 一旦设计糟糕，后续的开发、测试、维护都会极其痛苦。这就像盖房子，图纸画错了，房子必然会塌。
		- “设计是蓝图，编码是施工。没有蓝图的施工是灾难。”
	- **把自己当成“调用方”。**设计接口时，要考虑“这个接口用起来方不方便？”、“这个错误提示清不清楚？”。
	- **安全和错误处理不是“附加题”。**它们是产品的核心功能。一个没有错误处理的接口是 100% 的废品。
- ## 例子
-