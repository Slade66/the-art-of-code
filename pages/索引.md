索引的作用
heading:: true
	- 索引就像书的目录，能显著加快查询速度。有了目录，可以直接跳转到目标位置；没有目录，就只能逐页查找。通过索引查找数据通常比全表扫描快得多，因为可以进行更高效的 $O(\log n)$ 二分查找，而全表扫描则是 $O(n)$ 的线性查找。
	- 索引是一种加速查询的数据结构，是避免全表扫描的主要机制，但也会带来代价：它占用额外的磁盘空间，并在插入、更新或删除数据时增加写入的开销，因为这些操作需要同时维护索引。
- 索引的类型
  heading:: true
	- **普通索引（Index）**：最基本的索引类型，仅用于加快查询，无任何约束功能。
	- **唯一索引（Unique Index）**：在提升查询效率的同时，强制列值唯一，但允许为 `NULL`，因为 `NULL` 不等于 `NULL`。
	- **主键索引（Primary Key Index）**：专为主键字段设置，要求值唯一且非空，每张表只能有一个。
	- **复合索引（Composite Index）**：是在多个列上建立的单个索引，适用于多条件组合查询。
	- **全文索引（Fulltext Index）**：专用于大文本字段的全文搜索，如文章、评论等内容。
	- **空间索引（Spatial Index）**：用于地理空间（GIS）数据的查询，字段需为空间数据类型。
- 索引的底层结构
  heading:: true
	- InnoDB 是 MySQL 默认的存储引擎，其索引底层采用 B+ 树实现。
	- 为什么要用 B+ 树？
	  heading:: true
		- **查询效率高且稳定：**B+ 树是一种自平衡的树，通过节点的分裂与合并机制，始终保持各叶子节点到根节点的路径长度接近，确保查找操作的时间复杂度稳定在 $O(\log N)$。这有效避免了因插入顺序不当而导致树结构退化成链表，从而出现 $O(N)$ 查找性能的最坏情况。
		- **支持范围查找：**所有数据存储在叶子节点，且叶子节点通过指针顺序连接，遍历范围时无需多次回到上层节点。
		- **I/O 效率高：**B+ 树是一种多叉树，每个节点可包含多个子节点，使整棵树层级较少，即使数据量达百万级，通常也仅需 2～4 层，从而有效减少磁盘 I/O 次数，适用于在磁盘中高效检索数据。
	- 为什么用 B+ 树而不是其它结构？
	  heading:: true
		- **哈希表**：数据无序，仅支持等值查找，不适用于范围查询，且存在哈希冲突。
		- **二叉搜索树：**树高较大，且在最坏情况下会退化为链表。
		- **AVL 树**：为保持平衡，插入和删除需频繁旋转，代价较高；树高较大，导致磁盘访问开销较大。
		- **红黑树**：虽旋转较少，但仍为二叉结构，树高依然较大，查找时磁盘 I/O 开销较高。
		- **B 树**：虽然是多路平衡查找树，但数据分布在所有节点，无法像 B+ 树那样在叶子节点顺序遍历，执行范围查询时需要频繁回到根节点查找，效率较低。
	- 聚簇索引（Clustered Index）
	  heading:: true
		- InnoDB 的核心设计理念之一是“万物皆索引”，即表中的数据行本身就存储在聚簇索引（通常是主键索引）的叶子节点中。而二级索引的叶子节点仅存储索引列的值和对应行的主键值，用于回表定位完整数据。
		- 每张表只能有一个聚簇索引。若用户定义了主键，InnoDB 会将其作为聚簇索引；若未定义主键，则优先使用第一个所有列为 `NOT NULL` 的 `UNIQUE` 索引；若仍不存在符合条件的索引，InnoDB 会为每行生成一个隐藏的行 ID，并基于该列构建聚簇索引。
	- 二级索引（Secondary Index）
	  heading:: true
		- 又称非聚簇索引，用于非主键列。
		- 叶子节点存储的是索引列的值以及对应的主键值，如果不能满足查询结果列的需求，需通过主键值回表查询。
		- **回表**：通过非聚簇索引查询时，如需获取非索引列的数据，需先在索引中定位主键值，再根据主键到聚簇索引中查找完整行数据，这一过程称为回表。
- 索引的管理
  heading:: true
  id:: 6815a0d0-8fd0-4ad3-9a95-c17f54c93866
	- 创建索引
	  heading:: true
		- 在创建表时添加索引：
			- ```mysql
			  CREATE TABLE users (
			      id INT PRIMARY KEY,
			      name VARCHAR(100),
			      email VARCHAR(100),
			      INDEX idx_name(name)
			  );
			  ```
		- 在已存在的表上添加索引：
			- `CREATE [索引类型] INDEX index_name ON table_name(column_list);`
			- `ALTER TABLE table_name ADD [索引类型] INDEX index_name(col1[, col2]);`
			- `UNIQUE`, `FULLTEXT`, `SPATIAL` 是可选关键字，用于指定索引类型。
	- 查看索引
	  heading:: true
		- `SHOW INDEX FROM table_name;`
	- 删除索引
	  heading:: true
		- `DROP INDEX index_name ON table_name;`
		- `ALTER TABLE table_name DROP INDEX index_name;`
- 索引的优化策略
  heading:: true
	- 如何选择合适的列创建索引？
	  heading:: true
		- **优先选择区分度高的列**：索引在重复值少的列上效果最好，因为能够更有效地过滤掉大量不相关的行。区分度低的列不适合建索引。
		- **WHERE 子句中的条件列**：经常作为查询条件的列应建立索引。
		- **JOIN 子句中的连接列**：常用于表连接的列适合建索引以提升连接效率。
		- **ORDER BY / GROUP BY 列**：对排序或分组频繁的列建索引，可以利用索引的有序性减少排序开销。
		- **组合索引的顺序设计**：将高选择性的列放在索引的起始位置，使得 MySQL 在查找过程中能够迅速排除大量无关行。后续的列则在已经缩小的范围内进一步精确筛选。反之，如果将一个选择性很低的列放在复合索引的开头，那么即使查询条件包含了后续更高选择性的列，索引的第一步筛选效果也会很差。
		- **控制索引数量**：索引不是越多越好，它们会占用存储空间，并增加写操作的成本。
	- 导致索引失效的原因
	  heading:: true
		- 在某些情况下，即使列上有索引，优化器也可能不会使用。了解常见的索引失效写法，并掌握规避技巧，有助于编写更高效的 SQL 查询。
		- 对索引列使用函数或进行计算。
		- 使用 `LIKE` 模糊匹配时以 `%` 开头，会触发全表扫描。
		- 发生隐式类型转换。
		- `OR` 条件中包含未建索引的列。改写为 `UNION ALL`。
		- 使用组合索引时未遵循最左前缀规则。
		- 索引列选择性差或数据量太小，MySQL 会选择全表扫描，因为比走索引更快。
	- 覆盖索引
	  heading:: true
		- 传统索引查询通常需要回表：先通过二级索引定位主键，再根据主键到聚簇索引中查找完整数据行。
		- 如果索引已包含查询所需的所有列（要查询的字段都在索引中），MySQL 就可以直接从索引中获取所有需要的数据，无需回表，从而显著提升查询性能。
	- 索引下推（Index Condition Pushdown）
	  heading:: true
		- 索引下推是一种优化机制，MySQL 通过将涉及联合索引中的多个字段的 `WHERE` 条件下发到存储引擎层，在索引扫描阶段提前进行判断，从而减少不必要的回表操作，提升查询效率。
		- 在未开启索引下推时，Server 层只会将最左前缀的索引条件传给存储引擎，先获取满足初步条件的主键，再回表读取完整数据，由 Server 层继续判断剩余的过滤条件。而在开启索引下推后，只要筛选字段包含在索引中，Server 层就会将更多的条件一并传给存储引擎，使其在扫描索引时就完成过滤，从源头上减少回表次数和数据传输量。
	- 最左前缀原则
	  heading:: true
		- 联合索引对查询字段的顺序非常敏感，顺序必须与建索引时一致，一旦中间字段被跳过，后续字段将无法使用索引。
		- 联合索引将多个字段组合成 B+ 树叶子节点的键，先按第一个字段全局排序，值相同时再按第二个字段排序。B+ 树之所以能实现 $O(\log n)$ 的高效查找，正是依赖这种键的有序性。在复合索引中，第二个字段只有在第一字段相同时才有序，因此如果缺少最左前缀，后续字段的顺序无法确定，自然也就无法使用索引进行二分查找。
		- 联合索引中的范围查询导致索引失效问题
		  heading:: true
			- 在使用联合索引进行查询时，如果最左字段使用了范围条件（如 `a > 1`），将中断最左前缀匹配原则。此时，虽然范围字段本身仍可参与索引扫描，但后续字段将无法继续利用索引。
			- 原因在于 B+ 树只能执行一次连续的顺序扫描。MySQL 会根据范围条件定位到首个满足 `a > 1` 的记录（如 `a = 2`），然后沿着索引的叶子节点链表依次向后扫描，直到超出该范围为止。在此过程中，后续字段（如 `b`）在整个范围内的值是分散且无序的，无法在索引层进行精确匹配。MySQL 只能在扫描到具体记录后，再对这些字段进行条件判断，可能通过索引下推优化，也可能回表执行过滤。
			- 后续字段是否能参与索引查找，取决于前导字段是否为等值匹配。即使能缩小索引扫描范围，也仅限于前导字段等值对应的那一段索引区域。
	- 利用索引的有序性加快结果排序
	  heading:: true
		- 如果为过滤条件和排序字段建立了合适的索引，MySQL 可以利用索引的有序性直接按顺序读取数据，从而同时加速数据筛选与排序，避免额外的排序操作，显著提升查询性能。
		- 当 `WHERE` 和 `ORDER BY` 子句中的列及其顺序与联合索引完全一致时，优化器通常会选择通过索引顺序扫描来获取有序结果。
- 索引的性能分析
  heading:: true
	- `EXPLAIN`
	  heading:: true
		- `EXPLAIN` 是用于分析 SQL 查询执行计划的核心工具，能够帮助我们了解 MySQL 打算如何执行一条查询语句，特别是是否使用了索引、使用了哪个索引，以及判断查询中的性能瓶颈所在。
		- `EXPLAIN` 的输出结果：
			- `id`：查询中每个 `SELECT` 的序列号。
			- `type`：表示 MySQL 访问表的方式。
				- 从好到差大致为：`system` > `const` > `eq_ref` > `ref` > `range` > `index` > `ALL`。
				- `ALL` 表示全表扫描，是性能瓶颈的信号。
			- `possible_keys`：列出了 MySQL 认为可能适用于此查询的索引。
			- `key`：显示 MySQL 实际决定使用的索引。如果为 `NULL`，表示没有使用索引。
			- `Extra`：包含非常重要的附加信息。常见的有：
				- `Using where`：表示在存储引擎检索行后，还需要在 Server 层应用 `WHERE` 子句中的其它条件进行过滤。
				- `Using index`：表明查询使用了覆盖索引，即所需数据完全可以从索引中获取，无需回表。
				- `Using filesort`：表示 MySQL 无法利用索引完成排序，需要进行额外的排序操作。
				- `Using temporary`：表示 MySQL 需要创建一个临时表来处理中间结果。
				- `Using index condition`：存储引擎层利用索引过滤部分行，减少返回给 `Server` 层的数据。
	- `EXPLAIN ANALYZE`
	  heading:: true
		- 比普通 `EXPLAIN` 更进一步，实际执行查询并显示真实耗时。
	- 慢查询日志（Slow Query Log）
	  heading:: true
		- 记录执行时间超过设定阈值（如 1 秒）的 SQL，用于定位执行缓慢的语句。