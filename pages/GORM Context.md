- `db.WithContext(ctx)`：
	- 它的核心目的是让数据库操作能够“感知”请求的生命周期，从而实现：
		- **超时控制**：确保数据库查询遵守上层设置的超时限制。
		- **优雅取消**：当上游任务（如 HTTP 请求）被取消时，能够**级联取消**正在进行的数据库查询，避免资源浪费和不必要的等待。
		- **全链路追踪**：将 `trace_id` 等元数据传递到数据库层，便于监控和调试。
	- 在现代网络应用中，任何涉及数据库操作的场景，都应将 `Context` 绑定到每次操作，这是一个必须遵守的最佳实践。
- **比喻：**
	- 当代码执行到需要操作数据库时，就像流程走到了“数据库部门”门口。
	- 如果不带 `WithContext(ctx)`：
		- `r.data.db.Save(po)`
		- 这相当于直接把“工作指令”（`Save(po)`）交给数据库部门，却没有带上“通行证”。数据库部门接到指令后开始工作，但如果此时请求超时（外部通行证失效），数据库部门并不会知晓，仍会继续执行任务，浪费资源。
	- 如果带上 `db.WithContext(ctx)`：
		- `r.data.db.WithContext(ctx).Save(po)`
		- `WithContext(ctx)` 的作用是告知 GORM：“请为接下来的数据库操作（`Save`）创建一个带有此通行证的会话（Session）。”这相当于在递交“工作指令”的同时，把“通行证” (`ctx`) 交给了数据库部门。
		- 现在，GORM（或底层数据库驱动）在执行 `Save` 操作时，会变得更加“智能”：
			- 它会时不时地看一眼手里的这张“通行证”。
			- 如果发现通行证被盖上了“作废”的章（`Context` 被取消了），它会立刻停下手中的活，中断数据库查询，并返回一个错误（比如 `context.Canceled`）。
			- 如果发现通行证已经“过期”了（`Context` 超时了），它也会立刻停止工作，并返回一个超时错误（`context.DeadlineExceeded`）。
			- 它还可以读取通行证上的“追踪ID”，并把它加到 SQL 日志里，方便你调试。
-