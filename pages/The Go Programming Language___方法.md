- **Go 没有 “类”，但有 “方法”**
	- 在像 Java, Python 或 C++ 这样的语言中，你创建一个 **"类" (Class)**，然后在类里面定义数据（字段）和行为（方法）。
	- 在 Go 中，**数据 (data)** 和 **行为 (behavior)** 是**分开定义**的。
		- 你首先定义一个**类型 (Type)**，比如 `type Vertex struct { ... }`，它只关心数据。
		- 然后，你通过一种特殊语法，将一个**函数 (Function) “附加”** 到这个类型上，这个“附加”了的函数就叫做**方法 (Method)**。
- **什么是方法？**
	- 在 Go 语言中，方法本质上就是绑定到特定类型的函数。方法只是多带了一个接收者参数的函数。
	- 方法与普通函数的主要区别在于：方法具有一个接收者参数，用于指定该方法属于哪个类型，且只能通过该类型的变量调用。
- **方法的定义：**
	- 方法的定义语法与普通函数类似，不同之处在于函数名前需要添加一个接收者，用来表明该函数属于某个类型的方法。
	- 方法的接收者本质上是方法的第一个参数，用来表示该方法**绑定的类型**。实际上，调用方法时就是将接收者作为参数传入方法中。接收者变量在方法内部的作用，类似于其他语言中的 `this` 或 `self`。
	- `func (v Vertex) Abs()` 这种方法语法，只是一种**语法糖**，它在语义上等同于 `func Abs(v Vertex) float64`。接收者本质上就是被“提到”函数名前面的第一个参数。当你调用 `v.Abs()` 时，Go 编译器在背后就是把它**翻译**成了类似 `Abs(v)` 的形式来执行。
	- **语法：**
		- ```go
		  func (接收者变量名 接收者类型) 方法名(参数列表) 返回值 {
		      // 方法体
		  }
		  ```
	- **示例：**
		- ```go
		  type Point struct {
		      X, Y int
		  }
		  
		  // 定义一个方法 Move，用于移动点的位置
		  func (p Point) Move(dx, dy int) {
		      p.X += dx
		      p.Y += dy
		  }
		  ```
- **值接收者与指针接收者：**
	- 使用值接收者时，方法会复制一份原始结构体实例，接收到的是该值的副本。因此，方法内部的修改不会影响原始结构体，因为它操作的是副本。
	- 若希望修改原始值，应使用指针接收者，方法会直接操作结构体的原始数据，因此修改结构体的字段会影响到原始结构体。
	- 当以值方式调用指针接收者的方法时，Go 会自动进行取址转换。
		- ```go
		  type Person struct {
		      Name string
		  }
		  
		  // 指针接收者方法
		  func (p *Person) Greet() {
		      fmt.Println("Hello,", p.Name)
		  }
		  
		  func main() {
		      p := Person{Name: "小泽"}
		   	p.Greet() // Go 会自动通过取地址操作把 p 转换为 *Person 类型。所以，实际上是通过 *Person 类型调用该方法的。
		  }
		  ```
	- 如果结构体非常大，复制整个结构体的代价较高（可能会浪费大量的内存和计算资源），且方法需要修改结构体的字段，此时使用指针接收者会是一个更好的选择。
	- 如果不确定，请使用指针接收者。
	- 如果一个类型已经有了一些指针接收者的方法，那么其它方法也应该使用指针接收者，为了好看。
- **注意：**
	- 方法和其接收者类型必须定义在同一个包中。
-