- Spring Cloud 是 Java 世界中构建微服务最主流且最完善的解决方案。它不是一个单一的框架，而是一个基于 Spring Boot 的工具集，你可以把它看作一个“全家桶”，专门用于解决微服务架构中常见的问题。
- **Spring Boot 和 Spring Cloud 的区别：**
	- Spring Boot 是一个用于快速开发应用的框架，其核心理念是简化配置，帮助开发者快速构建单体应用。它就像一套已经精装修好的房子，让你专注于实现业务功能，而不用费心处理搭建过程中的各种繁琐细节。
	- Spring Cloud 是一个微服务工具集，核心在于治理和协调由多个 Spring Boot 应用组成的复杂分布式系统。你可以通过 Spring Boot 快速搭建多个服务（如用户服务、订单服务、商品服务等），就像造好了许多栋房子。但一座城市光有房子还不够，还需要道路、电网、排水系统等基础设施，将这些房子有机连接起来。Spring Cloud 的作用，就像是在规划和管理这样一座现代化城市。它不关心每栋房子是如何建成的（这是 Spring Boot 的职责），而是专注于服务之间如何协同工作，从而构建一个强大且具备弹性的分布式系统。
	- 我们先用 Spring Boot 把一个个独立的微服务（房子）快速开发出来，然后再用 Spring Cloud 的各种组件（城市公共设施）把它们有机地组织和管理起来，最终形成一个强大、稳定、易于管理的微服务架构。
	- 学习 Spring Cloud 的前提是熟练掌握 Spring Boot，因为 Spring Cloud 的所有组件都是以 Spring Boot 应用的形式运行的。
- **Spring Cloud 和 Spring Cloud Alibaba 的区别：**
	- 简单来说，它们的关系就像“标准与实现”或“接口与实现类”。
	- **Spring Cloud：**是一套构建微服务架构的规范和标准，定义了诸如服务发现、配置管理、熔断降级等常见分布式问题的抽象接口，但不一定提供所有功能的具体实现。
	- **Spring Cloud Alibaba：**则是对这些规范的完整实现，它采用了阿里巴巴在“双十一”等大规模业务场景中验证过的成熟组件（如 Nacos、Sentinel 等），为 Spring Cloud 提供了可靠的落地方案。
- **Spring Cloud 中的组件：**
	- **服务治理：**
		- 在动态扩缩容的环境下，随着服务数量从个位数增长到几十甚至上百个，如何实现服务发现、集中管理所有配置，并在无需重启服务的情况下完成动态更新，成为首要难题。
		- [[Nacos]]
	- **服务间通信：**
		- 在微服务架构中，系统被拆分为多个功能独立、可单独部署的服务模块，每个服务专注于某一业务职责。这意味着它们不能直接调用彼此的方法，只能通过网络进行通信。
		- [[OpenFeign]]
	- **系统网关：**
		- 在微服务架构中，系统网关（也称为 API 网关）是连接客户端与后端服务的关键组件，承担着统一入口、请求路由、安全校验等核心职责。
		- **类比：**
			- 想象一下，一个大型的现代化城市（你的整个微服务系统），里面有无数个功能各异的建筑（用户服务、商品服务、订单服务等）。
			- 如果没有统一的规划，外部的访客（客户端，如手机App、网页）想要办事，就必须知道每个建筑的具体位置，并且自己开车在城市复杂的路网中穿行，每到一栋建筑还要单独进行一次身份核查。这显然是混乱、低效且不安全的。
			- 此时，系统网关就像城市的“中央交通枢纽 + 安检入口”：
				- **中央交通枢纽：**所有的外部访客都必须先到达这里。枢纽的指示牌（路由规则）会清楚地告诉他们，要去“市民中心”（用户服务）该走哪条专属通道，要去“购物中心”（商品服务）该走另一条。访客无需关心内部道路的复杂性。
				- **统一安检入口：**在进入专属通道前，所有人都要在枢纽入口接受统一的安全检查（身份认证、权限校验）。只有合法的访客才能进入。
			- 所以，系统网关是一个位于客户端和后端微服务之间的服务器，它是所有外部请求进入微服务系统的唯一入口。
		- **作用：**
			- **统一入口与路由转发：**
				- 将所有来自外部客户端（Web、App 等）的请求，根据预设的规则（如 URL 路径），转发到内部对应的微服务去处理。
				- **对客户端的好处：**客户端无需了解微服务的数量或地址变化，只需与网关交互即可，极大简化开发与维护。
			- **统一安全认证：**
				- 所有请求在网关层完成身份验证和权限判断。
				- **对后端服务的好处：**后端服务可以信任来自网关的请求，无需重复校验，专注于业务处理。
			- **统一流量控制：**
				- **负载均衡：**当某服务有多个实例时，网关可将请求均匀分配至负载较低的实例。
				- **请求限流：**当某接口访问量激增时，网关可限制请求频率，防止服务过载，保障系统稳定。
		- [[Spring Cloud Gateway]]
	- **服务容错与保护：**
		- 确保在不可避免的局部故障发生时，整个系统依然能够保持核心功能的可用性，防止“雪崩效应”的发生。
		- **微服务雪崩：**
			- 微服务雪崩是指当某个服务变慢或不可用时，会阻塞其上游服务的调用线程，导致线程池资源逐步被耗尽并陷入瘫痪，形成连锁反应，最终引发整个系统的崩溃。
			- 比如，积分服务响应变慢，会导致用户服务在调用积分服务时的线程被长期占用，无法及时释放。随着请求不断涌入，用户服务的线程池资源迅速被阻塞调用占满，无法处理新的请求。此时，订单服务在同步调用用户服务时也会被卡住，逐步拖垮自身的线程池，最终导致整个下单流程从内部到外部全面崩溃。
		- **超时控制：**
			- 为每一次远程服务调用设置一个明确的等待时间上限。
			- 防止单个请求因为下游服务响应缓慢而无限期地等待，将调用线程“套牢”、“拖死”。
			- **比喻：**你给朋友打电话，规定自己手机铃声只响 30 秒。如果 30 秒内没人接，你就会主动挂断，然后去做别的事情，而不是一直把电话举在耳边等下去。
			- **实现方式：**所有的 RPC 框架（如 OpenFeign）和 HTTP 客户端都支持配置请求超时。
		- **舱壁模式：**
			- 将系统资源（主要是线程）进行划分，为调用不同的下游服务分配独立的、有限的资源池。
			- 防止因某一个下游服务（“坏邻居”）的故障，耗尽当前服务的所有线程资源，从而影响到对其他健康服务（“好邻居”）的调用。
			- **比喻：**豪华游轮的船体被分成了很多个独立的防水隔舱（舱壁）。即使其中一个隔舱因为撞上冰山而进水，水也不会流到其他隔舱里，从而保证了整艘船不会沉没。
			- **实现方式：**
				- **信号量隔离：**用一个“计数器”（信号量）来限制调用某个依赖的并发线程数。例如，信号量大小为 10，就表示最多只允许 10 个线程同时调用该依赖。
		- **熔断降级：**
			- 它像一个家用的“空气开关”。持续监控对某个下游服务的调用状况（如错误率、慢调用比例），当状况恶化到一定阈值时，就主动“拉闸跳闸”（即熔断），在接下来的一段时间内，所有对该服务的调用都会被直接拒绝，执行降级逻辑。
			- **快速失败：**避免在明知下游服务已出问题的情况下，还徒劳地发起网络调用。
			- **自我修复：**给下游故障服务一段“喘息”和恢复的时间，避免被持续的请求压垮。
			- **熔断器的三种状态：**
				- **Closed（闭合）：**正常状态，允许所有请求通过。
				- **Open（断开）：**熔断状态，所有请求都会被立即拦截，执行降级逻辑。
				- **Half-Open（半开）：**试探状态。在熔断一段时间后，会尝试放行少量请求去探测下游服务是否恢复。如果成功，则关闭熔断器；如果失败，则继续保持断开状态。
			- **降级（Degradation）：**指的是触发了熔断或限流后，系统提供的一个“备用方案”，而不是直接抛出冷冰冰的错误。常见的降级逻辑有：返回一个缓存数据、返回一个默认值、或者返回一个友好的提示。
		- **流量控制 / 限流：**
			- 根据预设的规则（如 QPS、并发数），对访问某个接口或资源的请求流量进行限制。
			- 主动地“拦住”过多流量，保护服务不被意料之外的流量洪峰（如秒杀活动、恶意攻击）所冲垮。
		- [[Sentinel]]
	- **分布式事务：**
		- 一个业务流程往往涉及多个微服务，每个微服务操作各自独立的数据库。为了确保数据一致性，当其中任意一个微服务的事务失败时，必须确保同组的其它服务的事务一并回滚，避免出现部分成功、部分失败的异常状态。
		- **分布式事务问题：**
			- “用户下单”这个操作看似简单，但在微服务架构下，往往需要多个服务协同配合，通常涉及以下三个服务：
				- 订单服务：在订单数据库中创建一条订单记录。
				- 库存服务：在商品数据库中扣减对应商品的库存。
				- 账户服务：在用户数据库中扣减用户的账户余额。
			- 这三个步骤必须具备原子性：要么全部执行成功，要么全部回滚。
			- **在单体架构中：**这非常简单。因为所有操作都连接同一个数据库，我们可以用一个数据库事务（`@Transactional`）将它们包裹起来，轻松实现 ACID。
			- **在微服务架构中：**灾难来了。订单、库存和账户分别属于不同的服务，连接着不同的数据库。Java 的 `@Transactional` 只能控制单个数据库的事务，无法跨越网络和多个数据库。
			- 这会导致严重的数据一致性问题：
				- 如果库存扣减成功了，账户余额也扣减成功了，但在最后一步，订单服务因为网络抖动没能成功创建订单记录，怎么办？
				- 此时，用户的钱和商品的库存都“凭空消失”了，但却没有生成订单。这是灾难性的。
			- Seata 的使命，正是为了解决这种跨服务、跨数据库场景下的数据一致性问题，保障分布式事务的可靠性。
		- [[Seata]]
	- **可观测性：**
		-
	- 学习 Spring Cloud 的核心，其实就是理解和掌握这些关键组件（如 Nacos、Gateway、OpenFeign、Sentinel 等）分别是做什么的、为什么需要它们，以及如何配置和使用它们。
-